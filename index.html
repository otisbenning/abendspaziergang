<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>K√∂lner Abendspaziergang</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            line-height: 1.6;
            overflow-x: hidden;
        }

        .container {
            max-width: 100vw;
            margin: 0 auto;
            min-height: 100vh;
            background: white;
            box-shadow: 0 0 30px rgba(0,0,0,0.3);
        }

        header {
            background: linear-gradient(135deg, #dc2626 0%, #991b1b 100%);
            color: white;
            padding: 1rem;
            text-align: center;
            position: sticky;
            top: 0;
            z-index: 1000;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }

        h1 {
            font-size: 1.8rem;
            margin-bottom: 0.5rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .subtitle {
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .tour-id-display {
            background: rgba(255,255,255,0.2);
            padding: 0.5rem;
            border-radius: 4px;
            margin-top: 0.5rem;
            font-size: 0.8rem;
        }

        .connection-status {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-left: 8px;
        }

        .connection-status.online {
            background: #10b981;
        }

        .connection-status.offline {
            background: #dc2626;
        }

        .connection-status.connecting {
            background: #f59e0b;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .progress-container {
            background: rgba(255,255,255,0.2);
            height: 8px;
            border-radius: 4px;
            margin-top: 1rem;
            overflow: hidden;
        }

        .progress-bar {
            background: #fbbf24;
            height: 100%;
            width: 0%;
            border-radius: 4px;
            transition: width 0.5s ease;
        }

        .main-content {
            padding: 0;
            padding-bottom: 80px; /* Space for fixed navigation */
        }

        /* Fixed Navigation */
        .tab-container {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            display: flex;
            background: linear-gradient(135deg, #dc2626 0%, #991b1b 100%);
            box-shadow: 0 -2px 15px rgba(0,0,0,0.2);
            z-index: 1001;
            overflow-x: auto;
        }

        .tab {
            flex: 1;
            padding: 0.8rem 0.3rem;
            text-align: center;
            cursor: pointer;
            background: transparent;
            border: none;
            font-weight: 600;
            color: rgba(255,255,255,0.8);
            transition: all 0.3s;
            font-size: 0.75rem;
            white-space: nowrap;
            min-width: 60px;
            touch-action: manipulation;
            position: relative;
        }

        .tab.active {
            background: rgba(255,255,255,0.2);
            color: white;
            border-top: 3px solid #fbbf24;
        }

        .tab.admin {
            background: rgba(245, 158, 11, 0.3);
            color: #fbbf24;
        }

        .tab.admin.active {
            background: #f59e0b;
            color: white;
        }

        /* Notification badge for tabs */
        .tab-notification {
            position: absolute;
            top: 5px;
            right: 8px;
            background: #ef4444;
            color: white;
            border-radius: 50%;
            width: 18px;
            height: 18px;
            font-size: 0.7rem;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            animation: bounce 0.5s;
        }

        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
            40% { transform: translateY(-5px); }
            60% { transform: translateY(-3px); }
        }

        .tab-content {
            display: none;
            padding: 1.5rem;
            min-height: calc(100vh - 200px);
        }

        .tab-content.active {
            display: block;
        }

        .error-panel {
            background: #fef2f2;
            border: 2px solid #fca5a5;
            border-radius: 10px;
            padding: 1rem;
            margin: 1rem 0;
            color: #dc2626;
        }

        .score-display {
            background: linear-gradient(135deg, #e0e7ff 0%, #c7d2fe 100%);
            padding: 1rem;
            border-radius: 10px;
            text-align: center;
            margin: 1rem 0;
            border: 2px solid #8b5cf6;
        }

        .score-number {
            font-size: 2rem;
            font-weight: bold;
            color: #5b21b6;
        }

        .score-label {
            color: #7c3aed;
            margin-top: 0.5rem;
        }

        /* Improved form styles */
        .form-section {
            background: white;
            border: 2px solid #e5e7eb;
            border-radius: 10px;
            padding: 1rem;
            margin: 1rem 0;
        }

        .form-section h3 {
            margin-bottom: 1rem;
            color: #374151;
        }

        .input-group {
            display: flex;
            gap: 0.5rem;
            align-items: stretch;
            margin-bottom: 0.5rem;
            flex-wrap: nowrap;
        }

        .input-group input {
            flex: 1;
            padding: 0.8rem;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            font-size: 1rem;
            min-width: 0;
        }

        .input-group .btn-small {
            flex-shrink: 0;
            white-space: nowrap;
            height: auto;
            align-self: center;
        }

        .team-selector {
            background: white;
            border: 2px solid #e5e7eb;
            border-radius: 10px;
            padding: 1rem;
            margin: 1rem 0;
        }

        .team-option {
            display: flex;
            align-items: center;
            padding: 0.8rem;
            margin: 0.5rem 0;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.3s;
            touch-action: manipulation;
        }

        .team-option:hover {
            background: #f3f4f6;
        }

        .team-option.selected {
            background: #dbeafe;
            border: 2px solid #3b82f6;
        }

        .team-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin-right: 1rem;
        }

        .tour-connection-section {
            background: #f0f9ff;
            border: 2px solid #0ea5e9;
            border-radius: 10px;
            padding: 1rem;
            margin: 1rem 0;
        }

        .qr-code-area {
            text-align: center;
            padding: 1rem;
            background: white;
            border-radius: 8px;
            margin: 1rem 0;
        }

        .share-url {
            background: #f8fafc;
            padding: 0.8rem;
            border-radius: 8px;
            border: 2px dashed #e2e8f0;
            font-family: monospace;
            font-size: 0.9rem;
            word-break: break-all;
            margin: 0.5rem 0;
        }

        .admin-section {
            background: #fef3c7;
            border: 2px solid #f59e0b;
            border-radius: 10px;
            padding: 1rem;
            margin: 1rem 0;
        }

        .admin-password-input {
            width: 100%;
            padding: 0.8rem;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            font-size: 1rem;
            margin: 0.5rem 0;
        }

        .station-card {
            background: white;
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            border-left: 5px solid #dc2626;
            cursor: pointer;
            transition: all 0.3s;
        }

        .station-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
        }

        .station-card.completed {
            border-left-color: #10b981;
            background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%);
        }

        .station-header {
            display: flex;
            align-items: center;
            margin-bottom: 1rem;
        }

        .station-number {
            background: #dc2626;
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            margin-right: 1rem;
            flex-shrink: 0;
        }

        .station-number.completed {
            background: #10b981;
        }

        .station-title {
            flex: 1;
            font-size: 1.3rem;
            font-weight: bold;
            color: #1f2937;
        }

        .station-subtitle {
            color: #6b7280;
            font-size: 0.9rem;
            margin-bottom: 1rem;
        }

        .station-details {
            display: none;
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 2px solid #e5e7eb;
        }

        .station-details.active {
            display: block;
        }

        .detail-section {
            margin-bottom: 1.5rem;
        }

        .detail-section h4 {
            color: #dc2626;
            margin-bottom: 0.8rem;
            font-size: 1.1rem;
            display: flex;
            align-items: center;
        }

        .detail-section h4::before {
            content: "‚ñ∂";
            margin-right: 0.5rem;
            color: #dc2626;
        }

        .photo-challenge {
            background: linear-gradient(135deg, #e0e7ff 0%, #c7d2fe 100%);
            border-radius: 12px;
            padding: 1.5rem;
            margin: 1rem 0;
            border-left: 4px solid #6366f1;
            position: relative;
        }

        .photo-challenge h4 {
            color: #4f46e5;
            margin-bottom: 1rem;
            font-size: 1.2rem;
        }

        .photo-upload-area {
            border: 3px dashed #a5b4fc;
            border-radius: 10px;
            padding: 2rem;
            text-align: center;
            margin: 1rem 0;
            cursor: pointer;
            transition: all 0.3s;
            background: rgba(255,255,255,0.5);
            touch-action: manipulation;
        }

        .photo-upload-area:hover {
            border-color: #6366f1;
            background: rgba(255,255,255,0.8);
        }

        .photo-upload-area.has-photo {
            border-color: #10b981;
            background: #f0fdf4;
        }

        .photo-preview {
            max-width: 100%;
            max-height: 200px;
            border-radius: 8px;
            margin: 1rem 0;
        }

        .ai-rating {
            background: white;
            border-radius: 10px;
            padding: 1.5rem;
            margin: 1rem 0;
            text-align: center;
            border: 2px solid #10b981;
        }

        .rating-score {
            font-size: 3rem;
            font-weight: bold;
            color: #059669;
            margin-bottom: 0.5rem;
        }

        .rating-text {
            color: #047857;
            font-size: 1.1rem;
            margin-bottom: 1rem;
        }

        .rating-details {
            background: #f0fdf4;
            padding: 1rem;
            border-radius: 8px;
            font-size: 0.9rem;
            color: #065f46;
        }

        .image-gallery {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 1rem;
            margin: 1rem 0;
        }

        .gallery-image {
            width: 100%;
            height: 120px;
            background: #f3f4f6;
            border-radius: 8px;
            cursor: pointer;
            transition: transform 0.3s;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            color: #6b7280;
            font-size: 2rem;
        }

        .gallery-image:hover {
            transform: scale(1.05);
        }

        .gallery-item {
            text-align: center;
            position: relative;
        }

        .gallery-item small {
            display: block;
            margin-top: 0.5rem;
            color: #6b7280;
            font-size: 0.8rem;
        }

        .btn {
            background: #dc2626;
            color: white;
            border: none;
            padding: 1rem 2rem;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            width: 100%;
            font-size: 1rem;
            margin-top: 1rem;
            touch-action: manipulation;
        }

        .btn:hover {
            background: #991b1b;
            transform: translateY(-2px);
        }

        .btn:disabled {
            background: #9ca3af;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            background: #6b7280;
        }

        .btn-secondary:hover {
            background: #4b5563;
        }

        .btn-admin {
            background: #f59e0b;
        }

        .btn-admin:hover {
            background: #d97706;
        }

        .btn-small {
            padding: 0.5rem 1rem;
            font-size: 0.9rem;
            width: auto;
            margin: 0.5rem 0.5rem 0.5rem 0;
        }

        .team-ranking {
            background: white;
            border-radius: 12px;
            padding: 1.5rem;
            margin: 1rem 0;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .team-rank-item {
            display: flex;
            align-items: center;
            padding: 1rem;
            margin: 0.5rem 0;
            border-radius: 8px;
            background: #f8fafc;
        }

        .team-rank-item.highlight {
            background: #fef3c7;
            border: 2px solid #f59e0b;
        }

        .rank-position {
            background: #6b7280;
            color: white;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            margin-right: 1rem;
        }

        .rank-position.gold {
            background: #f59e0b;
        }

        .rank-position.silver {
            background: #6b7280;
        }

        .rank-position.bronze {
            background: #d97706;
        }

        #map {
            height: 400px;
            width: 100%;
            border-radius: 10px;
            margin: 1rem 0;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .location-info {
            background: #f0f9ff;
            border: 2px solid #0ea5e9;
            border-radius: 10px;
            padding: 1rem;
            margin: 1rem 0;
        }

        .distance-info {
            font-weight: bold;
            color: #0369a1;
            margin-bottom: 0.5rem;
        }

        .chat-container {
            background: white;
            border-radius: 12px;
            padding: 1rem;
            margin: 1rem 0;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            max-height: 400px;
            overflow-y: auto;
        }

        .chat-message {
            padding: 0.5rem;
            margin: 0.5rem 0;
            border-radius: 8px;
            background: #f8fafc;
            border-left: 3px solid #3b82f6;
        }

        .chat-message.own {
            background: #dbeafe;
            border-left-color: #1d4ed8;
            margin-left: 2rem;
        }

        .chat-message.system {
            background: #fef3c7;
            border-left-color: #f59e0b;
            font-style: italic;
        }

        .chat-input-container {
            display: flex;
            gap: 0.5rem;
            margin-top: 1rem;
            align-items: stretch;
            flex-wrap: nowrap;
        }

        .chat-input {
            flex: 1;
            padding: 0.8rem;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            font-size: 1rem;
            min-width: 0;
        }

        .chat-send {
            padding: 0.8rem 1.5rem;
            background: #3b82f6;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            touch-action: manipulation;
            flex-shrink: 0;
            white-space: nowrap;
        }

        .chat-image-upload {
            background: #6b7280;
            color: white;
            border: none;
            padding: 0.8rem;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            touch-action: manipulation;
            white-space: nowrap;
            flex-shrink: 0;
        }

        .chat-image-container {
            margin: 0.5rem 0;
            border-radius: 8px;
            overflow: hidden;
            max-width: 200px;
        }

        .chat-image {
            width: 100%;
            height: auto;
            cursor: pointer;
            transition: transform 0.3s;
        }

        .chat-image:hover {
            transform: scale(1.05);
        }

        /* Chat Sub-Tabs */
        .chat-sub-tab {
            color: #6b7280;
            border-bottom: 3px solid transparent;
        }

        .chat-sub-tab.active {
            background: white !important;
            color: #dc2626;
            border-bottom: 3px solid #dc2626;
        }

        .admin-chat-tab {
            background: #fef3c7 !important;
            color: #92400e !important;
            border-bottom: 3px solid #f59e0b !important;
            position: relative;
            min-width: 100px;
            font-size: 0.8rem;
            padding: 0.6rem 0.4rem !important;
        }

        .admin-chat-tab.active {
            background: #f59e0b !important;
            color: white !important;
        }

        .admin-chat-tab .close-btn {
            position: absolute;
            top: 2px;
            right: 4px;
            background: rgba(220, 38, 38, 0.8);
            color: white;
            border: none;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            font-size: 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .admin-chat-section {
            background: #fef3c7;
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1rem;
        }

        .chat-section {
            display: none;
        }

        .chat-section.active {
            display: block;
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #059669;
            color: white;
            padding: 1rem;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            z-index: 10000;
            animation: slideIn 0.5s ease;
            max-width: 300px;
            cursor: pointer;
        }

        .notification.error {
            background: #dc2626;
        }

        .notification.warning {
            background: #f59e0b;
        }

        .notification.clickable {
            border: 2px solid rgba(255,255,255,0.3);
        }

        .notification.clickable:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.3);
        }

        /* Admin-specific styles */
        .admin-content-editor {
            background: white;
            border-radius: 12px;
            padding: 1.5rem;
            margin: 1rem 0;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .admin-station-editor {
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            padding: 0;
            margin: 1rem 0;
            overflow: hidden;
        }

        .admin-station-header {
            background: #f9fafb;
            padding: 1rem;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #e5e7eb;
            transition: background 0.3s;
        }

        .admin-station-header:hover {
            background: #f3f4f6;
        }

        .admin-station-header.expanded {
            background: #fef3c7;
        }

        .admin-station-content {
            padding: 1rem;
            display: none;
        }

        .admin-station-content.expanded {
            display: block;
        }

        .admin-expand-icon {
            transition: transform 0.3s;
            font-size: 1.2rem;
        }

        .admin-expand-icon.expanded {
            transform: rotate(90deg);
        }

        .admin-input {
            width: 100%;
            padding: 0.8rem;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            font-size: 1rem;
            margin: 0.5rem 0;
        }

        .admin-textarea {
            width: 100%;
            min-height: 120px;
            padding: 0.8rem;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            font-size: 1rem;
            margin: 0.5rem 0;
            resize: vertical;
        }

        .admin-lat-lng {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
        }

        /* Admin Popup Styles */
        .admin-popup-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 20000;
            animation: fadeIn 0.5s ease;
        }

        .admin-popup {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            color: white;
            padding: 2rem;
            border-radius: 16px;
            max-width: 400px;
            width: 90%;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            position: relative;
            animation: popIn 0.5s ease;
        }

        .admin-popup h3 {
            margin-bottom: 1rem;
            font-size: 1.5rem;
        }

        .admin-popup p {
            margin-bottom: 1.5rem;
            font-size: 1.1rem;
            line-height: 1.6;
        }

        .admin-popup-close {
            background: white;
            color: #f59e0b;
            border: none;
            padding: 0.8rem 2rem;
            border-radius: 25px;
            font-weight: bold;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.3s;
        }

        .admin-popup-close:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(255,255,255,0.3);
        }

        .hidden {
            display: none !important;
        }

        .address-result {
            transition: all 0.3s;
        }

        .address-result:hover {
            background: #f3f4f6 !important;
            transform: translateX(2px);
        }

        .address-result:last-child {
            border-bottom: none !important;
        }

        /* Location map specific styles */
        #location-map-container {
            position: relative;
        }

        .location-map-overlay {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.9);
            padding: 0.5rem;
            border-radius: 6px;
            font-size: 0.8rem;
            color: #374151;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            z-index: 1000;
        }

        .file-input {
            display: none;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes popIn {
            from { transform: scale(0.8); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }

        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        @media (max-width: 768px) {
            .container {
                box-shadow: none;
            }
            
            h1 {
                font-size: 1.5rem;
            }
            
            .tab {
                font-size: 0.7rem;
                padding: 0.8rem 0.2rem;
            }
            
            .tab-content {
                padding: 1rem;
            }
            
            .station-card {
                padding: 1rem;
            }
            
            .image-gallery {
                grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            }
        }

        .team-rename-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            animation: fadeIn 0.3s ease;
        }

        .team-rename-content {
            background: white;
            border-radius: 16px;
            padding: 2rem;
            max-width: 400px;
            width: 90%;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            animation: popIn 0.3s ease;
        }

        .team-members-list {
            background: #f8fafc;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            max-height: 200px;
            overflow-y: auto;
        }

        .team-member-item {
            display: flex;
            align-items: center;
            padding: 0.5rem;
            margin: 0.25rem 0;
            background: white;
            border-radius: 6px;
            font-size: 0.9rem;
        }

        .auto-assign-section {
            background: #fef3c7;
            border: 2px solid #f59e0b;
            border-radius: 10px;
            padding: 1rem;
            margin: 1rem 0;
        }

        .notification.info {
            background: #3b82f6;
        }

        .notification.warning {
            background: #f59e0b;
        }

    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1 id="tourTitle">üèõÔ∏è K√∂lner Abendspaziergang</h1>
            <p class="subtitle" id="tourSubtitle">Entdecke 2000 Jahre Stadtgeschichte</p>
            <div class="tour-id-display">
                Tour: <span id="currentTourId">Wird geladen...</span>
                <span class="connection-status connecting" id="connectionStatus" title="Verbindung wird aufgebaut..."></span>
            </div>
            <div class="progress-container">
                <div class="progress-bar" id="progressBar"></div>
            </div>
        </header>

        <div class="main-content">
            <!-- Overview Tab -->
            <div id="overview" class="tab-content active">
                <div id="errorPanel" class="error-panel hidden">
                    <h4>‚ö†Ô∏è Verbindungsproblem</h4>
                    <p id="errorMessage">Verbindung zu Firebase wird aufgebaut...</p>
                    <button class="btn btn-secondary btn-small" onclick="retryConnection()">üîÑ Erneut versuchen</button>
                </div>

                <div class="score-display">
                    <div class="score-number" id="totalScore">0</div>
                    <div class="score-label">Foto-Punkte gesammelt</div>
                </div>

                <!-- 1. Name -->
                <div class="form-section">
                    <h3>üë§ Dein Name:</h3>
                    <div class="input-group">
                        <input type="text" id="userNameInput" placeholder="Dein Name..." maxlength="20">
                        <button class="btn btn-secondary btn-small" onclick="changeUserName()">üíæ Speichern</button>
                    </div>
                    <p style="font-size: 0.8rem; color: #6b7280; margin-top: 0.5rem;">Aktuell: <span id="currentUserName">Tourist_xyz</span></p>
                </div>

                <!-- 2. Team -->
                <div class="team-selector" id="teamSelector">
                    <h3>üì∏ W√§hle dein Team:</h3>
                    <div id="teamOptions">
                        <!-- Team options will be generated dynamically -->
                    </div>
                    <div style="margin-top: 1rem; text-align: center;">
                        <button class="btn btn-secondary btn-small" onclick="showTeamNameEditor()" style="background: #8b5cf6;">
                            ‚úèÔ∏è Team umbenennen
                        </button>
                    </div>
                </div>

                <!-- Current Team Display -->
                <div id="currentTeamDisplay" class="form-section" style="display: none;">
                    <h3>üë• Dein aktuelles Team:</h3>
                    <div id="currentTeamInfo" style="display: flex; align-items: center; padding: 1rem; background: #f0f9ff; border-radius: 8px; margin-bottom: 1rem;">
                        <!-- Current team info will be displayed here -->
                    </div>
                    <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                        <button class="btn btn-secondary btn-small" onclick="showTeamSelector()">
                            üîÑ Team wechseln
                        </button>
                        <button class="btn btn-secondary btn-small" onclick="showTeamNameEditor()" style="background: #8b5cf6;">
                            ‚úèÔ∏è Team umbenennen
                        </button>
                    </div>
                </div>

                <!-- 3. Start Button -->
                <button class="btn" onclick="startTour()">üöÄ Tour starten</button>

                <!-- 4. Link teilen -->
                <div class="tour-connection-section">
                    <h3 style="margin-bottom: 1rem; color: #0369a1;">üîó Mit anderen Ger√§ten verbinden</h3>
                    
                    <div class="qr-code-area">
                        <p><strong>Teile diese URL mit anderen Teilnehmern:</strong></p>
                        <div class="share-url" id="shareUrl">App wird gestartet...</div>
                        <button class="btn btn-secondary btn-small" onclick="copyShareUrl()">üìã URL kopieren</button>
                        <button class="btn btn-secondary btn-small" onclick="shareViaWhatsApp()">üì± WhatsApp teilen</button>
                    </div>
                    
                    <p style="font-size: 0.9rem; color: #6b7280; text-align: center;">
                        üí° Alle die diesen Link √∂ffnen, k√∂nnen miteinander chatten und sehen Live-Rankings!
                    </p>
                </div>

                <!-- 5. Admin Passwort -->
                <div class="admin-section">
                    <h3 style="margin-bottom: 1rem; color: #92400e;">üîê Admin-Zugang</h3>
                    <input type="password" class="admin-password-input" id="adminPassword" placeholder="Admin-Passwort eingeben">
                    <button class="btn btn-admin" onclick="loginAdmin()">Admin-Modus aktivieren</button>
                </div>

                <div style="background: #f8fafc; padding: 1.5rem; border-radius: 12px; margin: 1.5rem 0;" id="tourInfoSection">
                    <h3 style="color: #1f2937; margin-bottom: 1rem;">üìã Tour-Informationen</h3>
                    <div id="tourInfoContent">
                        <p><strong>‚è∞ Dauer:</strong> <span id="tourDuration">ca. 3,5 Stunden</span></p>
                        <p><strong>üìç Start:</strong> <span id="tourStart">Heumarkt, 19:30 Uhr</span></p>
                        <p><strong>üéØ Ziel:</strong> <span id="tourEnd">Alte Bastion</span></p>
                        <p><strong>üë• Teilnehmer:</strong> <span id="tourParticipants">15-25 Personen</span></p>
                        <p><strong>üì∏ Ziel:</strong> <span id="tourGoal">Sammle die besten Foto-Punkte!</span></p>
                    </div>
                </div>
            </div>

            <!-- Stations Tab -->
            <div id="stations" class="tab-content">
                <div id="stationsList">
                    <!-- Stations will be generated here -->
                </div>
            </div>

            <!-- Ranking Tab -->
            <div id="ranking" class="tab-content">
                <div class="team-ranking">
                    <h3 style="color: #1f2937; margin-bottom: 1rem;">üèÜ Live-Ranking</h3>
                    <div id="rankingList">
                        <!-- Ranking will be generated here -->
                    </div>
                </div>

                <div style="background: white; border-radius: 12px; padding: 1.5rem; margin: 1.5rem 0; box-shadow: 0 4px 15px rgba(0,0,0,0.1);">
                    <h3 style="color: #1f2937; margin-bottom: 1rem;">üì∏ KI-Punktesystem</h3>
                    <ul style="margin-left: 1.5rem; color: #4b5563;">
                        <li><strong>Technische Qualit√§t:</strong> Sch√§rfe, Belichtung, Komposition (0-40 Punkte)</li>
                        <li><strong>Kreativit√§t:</strong> Perspective, Originalit√§t (0-30 Punkte)</li>
                        <li><strong>Stadtbezug:</strong> Erkannte Sehensw√ºrdigkeiten (0-20 Punkte)</li>
                        <li><strong>Personen/Gruppenfoto:</strong> Bonus f√ºr Teamarbeit (+10 Punkte)</li>
                    </ul>
                </div>

                <div style="background: white; border-radius: 12px; padding: 1.5rem; margin: 1.5rem 0; box-shadow: 0 4px 15px rgba(0,0,0,0.1); text-align: center;">
                    <h3 style="color: #1f2937; margin-bottom: 1rem;">üì± Foto-Verwaltung</h3>
                    <button class="btn btn-secondary" onclick="downloadAllTourPhotos()" style="background: #8b5cf6;">
                        üíæ Alle Tour-Fotos herunterladen
                    </button>
                    <p style="font-size: 0.9rem; color: #6b7280; margin-top: 0.5rem;">
                        üí° Lade alle deine Challenge-Fotos als Sammlung herunter
                    </p>
                </div>

            </div>

            <!-- Chat Tab -->
            <div id="chat" class="tab-content">
                <!-- Chat Sub-Navigation -->
                <div style="display: flex; background: #f8fafc; border-radius: 8px; margin-bottom: 1rem; overflow: hidden; flex-wrap: wrap;" id="chatTabContainer">
                    <button class="chat-sub-tab active" onclick="showChatTab('main', this)" style="flex: 1; min-width: 120px; padding: 0.8rem; border: none; background: transparent; cursor: pointer; font-weight: bold; transition: all 0.3s;">
                        üí¨ Haupt-Chat
                    </button>
                    <button class="chat-sub-tab" onclick="showChatTab('team', this)" id="teamChatTab" style="flex: 1; min-width: 120px; padding: 0.8rem; border: none; background: transparent; cursor: pointer; font-weight: bold; transition: all 0.3s; display: none;">
                        üë• Team-Chat
                    </button>
                    <button class="chat-sub-tab" onclick="showChatTab('admin', this)" id="adminChatTab" style="flex: 1; min-width: 120px; padding: 0.8rem; border: none; background: transparent; cursor: pointer; font-weight: bold; transition: all 0.3s;">
                        üë§ Admin
                    </button>
                    <!-- Dynamic admin chat tabs will be added here -->
                </div>

                <!-- Main Chat -->
                <div id="mainChatContainer" class="chat-section active">
                    <div class="chat-container" id="chatContainer">
                        <div class="chat-message system">
                            <strong>System:</strong> Willkommen im Tour-Chat! üëã<br>
                            <small>Chat funktioniert zwischen allen Ger√§ten mit derselben Tour-URL.</small>
                            <span class="timestamp">jetzt</span>
                        </div>
                    </div>
                    
                    <!-- Chat Moderation Notice -->
                    <div id="chatModerationNotice" class="hidden" style="background: #fef3c7; border: 2px solid #f59e0b; border-radius: 8px; padding: 1rem; margin: 1rem 0; text-align: center;">
                        <h4 style="color: #92400e; margin-bottom: 0.5rem;">üõ°Ô∏è Chat ist moderiert</h4>
                        <p style="color: #92400e; margin: 0;">Der Chat wurde vom Admin gesperrt. Nachrichten k√∂nnen aktuell nicht gesendet werden.</p>
                    </div>
                    
                    <div class="chat-input-container" id="mainChatInput">
                        <input type="text" class="chat-input" id="chatInput" placeholder="Nachricht eingeben..." maxlength="200">
                        <button class="chat-image-upload" onclick="selectChatImage()">üì∑</button>
                        <button class="chat-send" onclick="sendMessage()">Senden</button>
                    </div>
                </div>

                <!-- Team Chat -->
                <div id="teamChatContainer" class="chat-section" style="display: none;">
                    <div class="chat-container" id="teamChatMessages">
                        <div class="chat-message system">
                            <strong>Team-Chat:</strong> Hier k√∂nnt ihr euch als Team koordinieren! üë•<br>
                            <small>Nur euer Team kann diese Nachrichten sehen.</small>
                            <span class="timestamp">jetzt</span>
                        </div>
                    </div>
                    
                    <div class="chat-input-container" id="teamChatInput">
                        <input type="text" class="chat-input" id="teamChatInputField" placeholder="Team-Nachricht eingeben..." maxlength="200">
                        <button class="chat-image-upload" onclick="selectTeamChatImage()">üì∑</button>
                        <button class="chat-send" onclick="sendTeamMessage()">Senden</button>
                    </div>
                </div>
                <!-- Admin Direct Message -->
                <div id="adminChatContainer" class="chat-section" style="display: none;">
                    <div class="admin-chat-section">
                        <div class="chat-container" id="adminChatMessages">
                            <div class="chat-message system">
                                <strong>Admin-Chat:</strong> Direkter Kontakt zum Tour-Admin üë§<br>
                                <small>Nur du und der Admin k√∂nnen diese Nachrichten sehen.</small>
                                <span class="timestamp">jetzt</span>
                            </div>
                        </div>
                        
                        <div class="chat-input-container" id="adminChatInput">
                            <input type="text" class="chat-input" id="adminChatInputField" placeholder="Nachricht an Admin..." maxlength="200">
                            <button class="chat-image-upload" onclick="selectAdminChatImage()">üì∑</button>
                            <button class="chat-send" onclick="sendAdminMessage()">An Admin</button>
                        </div>
                    </div>
                </div>

                <!-- Dynamic Admin Chat Containers -->
                <div id="dynamicAdminChats">
                    <!-- Individual user chat containers will be created here dynamically -->
                </div>

                <input type="file" class="file-input" id="adminChatImageInput" accept="image/*" onchange="handleAdminChatImageUpload(event)">

                <input type="file" class="file-input" id="chatImageInput" accept="image/*" onchange="handleChatImageUpload(event)">
                <input type="file" class="file-input" id="teamChatImageInput" accept="image/*" onchange="handleTeamChatImageUpload(event)">
                
                <div style="margin-top: 1rem; text-align: center; color: #6b7280; font-size: 0.9rem;">
                    üí° Nachrichten und Bilder werden live synchronisiert
                </div>
            </div>

            <!-- Map Tab -->
            <div id="map-tab" class="tab-content">
                <div class="location-info">
                    <div class="distance-info" id="distanceInfo">üìç Standort wird ermittelt...</div>
                    <p>üí° Tipp: Erlaube Standortzugriff f√ºr Navigation</p>
                </div>
                <div id="map"></div>
                <button class="btn" onclick="centerOnUser()">üìç Zu meinem Standort</button>
            </div>

            <!-- Admin Tab -->
            <div id="admin" class="tab-content">
                <!-- Admin Sub-Navigation -->
                <div style="display: flex; background: #f8fafc; border-radius: 8px; margin-bottom: 1rem; overflow: hidden; flex-wrap: wrap;" id="adminTabContainer">
                    <button class="admin-sub-tab active" onclick="showAdminTab('live', this)" style="flex: 1; min-width: 120px; padding: 0.8rem; border: none; background: transparent; cursor: pointer; font-weight: bold; transition: all 0.3s; color: #dc2626; border-bottom: 3px solid #dc2626;">
                        üì± Live-Admin
                    </button>
                    <button class="admin-sub-tab" onclick="showAdminTab('planning', this)" style="flex: 1; min-width: 120px; padding: 0.8rem; border: none; background: transparent; cursor: pointer; font-weight: bold; transition: all 0.3s; color: #6b7280; border-bottom: 3px solid transparent;">
                        üó∫Ô∏è Streckenplanung
                    </button>
                    <button class="admin-sub-tab" onclick="showAdminTab('settings', this)" style="flex: 1; min-width: 120px; padding: 0.8rem; border: none; background: transparent; cursor: pointer; font-weight: bold; transition: all 0.3s; color: #6b7280; border-bottom: 3px solid transparent;">
                        ‚öôÔ∏è Tour-Einstellungen
                    </button>
                </div>

                <!-- Live-Admin Section -->
                <div id="liveAdminSection" class="admin-section active">
                    <div style="background: #fef3c7; padding: 1.5rem; border-radius: 12px; margin-bottom: 1.5rem;">
                        <h3 style="color: #92400e; margin-bottom: 1rem;">üì± Live-Admin</h3>
                        <p>Schneller Zugriff f√ºr unterwegs - Chat-Moderation und Live-Updates</p>
                    </div>

                    <!-- Quick Actions -->
                    <div style="background: white; border-radius: 12px; padding: 1.5rem; margin: 1.5rem 0; box-shadow: 0 4px 15px rgba(0,0,0,0.1);">
                        <h4 style="color: #1f2937; margin-bottom: 1rem;">üöÄ Schnellaktionen</h4>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem;">
                            <button class="btn btn-admin btn-small" onclick="toggleTourChatLock()" id="tourChatLockBtn">
                                <span id="tourChatLockText">üîì Tour-Chat freigeben</span>
                            </button>
                            <button class="btn btn-admin btn-small" onclick="toggleChatModeration()">
                                <span id="chatModerationText">üõ°Ô∏è Chat sperren</span>
                            </button>
                            <button class="btn btn-secondary btn-small" onclick="sendAdminAnnouncement()">üì¢ Ank√ºndigung senden</button>
                            <button class="btn btn-secondary btn-small" onclick="clearAllChatMessages()">üóëÔ∏è Chat l√∂schen</button>
                            <button class="btn btn-secondary btn-small" onclick="showQuickStationUpdate()">‚ö° Station schnell bearbeiten</button>
                            <button class="btn btn-secondary btn-small" onclick="autoAssignTeams()" style="background: #8b5cf6;">üé≤ Teams auto-verteilen</button>
                        </div>
                    </div>

                    <!-- Live Statistics -->
                    <div style="background: white; border-radius: 12px; padding: 1.5rem; margin: 1.5rem 0; box-shadow: 0 4px 15px rgba(0,0,0,0.1);">
                        <h4 style="color: #1f2937; margin-bottom: 1rem;">üìä Live-Statistiken</h4>
                        <div id="adminStats" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 1rem;">
                            <div style="text-align: center; padding: 1rem; background: #f0f9ff; border-radius: 8px;">
                                <div style="font-size: 2rem; font-weight: bold; color: #0369a1;" id="activeUsers">-</div>
                                <div style="color: #6b7280; font-size: 0.9rem;">Aktive Nutzer</div>
                            </div>
                            <div style="text-align: center; padding: 1rem; background: #f0fdf4; border-radius: 8px;">
                                <div style="font-size: 2rem; font-weight: bold; color: #059669;" id="totalMessages">-</div>
                                <div style="color: #6b7280; font-size: 0.9rem;">Nachrichten</div>
                            </div>
                            <div style="text-align: center; padding: 1rem; background: #fef3c7; border-radius: 8px;">
                                <div style="font-size: 2rem; font-weight: bold; color: #d97706;" id="completedStations">-</div>
                                <div style="color: #6b7280; font-size: 0.9rem;">Abgeschlossen</div>
                            </div>
                            <div style="text-align: center; padding: 1rem; background: #fef2f2; border-radius: 8px;">
                                <div style="font-size: 2rem; font-weight: bold; color: #dc2626;" id="uploadedPhotos">-</div>
                                <div style="color: #6b7280; font-size: 0.9rem;">Fotos</div>
                            </div>
                        </div>
                        <button class="btn btn-secondary btn-small" onclick="refreshAdminStats()" style="margin-top: 1rem;">üîÑ Aktualisieren</button>
                    </div>
                </div>

                <!-- Planning Section -->
                <div id="planningSection" class="admin-section" style="display: none;">
                    <div style="background: #e0e7ff; padding: 1.5rem; border-radius: 12px; margin-bottom: 1.5rem;">
                        <h3 style="color: #4338ca; margin-bottom: 1rem;">üó∫Ô∏è Streckenplanung</h3>
                        <p>Detaillierte Bearbeitung der Stationen und Inhalte</p>
                    </div>

                    <!-- Content Management -->
                    <div class="admin-content-editor">
                        <h4 style="color: #1f2937; margin-bottom: 1rem;">üìù Stationen-Content bearbeiten</h4>
                        <div id="adminContentEditor">
                            <!-- Content editor will be generated here -->
                        </div>
                    </div>

                    <!-- Tour Export/Import -->
                    <div style="background: white; border-radius: 12px; padding: 1.5rem; margin: 1.5rem 0; box-shadow: 0 4px 15px rgba(0,0,0,0.1);">
                        <h4 style="color: #1f2937; margin-bottom: 1rem;">üì¶ Tour Export/Import</h4>
                        <div style="display: flex; gap: 1rem; flex-wrap: wrap; margin-bottom: 1rem;">
                            <button class="btn btn-admin btn-small" onclick="exportTourData()">üì§ Tour exportieren</button>
                            <button class="btn btn-secondary btn-small" onclick="document.getElementById('importFileInput').click()">üì• Tour importieren</button>
                        </div>
                        <input type="file" id="importFileInput" accept=".json" style="display: none;" onchange="importTourData(event)">
                        <p style="font-size: 0.9rem; color: #6b7280;">
                            üí° Exportiert alle Stationen, Texte, Bilder und Audio-Dateien als JSON-Datei.
                        </p>
                    </div>

                    <div style="background: white; border-radius: 12px; padding: 1.5rem; margin: 1.5rem 0; box-shadow: 0 4px 15px rgba(0,0,0,0.1);">
                        <h4 style="color: #1f2937; margin-bottom: 1rem;">üîÑ Tour zur√ºcksetzen</h4>
                        <button class="btn btn-secondary" onclick="resetTour()">Alle Daten zur√ºcksetzen</button>
                    </div>
                </div>

                <!-- Settings Section -->
                <div id="settingsSection" class="admin-section" style="display: none;">
                    <div style="background: #f0fdf4; padding: 1.5rem; border-radius: 12px; margin-bottom: 1.5rem;">
                        <h3 style="color: #059669; margin-bottom: 1rem;">‚öôÔ∏è Tour-Einstellungen</h3>
                        <p>Grundlegende Einstellungen der Tour anpassen</p>
                    </div>

                    <!-- Tour Basic Settings -->
                    <div style="background: white; border-radius: 12px; padding: 1.5rem; margin: 1.5rem 0; box-shadow: 0 4px 15px rgba(0,0,0,0.1);">
                        <h4 style="color: #1f2937; margin-bottom: 1rem;">üìã Tour-Grunddaten</h4>
                        
                        <div style="margin-bottom: 1rem;">
                            <label style="display: block; font-weight: bold; margin-bottom: 0.5rem;">Tour-Titel:</label>
                            <input type="text" class="admin-input" id="editTourTitle" value="üèõÔ∏è K√∂lner Abendspaziergang" placeholder="Tour-Titel eingeben">
                        </div>
                        
                        <div style="margin-bottom: 1rem;">
                            <label style="display: block; font-weight: bold; margin-bottom: 0.5rem;">Untertitel:</label>
                            <input type="text" class="admin-input" id="editTourSubtitle" value="Entdecke 2000 Jahre Stadtgeschichte" placeholder="Untertitel eingeben">
                        </div>
                    </div>

                    <!-- Tour Info Settings -->
                    <div style="background: white; border-radius: 12px; padding: 1.5rem; margin: 1.5rem 0; box-shadow: 0 4px 15px rgba(0,0,0,0.1);">
                        <h4 style="color: #1f2937; margin-bottom: 1rem;">‚ÑπÔ∏è Tour-Informationen</h4>
                        
                        <div style="margin-bottom: 1rem;">
                            <label style="display: block; font-weight: bold; margin-bottom: 0.5rem;">‚è∞ Dauer:</label>
                            <input type="text" class="admin-input" id="editTourDuration" value="ca. 3,5 Stunden" placeholder="z.B. ca. 2 Stunden">
                        </div>
                        
                        <div style="margin-bottom: 1rem;">
                            <label style="display: block; font-weight: bold; margin-bottom: 0.5rem;">üìç Start:</label>
                            <input type="text" class="admin-input" id="editTourStart" value="Heumarkt, 19:30 Uhr" placeholder="z.B. Hauptbahnhof, 14:00 Uhr">
                        </div>
                        
                        <div style="margin-bottom: 1rem;">
                            <label style="display: block; font-weight: bold; margin-bottom: 0.5rem;">üéØ Ziel:</label>
                            <input type="text" class="admin-input" id="editTourEnd" value="Alte Bastion" placeholder="z.B. Rheinufer">
                        </div>
                        
                        <div style="margin-bottom: 1rem;">
                            <label style="display: block; font-weight: bold; margin-bottom: 0.5rem;">üë• Teilnehmer:</label>
                            <input type="text" class="admin-input" id="editTourParticipants" value="15-25 Personen" placeholder="z.B. 10-20 Personen">
                        </div>
                        
                        <div style="margin-bottom: 1.5rem;">
                            <label style="display: block; font-weight: bold; margin-bottom: 0.5rem;">üì∏ Ziel:</label>
                            <input type="text" class="admin-input" id="editTourGoal" value="Sammle die besten Foto-Punkte!" placeholder="z.B. Erkunde die Geschichte der Stadt">
                        </div>
                        
                        <button class="btn btn-admin" onclick="saveTourSettings()">üíæ Einstellungen speichern</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Fixed Navigation -->
        <div class="tab-container">
            <button class="tab active" onclick="window.showTab('overview', this)">üè†<br><span style="font-size: 0.6rem;">Start</span></button>
            <button class="tab" onclick="window.showTab('stations', this)">üìç<br><span style="font-size: 0.6rem;">Stationen</span></button>
            <button class="tab" onclick="window.showTab('ranking', this)">üèÜ<br><span style="font-size: 0.6rem;">Ranking</span></button>
            <button class="tab" onclick="window.showTab('chat', this)">üí¨<br><span style="font-size: 0.6rem;">Chat</span></button>
            <button class="tab" onclick="window.showTab('map', this)" id="mapTabButton">
            <button class="tab admin hidden" onclick="window.showTab('admin', this)" id="adminTab">‚öôÔ∏è<br><span style="font-size: 0.6rem;">Admin</span></button>
        </div>
    </div>

    <!-- Firebase CDN -->
    <script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-firestore-compat.js"></script>

    <!-- Leaflet for Map -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.js"></script>

    <script>
        
        // Global showTab function - Korrigierte Version mit richtigen IDs
        function showTab(tabName, tabElement) {
            try {
                // Initialize tourApp.state if needed
                if (!window.tourApp) {
                    window.tourApp = { state: { currentTab: 'overview' } };
                }
                if (!window.tourApp.state) {
                    window.tourApp.state = { currentTab: 'overview' };
                }
                
                // Prevent rapid multiple calls
                if (window.showTab.isChanging) {
                    return;
                }
                window.showTab.isChanging = true;
                
                // Update current tab
                window.tourApp.state.currentTab = tabName;
                
                // Update tab appearance
                document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
                if (tabElement) {
                    tabElement.classList.add('active');
                }

                // Update content visibility - korrigierte Version
                document.querySelectorAll('.tab-content').forEach(content => {
                    content.classList.remove('active');
                    content.style.display = 'none';
                });
                
                // Korrekte ID-Zuordnung
                const targetTab = document.getElementById(tabName === 'map' ? 'map-tab' : tabName);
                if (targetTab) {
                    targetTab.classList.add('active');
                    targetTab.style.display = 'block';
                    
                    console.log(`Tab "${tabName}" erfolgreich angezeigt`); // Debug-Log
                    
                    // Special handling for map tab
                    if (tabName === 'map') {
                        setTimeout(() => {
                            if (typeof initMap === 'function') {
                                initMap();
                            }
                            if (window.tourApp && window.tourApp.state && window.tourApp.state.map) {
                                window.tourApp.state.map.invalidateSize();
                            }
                        }, 200);
                    }
                } else {
                    console.error(`Tab element mit ID "${tabName === 'map' ? 'map-tab' : tabName}" nicht gefunden!`);
                }

                // Handle specific tab actions
                if (tabName === 'chat') {
                    if (typeof clearChatNotification === 'function') clearChatNotification();
                    if (window.tourApp.state.currentChatTab === 'team' && typeof clearTeamChatNotification === 'function') {
                        clearTeamChatNotification();
                    }
                }

                if (tabName === 'admin' && window.tourApp.state && window.tourApp.state.isAdmin) {
                    setTimeout(() => {
                        if (typeof generateContentEditor === 'function') generateContentEditor();
                        if (typeof updateRanking === 'function') updateRanking();
                    }, 100);
                }

                if (tabName === 'ranking') {
                    setTimeout(() => {
                        if (typeof updateRanking === 'function') updateRanking();
                    }, 100);
                }
                
                // Release lock after a short delay
                setTimeout(() => {
                    window.showTab.isChanging = false;
                }, 100);
                
            } catch (error) {
                console.error('Error showing tab:', error);
                window.showTab.isChanging = false;
                
                // Fallback: Force show target tab
                const fallbackTab = document.getElementById(tabName === 'map' ? 'map-tab' : tabName);
                if (fallbackTab) {
                    fallbackTab.style.display = 'block';
                }
            }
        }

        // Make globally available immediately
        window.showTab = showTab;
    

    // Firebase Configuration
        const firebaseConfig = {
            apiKey: "AIzaSyC1dTE4AiAKbInq-5f2dy92zWBIOmZ8o9Y",
            authDomain: "koeln-tour.firebaseapp.com",
            projectId: "koeln-tour",
            storageBucket: "koeln-tour.firebasestorage.app",
            messagingSenderId: "297105093618",
            appId: "1:297105093618:web:fa44f3fee94e79d304f16b",
            measurementId: "G-TZBGBEPCVW"
        };

        // Global variables
        let tourApp = {
            state: {
                currentStation: 0,
                completedStations: [],
                totalScore: 0,
                selectedTeam: null,
                teamName: '',
                userLocation: null,
                map: null,
                markers: [],
                uploadedPhotos: [],
                userName: 'Tourist_' + Math.random().toString(36).substr(2, 5),
                tourId: null,
                isAdmin: false,
                syncListeners: [],
                isFirebaseConnected: false,
                connectionRetries: 0,
                maxRetries: 3,
                chatModeration: false,
                chatBlocked: false, // NEW: Chat gesperrt durch Moderation
                tourChatLocked: true, // NEW: Tour-Chat standardm√§√üig gesperrt
                unreadMessages: 0,
                unreadTeamMessages: 0, // NEW: Team-Chat ungelesen
                currentTab: 'overview',
                currentChatTab: 'main' // NEW: main oder team
            },
            
            stations: [
                {
                    id: 1,
                    title: "Heumarkt",
                    subtitle: "Wo alles anfing: 2000 Jahre Migration und Handel",
                    lat: 50.9356, lng: 6.9611,
                    description: "Start der Tour am historischen Heumarkt, einem der geschichtstr√§chtigsten Orte K√∂lns.",
                    photoChallenge: "Mache ein Foto von dir oder deinem Team vor dem Reiterstandbild - zeigt dabei mit Handbewegungen, wie H√§ndler fr√ºher ihre Waren angepriesen haben k√∂nnten!",
                    mainText: `Die Stadt ist ca. 2.000 Jahre alt. CCAA - Colonia Claudia Ara Agrippinensium - wurde 50 n. Chr. von den R√∂mern gegr√ºndet, mithilfe der germanischen Ubier. Das war √ºbrigens eine der ersten erfolgreichen Integration zweier Kulturen in Europa. 

Hier auf dem Heumarkt stehen wir an einem der ehemaligen Einfallstore zur Stadt. Die Markmannsgasse runter, links von der heutigen Deutzer Br√ºcke, befand sich von 1822 bis 1915 die einzige Schiffsbr√ºcke √ºber den Rhein - 42 schwimmende Boote, die √ºber 30 Mal t√§glich f√ºr Schiffe ge√∂ffnet wurden.

Das "Stapelrecht" von 1259 bis 1804 war ein 545 Jahre g√ºltiges Handelsprivileg. Alle Waren auf Schiffen, die an K√∂ln vorbeifahren wollten, mussten drei Tage hier angeboten werden.`,
                    images: [
                        { title: "Heumarkt heute", description: "Moderne Aufnahme des historischen Platzes", url: "" },
                        { title: "K√∂lner Architektur", description: "Typische Rheinische Bauweise", url: "" },
                        { title: "Rheinufer", description: "Blick auf den historischen Handelsweg", url: "" }
                    ],
                    audio: [
                        { title: "Heumarkt Atmosph√§re", description: "Originalaufnahme vom historischen Platz", url: "", type: "audio" },
                        { title: "Geschichte Audio-Guide", description: "Gesprochene F√ºhrung zur Stadtgeschichte", url: "", type: "podcast" }
                    ]
                },
                {
                    id: 2,
                    title: "K√∂lner Dom",
                    subtitle: "Das ewige Bauprojekt und die Verkehrsrevolution",
                    lat: 50.9413, lng: 6.9583,
                    description: "K√∂lns Wahrzeichen und die l√§ngste Baustelle der Welt.",
                    photoChallenge: "Bildet mit eurem Team eine 'menschliche Kathedrale' vor dem Dom - streckt die Arme hoch und formt gotische B√∂gen nach!",
                    mainText: `Der Dom wird seit fast 800 Jahren gebaut - etwas l√§nger als der BER. Die Grundsteinlegung 1248 war K√∂lns Versuch, Paris und andere Gro√üst√§dte zu beeindrucken. K√∂ln war immer reich, aber auch provinziell.

1248-1330 wurden Grundmauern und der Chor fertiggestellt. Dann ging das Geld aus. Fast 300 Jahre stand nur ein riesiger Kran auf dem unvollendeten Turm - eines der ersten gro√üen "paused projects" der Geschichte.

Erst die Romantik des 19. Jahrhunderts und preu√üisches Geld vollendeten den Dom 1880. Der Hauptbahnhof entstand 1894 als einer der modernsten Europas.`,
                    images: [
                        { title: "K√∂lner Dom", description: "Die ber√ºhmten Zwillingst√ºrme", url: "" },
                        { title: "Dom Innenraum", description: "Gotische Architektur", url: "" },
                        { title: "Dom bei Nacht", description: "Beleuchtetes Wahrzeichen", url: "" }
                    ],
                    audio: [
                        { title: "Domglocken", description: "Originalaufnahme der ber√ºhmten Domglocken", url: "", type: "youtube" },
                        { title: "Audio-Guide Dom", description: "Gesprochene F√ºhrung durch die Geschichte", url: "", type: "podcast" }
                    ]
                },
                {
                    id: 3,
                    title: "Altstadt",
                    subtitle: "Macht, Rebellion und eine gro√üe Liebesgeschichte",
                    lat: 50.9369, lng: 6.9572,
                    description: "Das historische Rathaus und die ber√ºhmte Jan-und-Griet-Geschichte.",
                    photoChallenge: "Fotografiert euch am historischen Rathaus und stellt eine romantische Szene nach: Eine Person kniet, eine steht stolz daneben.",
                    mainText: `Der Rathaus-Turm zeigt wichtige Pers√∂nlichkeiten der K√∂lner Geschichte. 1945 zerst√∂rt und wieder aufgebaut. Da auch die Figuren zerst√∂rt waren, w√§hlte eine Kommission neue aus - von √ºber 100 Kandidaten. Alle m√§nnlich.

Oben am Turm seht ihr den "Platz-Jabbeck" - er streckt Autorit√§ten die Zunge raus. So viel Respekt hatten die K√∂lner f√ºr die Obrigkeit.

Die Altstadt erz√§hlt eine der gr√∂√üten deutschen Liebesgeschichten: Jan ist ein armer Knecht, Griet arbeitet auch dort. Er mag sie, sie ihn nicht. Der Krieg beginnt, Jan zieht aus, kommt als ber√ºhmter General zur√ºck.`,
                    images: [
                        { title: "K√∂lner Altstadt", description: "Historische Gassen", url: "" },
                        { title: "Rheinpromenade", description: "Spazierweg mit Domblick", url: "" },
                        { title: "Historisches Rathaus", description: "Gotisches Bauwerk", url: "" }
                    ],
                    audio: [
                        { title: "Altstadt Atmosph√§re", description: "Stra√üenger√§usche der historischen Altstadt", url: "", type: "soundcloud" },
                        { title: "Jan und Griet", description: "Die Liebesgeschichte als H√∂rspiel", url: "", type: "spotify" }
                    ]
                },
                {
                    id: 4,
                    title: "Gro√ü St. Martin",
                    subtitle: "Romanische Kirche und Klostergeschichte",
                    lat: 50.9347, lng: 6.9597,
                    description: "Eine der zw√∂lf gro√üen romanischen Kirchen K√∂lns.",
                    photoChallenge: "Macht ein Foto der imposanten Kircht√ºrme und zeigt dabei mittelalterliche Gebetshaltungen!",
                    mainText: `Gro√ü St. Martin ist eine der beeindruckendsten romanischen Kirchen K√∂lns. Der markante Vierungsturm pr√§gt seit dem 12. Jahrhundert die Silhouette der Altstadt.

Die Kirche wurde auf r√∂mischen Fundamenten errichtet - arch√§ologische Ausgrabungen zeigen die Kontinuit√§t der Besiedlung √ºber 2000 Jahre. Im Mittelalter war hier eines der m√§chtigsten Benediktinerkl√∂ster der Region.

Der Turm diente auch als Orientierungspunkt f√ºr Rheinschiffe und H√§ndler - ein fr√ºher "Leuchtturm" des Handels.`,
                    images: [
                        { title: "Gro√ü St. Martin", description: "Romanischer Kirchenbau", url: "" },
                        { title: "Altstadt Panorama", description: "Kircht√ºrme der Altstadt", url: "" },
                        { title: "Rheinufer", description: "Blick auf die Kirchen", url: "" }
                    ],
                    audio: [
                        { title: "Kirchenglocken", description: "Glockengel√§ut von Gro√ü St. Martin", url: "", type: "audio" },
                        { title: "Gregorianischer Gesang", description: "Historische Klostermusik", url: "", type: "youtube" }
                    ]
                },
                {
                    id: 5,
                    title: "Fischmarkt",
                    subtitle: "Handel, Handwerk und B√ºrgerstolz",
                    lat: 50.9378, lng: 6.9589,
                    description: "Mittelpunkt des mittelalterlichen Handels.",
                    photoChallenge: "Zeigt mit euren H√§nden, wie mittelalterliche H√§ndler ihre Waren pr√§sentiert haben - seid kreativ mit Gesten!",
                    mainText: `Der Fischmarkt war im Mittelalter das kommerzielle Herz K√∂lns. Hier wurde nicht nur Fisch verkauft, sondern alle wichtigen Handelsg√ºter der Region.

Die K√∂lner B√ºrger entwickelten hier ihre ber√ºhmte Unabh√§ngigkeit. 1074 erhielt K√∂ln bereits wichtige Stadtrechte - 500 Jahre bevor andere deutsche St√§dte folgten.

Die Zunftordnungen vom Fischmarkt dienten als Vorbild f√ºr ganz Europa. Handwerksmeister aus K√∂ln gr√ºndeten in vielen anderen St√§dten √§hnliche Organisationen.`,
                    images: [
                        { title: "Alter Markt K√∂ln", description: "Historischer Marktplatz", url: "" },
                        { title: "K√∂lner H√§user", description: "Typische Architektur", url: "" },
                        { title: "Rheinischer Markt", description: "Handelstradition", url: "" }
                    ],
                    audio: [
                        { title: "Marktger√§usche", description: "Atmosph√§re des historischen Marktes", url: "", type: "soundcloud" },
                        { title: "H√§ndlerrufe", description: "Nachstellung mittelalterlicher Marktrufe", url: "", type: "audio" }
                    ]
                }
            ]
        };

        // Firebase Initialization
        let db = null;

        async function initFirebase() {
            try {
                updateConnectionStatus('connecting');
                
                if (typeof firebase === 'undefined') {
                    throw new Error('Firebase SDK not loaded');
                }
                
                firebase.initializeApp(firebaseConfig);
                db = firebase.firestore();
                
                await db.enableNetwork();
                
                const testDoc = db.collection('tours').doc('test');
                await testDoc.set({ test: Date.now() }, { merge: true });
                
                tourApp.state.isFirebaseConnected = true;
                updateConnectionStatus('online');
                hideErrorPanel();
                
                console.log('‚úÖ Firebase connected successfully');
                enableRealtimeSync();
                
            } catch (error) {
                console.error('‚ùå Firebase connection failed:', error);
                tourApp.state.isFirebaseConnected = false;
                updateConnectionStatus('offline');
                showErrorPanel('Firebase-Verbindung fehlgeschlagen. App funktioniert nur lokal.', error.message);
                
                if (tourApp.state.connectionRetries < tourApp.state.maxRetries) {
                    tourApp.state.connectionRetries++;
                    setTimeout(() => {
                        console.log(`üîÑ Retrying Firebase connection (${tourApp.state.connectionRetries}/${tourApp.state.maxRetries})`);
                        initFirebase();
                    }, 3000);
                }
            }
        }

        function updateConnectionStatus(status) {
            const statusEl = document.getElementById('connectionStatus');
            if (statusEl) {
                statusEl.className = `connection-status ${status}`;
                
                const titles = {
                    'connecting': 'Verbindung wird aufgebaut...',
                    'online': 'Online - Daten werden synchronisiert', 
                    'offline': 'Offline - Nur lokale Daten'
                };
                statusEl.title = titles[status] || status;
            }
        }

        function showErrorPanel(message, details = '') {
            const panel = document.getElementById('errorPanel');
            const messageEl = document.getElementById('errorMessage');
            
            if (panel && messageEl) {
                messageEl.innerHTML = `${message}${details ? `<br><small>Details: ${details}</small>` : ''}`;
                panel.classList.remove('hidden');
            }
        }

        function hideErrorPanel() {
            const panel = document.getElementById('errorPanel');
            if (panel) {
                panel.classList.add('hidden');
            }
        }

        function retryConnection() {
            tourApp.state.connectionRetries = 0;
            initFirebase();
        }

        // Firebase Real-time Functions
        function enableRealtimeSync() {
            if (!tourApp.state.isFirebaseConnected || !tourApp.state.tourId) return;

            try {
                // Listen to chat messages
                const chatRef = db.collection('tours').doc(tourApp.state.tourId).collection('chat');
                const chatUnsubscribe = chatRef.orderBy('timestamp', 'asc').onSnapshot((snapshot) => {
                    snapshot.docChanges().forEach((change) => {
                        if (change.type === 'added') {
                            const messageData = change.doc.data();
                            if (messageData.userName !== tourApp.state.userName) {
                                // Handle special challenge photo messages
                                if (messageData.type === 'challenge-photo') {
                                    addChallengePhotoMessage(messageData, false);
                                } else {
                                    addChatMessage(messageData, false);
                                }
                            }
                        } else if (change.type === 'removed') {
                            // Handle chat clearing - reload chat completely
                            const chatContainer = document.getElementById('chatContainer');
                            if (chatContainer) {
                                chatContainer.innerHTML = `
                                    <div class="chat-message system">
                                        <strong>Admin:</strong> Chat wurde geleert! üóëÔ∏è<br>
                                        <small>Alle Nachrichten wurden entfernt</small>
                                        <span class="timestamp">jetzt</span>
                                    </div>
                                `;
                            }
                        }
                    });
                }, (error) => {
                    console.error('Chat sync error:', error);
                });

                // Listen to team chat messages (only if user has selected a team)
                let teamChatUnsubscribe = null;
                if (tourApp.state.selectedTeam) {
                    const teamChatRef = db.collection('tours').doc(tourApp.state.tourId).collection('teamChat').doc(tourApp.state.selectedTeam).collection('messages');
                    teamChatUnsubscribe = teamChatRef.orderBy('timestamp', 'asc').onSnapshot((snapshot) => {
                        snapshot.docChanges().forEach((change) => {
                            if (change.type === 'added') {
                                const messageData = change.doc.data();
                                // Only show messages from other users
                                if (messageData.userName !== tourApp.state.userName) {
                                    addTeamChatMessage(messageData, false);
                                }
                            } else if (change.type === 'removed') {
                                // Handle team chat clearing
                                const teamChatContainer = document.getElementById('teamChatMessages');
                                if (teamChatContainer) {
                                    teamChatContainer.innerHTML = `
                                        <div class="chat-message system">
                                            <strong>Admin:</strong> Team-Chat wurde geleert! üóëÔ∏è<br>
                                            <small>Alle Team-Nachrichten wurden entfernt</small>
                                            <span class="timestamp">jetzt</span>
                                        </div>
                                    `;
                                }
                            }
                        });
                    }, (error) => {
                        console.error('Team chat sync error:', error);
                    });
                }

                // Listen to team name changes
                const teamNamesRef = db.collection('tours').doc(tourApp.state.tourId).collection('teamNameChanges');
                const teamNamesUnsubscribe = teamNamesRef.onSnapshot((snapshot) => {
                    snapshot.docChanges().forEach((change) => {
                        if (change.type === 'added') {
                            const changeData = change.doc.data();
                            if (changeData.changedBy !== tourApp.state.userName) {
                                // Update local team names
                                teamNames[changeData.teamId] = changeData.newName;
                                
                                // Update UI if this affects current user's team
                                if (tourApp.state.selectedTeam === changeData.teamId) {
                                    tourApp.state.teamName = changeData.newName;
                                    updateCurrentTeamDisplay();
                                    updateTeamChatTab();
                                }
                                
                                generateTeamOptions();
                                showNotification(`Team "${changeData.oldName}" wurde zu "${changeData.newName}" umbenannt!`, 'info');
                            }
                        }
                    });
                }, (error) => {
                    console.error('Team names sync error:', error);
                });

                // Listen to moderation status - FIXED REAL-TIME SYNC
                const moderationRef = db.collection('tours').doc(tourApp.state.tourId).collection('settings').doc('moderation');
                const moderationUnsubscribe = moderationRef.onSnapshot((doc) => {
                    if (doc.exists) {
                        const moderationData = doc.data();
                        const newBlockedStatus = moderationData.chatBlocked || false;
                        
                        // Only update if status actually changed
                        if (tourApp.state.chatBlocked !== newBlockedStatus) {
                            tourApp.state.chatBlocked = newBlockedStatus;
                            tourApp.state.chatModeration = newBlockedStatus;
                            
                            // Update UI immediately for all users
                            updateChatModeration();
                            
                            // Show notification to non-admin users
                            if (!tourApp.state.isAdmin) {
                                if (newBlockedStatus) {
                                    showNotification('Chat wurde vom Admin gesperrt! üîí', 'warning');
                                    addSystemMessage('Chat wurde vom Admin gesperrt üîí');
                                } else {
                                    showNotification('Chat wurde vom Admin freigegeben! üîì');
                                    addSystemMessage('Chat wurde vom Admin freigegeben üîì');
                                }
                            }
                            
                            // Update admin button text if user is admin
                            if (tourApp.state.isAdmin) {
                                const textEl = document.getElementById('chatModerationText');
                                if (textEl) {
                                    textEl.textContent = newBlockedStatus ? 
                                        'üîì Chat freigeben' : 
                                        'üõ°Ô∏è Chat sperren';
                                }
                            }
                        }
                    }
                }, (error) => {
                    console.error('Moderation sync error:', error);
                });

                // Listen to tour chat lock status
                const tourLockRef = db.collection('tours').doc(tourApp.state.tourId).collection('settings').doc('tourLock');
                const tourLockUnsubscribe = tourLockRef.onSnapshot((doc) => {
                    if (doc.exists) {
                        const tourLockData = doc.data();
                        const newLockStatus = tourLockData.tourChatLocked || false;
                        
                        // Only update if status actually changed
                        if (tourApp.state.tourChatLocked !== newLockStatus) {
                            tourApp.state.tourChatLocked = newLockStatus;
                            
                            // Update UI immediately for all users
                            updateChatModeration();
                            
                            // Show notification to non-admin users
                            if (!tourApp.state.isAdmin) {
                                if (newLockStatus) {
                                    showNotification('Tour-Chat wurde vom Admin gesperrt! üîí', 'warning');
                                    addSystemMessage('Tour-Chat wurde vom Admin gesperrt üîí');
                                } else {
                                    showNotification('Tour-Chat wurde freigegeben - die Tour kann beginnen! üîì');
                                    addSystemMessage('Tour-Chat wurde vom Admin freigegeben - die Tour kann beginnen! üîì');
                                }
                            }
                            
                            // Update admin button text if user is admin
                            if (tourApp.state.isAdmin) {
                                const textEl = document.getElementById('tourChatLockText');
                                const btnEl = document.getElementById('tourChatLockBtn');
                                if (textEl && btnEl) {
                                    if (newLockStatus) {
                                        textEl.textContent = 'üîì Tour-Chat freigeben';
                                        btnEl.style.background = '#dc2626';
                                    } else {
                                        textEl.textContent = 'üîí Tour-Chat sperren';
                                        btnEl.style.background = '#059669';
                                    }
                                }
                            }
                        }
                    }
                }, (error) => {
                    console.error('Tour lock sync error:', error);
                });

                // Listen to scores
                const scoresRef = db.collection('tours').doc(tourApp.state.tourId).collection('scores');
                const scoresUnsubscribe = scoresRef.onSnapshot(() => {
                    updateRanking();
                }, (error) => {
                    console.error('Scores sync error:', error);
                });

                // Listen to station updates
                const stationsRef = db.collection('tours').doc(tourApp.state.tourId).collection('stations');
                const stationsUnsubscribe = stationsRef.onSnapshot((snapshot) => {
                    let hasChanges = false;
                    snapshot.docChanges().forEach((change) => {
                        if (change.type === 'added' || change.type === 'modified') {
                            const stationData = change.doc.data();
                            const stationIndex = tourApp.stations.findIndex(s => s.id === stationData.id);
                            
                            if (stationIndex >= 0) {
                                tourApp.stations[stationIndex] = stationData;
                                hasChanges = true;
                            } else {
                                tourApp.stations.push(stationData);
                                tourApp.stations.sort((a, b) => a.id - b.id);
                                hasChanges = true;
                            }
                        } else if (change.type === 'removed') {
                            const stationData = change.doc.data();
                            const stationIndex = tourApp.stations.findIndex(s => s.id === stationData.id);
                            if (stationIndex >= 0) {
                                tourApp.stations.splice(stationIndex, 1);
                                hasChanges = true;
                            }
                        }
                    });
                    
                    if (hasChanges && !tourApp.state.isAdmin) {
                        generateStationsList();
                        updateProgress();
                        if (tourApp.state.map) {
                            updateMapMarkers();
                        }
                        showNotification('üîÑ Stationen wurden aktualisiert!');
                    }
                }, (error) => {
                    console.error('Stations sync error:', error);
                });

                // Listen to announcements
                const announcementsRef = db.collection('tours').doc(tourApp.state.tourId).collection('announcements');
                const announcementsUnsubscribe = announcementsRef.onSnapshot((snapshot) => {
                    snapshot.docChanges().forEach((change) => {
                        if (change.type === 'added') {
                            const announcementData = change.doc.data();
                            if (announcementData.isActive) {
                                showAdminPopup('üì¢ Admin-Ank√ºndigung', announcementData.message);
                            }
                        }
                    });
                }, (error) => {
                    console.error('Announcements sync error:', error);
                });

                // Listen to events (like chat clearing) - NEW!
                const eventsRef = db.collection('tours').doc(tourApp.state.tourId).collection('events');
                const eventsUnsubscribe = eventsRef.onSnapshot((snapshot) => {
                    snapshot.docChanges().forEach((change) => {
                        if (change.type === 'added') {
                            const eventData = change.doc.data();
                            if (eventData.type === 'chat_cleared' && eventData.by !== tourApp.state.userName) {
                                // Another admin cleared the chat - update local UI immediately
                                const chatContainer = document.getElementById('chatContainer');
                                if (chatContainer) {
                                    const allMessages = chatContainer.querySelectorAll('.chat-message');
                                    allMessages.forEach(msg => {
                                        if (!msg.classList.contains('system') || msg.textContent.includes('geleert')) {
                                            msg.remove();
                                        }
                                    });
                                    
                                    const confirmationMsg = document.createElement('div');
                                    confirmationMsg.className = 'chat-message system';
                                    confirmationMsg.innerHTML = `
                                        <strong>Admin:</strong> Chat wurde von ${eventData.by} geleert! üóëÔ∏è<br>
                                        <small>Alle Nachrichten wurden entfernt</small>
                                        <span class="timestamp">jetzt</span>
                                    `;
                                    chatContainer.appendChild(confirmationMsg);
                                }

                                const teamChatContainer = document.getElementById('teamChatMessages');
                                if (teamChatContainer) {
                                    const allTeamMessages = teamChatContainer.querySelectorAll('.chat-message');
                                    allTeamMessages.forEach(msg => {
                                        if (!msg.classList.contains('system') || msg.textContent.includes('geleert')) {
                                            msg.remove();
                                        }
                                    });
                                    
                                    const teamConfirmationMsg = document.createElement('div');
                                    teamConfirmationMsg.className = 'chat-message system';
                                    teamConfirmationMsg.innerHTML = `
                                        <strong>Admin:</strong> Team-Chat wurde geleert! üóëÔ∏è<br>
                                        <small>Alle Team-Nachrichten wurden entfernt</small>
                                        <span class="timestamp">jetzt</span>
                                    `;
                                    teamChatContainer.appendChild(teamConfirmationMsg);
                                }

                                showNotification('Chat wurde von Admin geleert! üóëÔ∏è', 'warning');
                            }
                        }
                    });
                }, (error) => {
                    console.error('Events sync error:', error);
                });

                let allSyncListeners = [chatUnsubscribe, scoresUnsubscribe, stationsUnsubscribe, announcementsUnsubscribe, moderationUnsubscribe, tourLockUnsubscribe, eventsUnsubscribe];
                if (teamChatUnsubscribe) {
                    allSyncListeners.push(teamChatUnsubscribe);
                }

                // Listen to admin direct messages - COMPLETELY FIXED
                const adminDirectRef = db.collection('tours').doc(tourApp.state.tourId).collection('adminDirectMessages');
                const adminDirectUnsubscribe = adminDirectRef.onSnapshot((snapshot) => {
                    snapshot.docChanges().forEach(async (change) => {
                        if (change.type === 'added' || change.type === 'modified') {
                            const channelId = change.doc.id;
                            
                            // Only process channels relevant to current user
                            if (channelId.startsWith('user_')) {
                                const channelUserName = channelId.replace('user_', '');
                                
                                // For admin: listen to all user channels
                                // For users: only listen to their own channel
                                const shouldListenToChannel = tourApp.state.isAdmin || channelUserName === tourApp.state.userName;
                                
                                if (!shouldListenToChannel) {
                                    return; // Skip irrelevant channels
                                }
                                
                                // Create tab for admin if it doesn't exist and it's for a different user
                                if (tourApp.state.isAdmin && channelUserName !== tourApp.state.userName && !document.getElementById(`adminChatTab_${channelUserName}`)) {
                                    createAdminChatTab(channelUserName);
                                }
                                
                                // Prevent duplicate listeners
                                if (!tourApp.state.adminChatListeners) {
                                    tourApp.state.adminChatListeners = new Set();
                                }
                                
                                const listenerKey = `${channelId}_${tourApp.state.userName}`;
                                if (!tourApp.state.adminChatListeners.has(listenerKey)) {
                                    tourApp.state.adminChatListeners.add(listenerKey);
                                    
                                    const messagesRef = change.doc.ref.collection('messages');
                                    messagesRef.orderBy('timestamp', 'asc').onSnapshot((messagesSnapshot) => {
                                        messagesSnapshot.docChanges().forEach((messageChange) => {
                                            if (messageChange.type === 'added') {
                                                const messageData = messageChange.doc.data();
                                                
                                                // Skip own messages
                                                if (messageData.userName === tourApp.state.userName) {
                                                    return;
                                                }
                                                
                                                // Determine if message should be shown to current user
                                                let shouldShowMessage = false;
                                                let targetContainer = null;
                                                
                                                if (tourApp.state.isAdmin) {
                                                    // Admin receives messages from users
                                                    if (!messageData.isFromAdmin && messageData.targetUser === 'admin') {
                                                        shouldShowMessage = true;
                                                        targetContainer = channelUserName;
                                                    }
                                                } else {
                                                    // User receives messages from admin
                                                    if (messageData.isFromAdmin && (messageData.targetUser === tourApp.state.userName || channelUserName === tourApp.state.userName)) {
                                                        shouldShowMessage = true;
                                                        targetContainer = 'admin';
                                                    }
                                                }
                                                
                                                if (shouldShowMessage) {
                                                    addAdminChatMessage(messageData, false, targetContainer);
                                                }
                                            }
                                        });
                                    }, (error) => {
                                        console.error(`Messages sync error for ${channelId}:`, error);
                                    });
                                }
                            }
                        }
                    });
                }, (error) => {
                    console.error('Admin direct messages sync error:', error);
                });

                // Listen to admin chat messages - FIXED
                const adminChatRef = db.collection('tours').doc(tourApp.state.tourId).collection('adminChat');
                const adminChatUnsubscribe = adminChatRef.orderBy('timestamp', 'asc').onSnapshot((snapshot) => {
                    snapshot.docChanges().forEach((change) => {
                        if (change.type === 'added') {
                            const messageData = change.doc.data();
                            if (messageData.userName !== tourApp.state.userName) {
                                addAdminChatMessage(messageData, false);
                            }
                        }
                    });
                }, (error) => {
                    console.error('Admin chat sync error:', error);
                });

                // Listen to user positions
                const positionsRef = db.collection('tours').doc(tourApp.state.tourId).collection('userPositions');
                const positionsUnsubscribe = positionsRef.onSnapshot((snapshot) => {
                    snapshot.docChanges().forEach((change) => {
                        if (change.type === 'added' || change.type === 'modified') {
                            const positionData = change.doc.data();
                            if (positionData.userName !== tourApp.state.userName) {
                                updateUserMarkerOnMap(positionData);
                            }
                        } else if (change.type === 'removed') {
                            const positionData = change.doc.data();
                            removeUserMarkerFromMap(positionData.userName);
                        }
                    });
                }, (error) => {
                    console.error('Positions sync error:', error);
                });

                // Listen to team assignments
                const teamAssignmentsRef = db.collection('tours').doc(tourApp.state.tourId).collection('teamAssignments');
                const teamAssignmentsUnsubscribe = teamAssignmentsRef.onSnapshot((snapshot) => {
                    snapshot.docChanges().forEach((change) => {
                        if (change.type === 'added') {
                            const assignmentData = change.doc.data();
                            // Prevent infinite loop by checking both assignedBy and timestamp
                            const assignmentTime = assignmentData.timestamp?.toMillis() || 0;
                            const currentTime = Date.now();
                            const timeDiff = Math.abs(currentTime - assignmentTime);
                            
                            if (assignmentData.assignedBy !== tourApp.state.userName && timeDiff < 30000) { // Only process recent assignments (< 30 seconds)
                                // Auto-assignment happened from another admin
                                teamMembers = assignmentData.assignments;
                                
                                // Update current user's team
                                const currentUserTeam = Object.keys(teamMembers).find(teamId => 
                                    teamMembers[teamId].some(member => member.userName === tourApp.state.userName)
                                );
                                
                                if (currentUserTeam) {
                                    tourApp.state.selectedTeam = currentUserTeam;
                                    tourApp.state.teamName = teamNames[currentUserTeam];
                                    updateCurrentTeamDisplay();
                                    updateTeamChatTab();
                                    
                                    // Show team chat tab for all users after auto-assignment
                                    const teamChatTab = document.getElementById('teamChatTab');
                                    if (teamChatTab) {
                                        teamChatTab.style.display = 'block';
                                    }
                                    
                                    // Save state
                                    try {
                                        const stateToSave = {
                                            selectedTeam: tourApp.state.selectedTeam,
                                            teamName: tourApp.state.teamName,
                                            userName: tourApp.state.userName,
                                            tourId: tourApp.state.tourId,
                                            isAdmin: tourApp.state.isAdmin
                                        };
                                        localStorage.setItem('tourState', JSON.stringify(stateToSave));
                                    } catch (saveError) {
                                        console.log('State save skipped due to circular reference');
                                    }
                                    
                                    // Restart sync to include team chat
                                    setTimeout(() => {
                                        if (tourApp.state.syncListeners) {
                                            tourApp.state.syncListeners.forEach(unsubscribe => {
                                                if (typeof unsubscribe === 'function') {
                                                    try {
                                                        unsubscribe();
                                                    } catch (e) {
                                                        console.log('Error unsubscribing:', e);
                                                    }
                                                }
                                            });
                                        }
                                        enableRealtimeSync();
                                    }, 1000);
                                    
                                    // Reload chat history to include team chat
                                    setTimeout(() => loadChatHistory(), 1500);
                                }
                                
                                generateTeamOptions();
                                showNotification(`Admin hat Teams neu verteilt! Du bist jetzt in ${teamNames[currentUserTeam]}`, 'info');
                            }
                        }
                    });
                }, (error) => {
                    console.error('Team assignments sync error:', error);
                });

                // Store team chat listener and team assignment listeners
                if (teamChatUnsubscribe) {
                    allSyncListeners.push(teamChatUnsubscribe);
                }
                allSyncListeners.push(teamNamesUnsubscribe, teamAssignmentsUnsubscribe);

                allSyncListeners.push(adminChatUnsubscribe, positionsUnsubscribe);
                tourApp.state.syncListeners = allSyncListeners;


            } catch (error) {
                console.error('Error setting up real-time sync:', error);
            }
        }

        // Firebase Data Functions
        async function saveToFirebase(collection, docId, data) {
            if (!tourApp.state.isFirebaseConnected || !tourApp.state.tourId) return false;

            try {
                await db.collection('tours').doc(tourApp.state.tourId)
                    .collection(collection).doc(docId).set(data, { merge: true });
                return true;
            } catch (error) {
                console.error('Firebase save error:', error);
                showNotification('Speichern fehlgeschlagen - nur lokal gespeichert', 'warning');
                return false;
            }
        }

        async function getFromFirebase(collection) {
            if (!tourApp.state.isFirebaseConnected || !tourApp.state.tourId) return [];

            try {
                const snapshot = await db.collection('tours').doc(tourApp.state.tourId)
                    .collection(collection).get();
                return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            } catch (error) {
                console.error('Firebase get error:', error);
                return [];
            }
        }

        // Enhanced Team Management Functions
        let teamNames = {
            'red': 'üî¥ Team R√∂mer',
            'blue': 'üîµ Team Gaffeln', 
            'green': 'üü¢ Team Hanseat',
            'yellow': 'üü° Team Modern'
        };

        let teamMembers = {
            'red': [],
            'blue': [],
            'green': [],
            'yellow': []
        };


        // Safe Firebase operations with error handling
        async function safeGetFromFirebase(collection) {
            try {
                if (!tourApp.state.isFirebaseConnected || !tourApp.state.tourId) {
                    return [];
                }
                return await getFromFirebase(collection);
            } catch (error) {
                console.error(`Error getting ${collection} from Firebase:`, error);
                return [];
            }
        }

        async function safeSaveToFirebase(collection, docId, data) {
            try {
                if (!tourApp.state.isFirebaseConnected || !tourApp.state.tourId) {
                    return false;
                }
                return await saveToFirebase(collection, docId, data);
            } catch (error) {
                console.error(`Error saving to ${collection}:`, error);
                return false;
            }
        }
        async function loadTeamData() {
            try {
                if (tourApp.state.isFirebaseConnected && tourApp.state.tourId) {
                    // Load team names from Firebase
                    const teamsData = await safeGetFromFirebase('teams');
                    if (teamsData && teamsData.length > 0) {
                        teamsData.forEach(team => {
                            if (team.id && team.name) {
                                teamNames[team.id] = team.name;
                            }
                        });
                    }

                    // Load team members from Firebase
                    const membersData = await safeGetFromFirebase('teamMembers');
                    if (membersData && membersData.length > 0) {
                        teamMembers = {
                            'red': [],
                            'blue': [],
                            'green': [],
                            'yellow': []
                        };
                        
                        membersData.forEach(member => {
                            if (member.teamId && teamMembers[member.teamId]) {
                                teamMembers[member.teamId].push({
                                    userName: member.userName,
                                    joinedAt: member.joinedAt
                                });
                            }
                        });
                    }
                }
                
                generateTeamOptions();
                updateCurrentTeamDisplay();
            } catch (error) {
                console.error('Error loading team data:', error);
                generateTeamOptions(); // Fallback to default teams
            }
        }

        function generateTeamOptions() {
            try {
                const container = document.getElementById('teamOptions');
                if (!container) return;
                
                container.innerHTML = '';
                
                Object.keys(teamNames).forEach(teamId => {
                    const memberCount = teamMembers[teamId] ? teamMembers[teamId].length : 0;
                    const isSelected = tourApp.state.selectedTeam === teamId;
                    
                    const teamOption = document.createElement('div');
                    teamOption.className = `team-option ${isSelected ? 'selected' : ''}`;
                    teamOption.onclick = () => {
                        selectTeam(teamId, teamNames[teamId], teamOption).catch(error => 
                            console.error('Error selecting team:', error)
                        );
                    };
                    
                    const teamColors = {
                        'red': '#dc2626',
                        'blue': '#2563eb',
                        'green': '#059669',
                        'yellow': '#d97706'
                    };
                    
                    teamOption.innerHTML = `
                        <div class="team-color" style="background: ${teamColors[teamId]};"></div>
                        <div style="flex: 1;">
                            <span>${teamNames[teamId]}</span>
                            <div style="font-size: 0.8rem; color: #6b7280; margin-top: 0.25rem;">
                                ${memberCount} Mitglied${memberCount !== 1 ? 'er' : ''}
                            </div>
                        </div>
                    `;
                    
                    container.appendChild(teamOption);
                });
            } catch (error) {
                console.error('Error generating team options:', error);
            }
        }

        function updateCurrentTeamDisplay() {
            try {
                const currentTeamDisplay = document.getElementById('currentTeamDisplay');
                const teamSelector = document.getElementById('teamSelector');
                const currentTeamInfo = document.getElementById('currentTeamInfo');
                
                if (tourApp.state.selectedTeam && currentTeamDisplay && teamSelector && currentTeamInfo) {
                    const teamColors = {
                        'red': '#dc2626',
                        'blue': '#2563eb',
                        'green': '#059669',
                        'yellow': '#d97706'
                    };
                    
                    const memberCount = teamMembers[tourApp.state.selectedTeam] ? teamMembers[tourApp.state.selectedTeam].length : 0;
                    
                    currentTeamInfo.innerHTML = `
                        <div class="team-color" style="background: ${teamColors[tourApp.state.selectedTeam]}; width: 30px; height: 30px; margin-right: 1rem;"></div>
                        <div style="flex: 1;">
                            <div style="font-weight: bold; font-size: 1.1rem;">${teamNames[tourApp.state.selectedTeam]}</div>
                            <div style="color: #6b7280; font-size: 0.9rem;">${memberCount} Mitglied${memberCount !== 1 ? 'er' : ''}</div>
                        </div>
                    `;
                    
                    currentTeamDisplay.style.display = 'block';
                    teamSelector.style.display = 'none';
                } else if (currentTeamDisplay && teamSelector) {
                    currentTeamDisplay.style.display = 'none';
                    teamSelector.style.display = 'block';
                }
            } catch (error) {
                console.error('Error updating current team display:', error);
            }
        }

        function showTeamSelector() {
            try {
                const currentTeamDisplay = document.getElementById('currentTeamDisplay');
                const teamSelector = document.getElementById('teamSelector');
                
                if (currentTeamDisplay && teamSelector) {
                    currentTeamDisplay.style.display = 'none';
                    teamSelector.style.display = 'block';
                    generateTeamOptions();
                }
            } catch (error) {
                console.error('Error showing team selector:', error);
            }
        }

        function showTeamNameEditor() {
            try {
                if (!tourApp.state.selectedTeam) {
                    showNotification('Du musst zuerst einem Team beitreten!', 'error');
                    return;
                }
                
                const modal = document.createElement('div');
                modal.className = 'team-rename-modal';
                
                const currentMembers = teamMembers[tourApp.state.selectedTeam] || [];
                const membersHtml = currentMembers.length > 0 ? 
                    currentMembers.map(member => `
                        <div class="team-member-item">
                            <span>üë§ ${member.userName}</span>
                        </div>
                    `).join('') : 
                    '<div style="color: #6b7280; font-style: italic;">Keine anderen Mitglieder</div>';
                
                modal.innerHTML = `
                    <div class="team-rename-content">
                        <h3 style="color: #1f2937; margin-bottom: 1rem;">‚úèÔ∏è Team umbenennen</h3>
                        
                        <div style="margin-bottom: 1rem;">
                            <label style="display: block; font-weight: bold; margin-bottom: 0.5rem;">Aktueller Name:</label>
                            <div style="background: #f3f4f6; padding: 0.8rem; border-radius: 8px; color: #6b7280;">
                                ${teamNames[tourApp.state.selectedTeam]}
                            </div>
                        </div>
                        
                        <div style="margin-bottom: 1rem;">
                            <label style="display: block; font-weight: bold; margin-bottom: 0.5rem;">Neuer Name:</label>
                            <input type="text" id="newTeamName" maxlength="30" placeholder="Neuer Teamname..." 
                                style="width: 100%; padding: 0.8rem; border: 2px solid #e5e7eb; border-radius: 8px; font-size: 1rem;">
                        </div>
                        
                        <div style="margin-bottom: 1.5rem;">
                            <label style="display: block; font-weight: bold; margin-bottom: 0.5rem;">Team-Mitglieder:</label>
                            <div class="team-members-list">
                                ${membersHtml}
                            </div>
                        </div>
                        
                        <div style="display: flex; gap: 1rem;">
                            <button onclick="closeTeamNameEditor()" style="flex: 1; background: #6b7280; color: white; border: none; padding: 0.8rem; border-radius: 25px; font-weight: bold; cursor: pointer;">
                                Abbrechen
                            </button>
                            <button onclick="window.saveTeamName()" style="flex: 1; background: #dc2626; color: white; border: none; padding: 0.8rem; border-radius: 25px; font-weight: bold; cursor: pointer;">
                                üíæ Speichern
                            </button>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(modal);

                // Add escape key handler
                const escapeHandler = (e) => {
                    if (e.key === 'Escape') {
                        modal.remove();
                        document.removeEventListener('keydown', escapeHandler);
                    }
                };
                document.addEventListener('keydown', escapeHandler);
                
                // Focus on input
                setTimeout(() => {
                    const input = document.getElementById('newTeamName');
                    if (input) {
                        input.focus();
                        input.addEventListener('keypress', (e) => {
                            if (e.key === 'Enter') {
                                saveTeamName();
                            }
                        });
                    }
                }, 100);
                
            } catch (error) {
                console.error('Error showing team name editor:', error);
            }
        }

        function saveTeamName() {
            try {
                const newNameInput = document.getElementById('newTeamName');
                if (!newNameInput) return;
                
                const newName = newNameInput.value.trim();
                if (!newName || newName.length < 2) {
                    showNotification('Name muss mindestens 2 Zeichen haben!', 'error');
                    return;
                }
                
                const oldName = teamNames[tourApp.state.selectedTeam];
                teamNames[tourApp.state.selectedTeam] = newName;
                tourApp.state.teamName = newName;
                
                // Save to Firebase with proper synchronization
                if (tourApp.state.isFirebaseConnected && tourApp.state.tourId) {
                    saveToFirebase('teams', tourApp.state.selectedTeam, {
                        id: tourApp.state.selectedTeam,
                        name: newName,
                        updatedBy: tourApp.state.userName,
                        updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                    });
                    
                    // Broadcast team name change to all users
                    saveToFirebase('teamNameChanges', Date.now().toString(), {
                        teamId: tourApp.state.selectedTeam,
                        oldName: oldName,
                        newName: newName,
                        changedBy: tourApp.state.userName,
                        timestamp: firebase.firestore.FieldValue.serverTimestamp()
                    });
                }
                
                // Update UI
                generateTeamOptions();
                updateCurrentTeamDisplay();
                updateTeamChatTab();
                
                // Close modal
                closeTeamNameEditor();
                
                showNotification('Teamname ge√§ndert! ‚úÖ');
                addSystemMessage(`${tourApp.state.userName} hat das Team von "${oldName}" zu "${newName}" umbenannt! ‚úèÔ∏è`);
                
                saveState();
                
            } catch (error) {
                console.error('Error saving team name:', error);
                showNotification('Fehler beim Speichern des Teamnamens', 'error');
            }
        }

        function closeTeamNameEditor() {
            try {
                const modal = document.querySelector('.team-rename-modal');
                if (modal) {
                    modal.remove();
                }
            } catch (error) {
                console.error('Error closing team name editor:', error);
            }
        }

        function updateTeamChatTab() {
            try {
                const teamChatTab = document.getElementById('teamChatTab');
                if (teamChatTab && tourApp.state.selectedTeam) {
                    const shortName = teamNames[tourApp.state.selectedTeam].split(' ')[1] || 'Team';
                    teamChatTab.innerHTML = `üë• ${shortName}-Chat`;
                }
            } catch (error) {
                console.error('Error updating team chat tab:', error);
            }
        }

        async function updateTeamMembership(teamId) {
            try {
                // Remove user from old team
                if (tourApp.state.selectedTeam && teamMembers[tourApp.state.selectedTeam]) {
                    teamMembers[tourApp.state.selectedTeam] = teamMembers[tourApp.state.selectedTeam].filter(
                        member => member.userName !== tourApp.state.userName
                    );
                }
                
                // Add user to new team
                if (!teamMembers[teamId]) {
                    teamMembers[teamId] = [];
                }
                
                const existingMember = teamMembers[teamId].find(member => member.userName === tourApp.state.userName);
                if (!existingMember) {
                    teamMembers[teamId].push({
                        userName: tourApp.state.userName,
                        joinedAt: Date.now()
                    });
                }
                
                // Save to Firebase
                if (tourApp.state.isFirebaseConnected && tourApp.state.tourId) {
                    try {
                        await saveToFirebase('teamMembers', tourApp.state.userName, {
                            userName: tourApp.state.userName,
                            teamId: teamId,
                            teamName: teamNames[teamId],
                            joinedAt: firebase.firestore.FieldValue.serverTimestamp()
                        });
                    } catch (firebaseError) {
                        console.error('Firebase team membership update failed:', firebaseError);
                        // Continue anyway - local state is updated
                    }
                }
                
                generateTeamOptions();
                
            } catch (error) {
                console.error('Error updating team membership:', error);
                showNotification('Fehler beim Aktualisieren der Team-Mitgliedschaft', 'warning');
            }
        }

        // Helper function to register current user for team assignment
        async function registerUserForTeamAssignment() {
            try {
                // Register user in Firebase for team assignment recognition
                if (tourApp.state.isFirebaseConnected && tourApp.state.tourId) {
                    await saveToFirebase('activeUsers', tourApp.state.userName, {
                        userName: tourApp.state.userName,
                        joinedAt: firebase.firestore.FieldValue.serverTimestamp(),
                        isActive: true,
                        tourId: tourApp.state.tourId
                    });
                }
                
                // Also register locally
                localStorage.setItem(`user_${tourApp.state.userName}`, JSON.stringify({
                    userName: tourApp.state.userName,
                    joinedAt: Date.now(),
                    isActive: true,
                    tourId: tourApp.state.tourId
                }));
                
                console.log(`‚úÖ User ${tourApp.state.userName} registered for team assignment`);
            } catch (error) {
                console.error('Error registering user for team assignment:', error);
            }
        }

        // Auto Team Assignment Function - FIXED
        async function autoAssignTeams() {
            try {
                if (!confirm('Alle aktiven Nutzer automatisch und gleichm√§√üig auf Teams verteilen?\n\n‚ö†Ô∏è Dies √ºberschreibt alle aktuellen Team-Zuordnungen!')) {
                    return;
                }
                
                // Get all active users from multiple sources
                let activeUsers = new Set();

                if (tourApp.state.isFirebaseConnected && tourApp.state.tourId) {
                    try {
                        // Get from activeUsers collection
                        const activeUsersData = await getFromFirebase('activeUsers');
                        if (activeUsersData && activeUsersData.length > 0) {
                            activeUsersData.forEach(user => {
                                if (user.userName) {
                                    activeUsers.add(user.userName);
                                }
                            });
                        }
                        
                        // Get from teamMembers collection
                        const membersData = await getFromFirebase('teamMembers');
                        if (membersData && membersData.length > 0) {
                            membersData.forEach(member => {
                                if (member.userName) {
                                    activeUsers.add(member.userName);
                                }
                            });
                        }
                        
                        // Get from chat messages (users who have been active)
                        const chatData = await getFromFirebase('chat');
                        if (chatData && chatData.length > 0) {
                            chatData.forEach(msg => {
                                if (msg.userName && msg.userName !== 'System' && msg.userName !== 'üîä System' && msg.userName !== 'Admin') {
                                    activeUsers.add(msg.userName);
                                }
                            });
                        }
                        
                        // Get from user positions (live tracking)
                        const positionsData = await getFromFirebase('userPositions');
                        if (positionsData && positionsData.length > 0) {
                            positionsData.forEach(pos => {
                                if (pos.userName) {
                                    activeUsers.add(pos.userName);
                                }
                            });
                        }
                        
                        // Get from admin direct messages
                        const adminDirectData = await getFromFirebase('adminDirectMessages');
                        if (adminDirectData && adminDirectData.length > 0) {
                            adminDirectData.forEach(channel => {
                                if (channel.userName && channel.userName !== 'admin') {
                                    activeUsers.add(channel.userName);
                                }
                            });
                        }
                        
                    } catch (error) {
                        console.log('Error fetching from Firebase, using local data');
                    }
                }

                // Get from localStorage
                Object.keys(localStorage).forEach(key => {
                    if (key.startsWith('user_')) {
                        try {
                            const userData = JSON.parse(localStorage.getItem(key));
                            if (userData.userName) {
                                activeUsers.add(userData.userName);
                            }
                        } catch (e) {
                            // Ignore invalid entries
                        }
                    }
                });

                // Always include current user
                if (tourApp.state.userName && tourApp.state.userName.trim()) {
                    activeUsers.add(tourApp.state.userName);
                }

                // Debug: Log current user info
                console.log('Current user for auto-assign:', {
                    userName: tourApp.state.userName,
                    isValid: !tourApp.state.userName.startsWith('Tourist_'),
                    activeUsersSize: activeUsers.size
                });

                console.log('ActiveUsers before filtering:', Array.from(activeUsers));
                console.log('Current userName for auto-assign:', tourApp.state.userName);

                // Debug: Log current user info
                console.log('Current user for auto-assign:', {
                    userName: tourApp.state.userName,
                    isValid: !tourApp.state.userName.startsWith('Tourist_'),
                    activeUsersSize: activeUsers.size
                });
                
                console.log('ActiveUsers before filtering:', Array.from(activeUsers));
                console.log('Current userName for auto-assign:', tourApp.state.userName);

                // Convert to array and filter out invalid names (but include ALL Tourist_ names)
                const userArray = Array.from(activeUsers).filter(name => 
                    name && 
                    name.length > 0 && 
                    name !== 'System' && 
                    name !== 'üîä System' &&
                    name !== 'Admin'
                    // Include ALL Tourist_ names to show all participants
                );
                
                if (userArray.length === 0) {
                    showNotification('‚ùå Keine aktiven Nutzer gefunden!\n\nüí° Nutzer m√ºssen die App ge√∂ffnet haben oder im Chat aktiv gewesen sein.', 'warning');
                    return;
                }
                
                // Show user names in a more readable format
                const displayNames = userArray.map(name => 
                    name.startsWith('Tourist_') ? `${name} (noch kein Name gesetzt)` : name
                );
                const confirmMessage = `${userArray.length} Nutzer gefunden:\n${displayNames.join('\n')}\n\nAlle auf Teams verteilen?`;
                if (!confirm(confirmMessage)) {
                    return;
                }
                
                // Shuffle users randomly
                for (let i = userArray.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [userArray[i], userArray[j]] = [userArray[j], userArray[i]];
                }
                
                // Clear all teams
                teamMembers = {
                    'red': [],
                    'blue': [],
                    'green': [],
                    'yellow': []
                };
                
                const teamIds = Object.keys(teamMembers);
                
                // Distribute users evenly
                userArray.forEach((userName, index) => {
                    const teamId = teamIds[index % teamIds.length];
                    teamMembers[teamId].push({
                        userName: userName,
                        joinedAt: Date.now()
                    });
                });
                
                // Save to Firebase
                if (tourApp.state.isFirebaseConnected && tourApp.state.tourId) {
                    try {
                        // Clear existing team assignments
                        const existingMembers = await getFromFirebase('teamMembers');
                        if (existingMembers && existingMembers.length > 0) {
                            for (const member of existingMembers) {
                                if (member.id) {
                                    await db.collection('tours').doc(tourApp.state.tourId)
                                        .collection('teamMembers').doc(member.id).delete();
                                }
                            }
                        }
                        
                        // Save new assignments
                        for (const [teamId, members] of Object.entries(teamMembers)) {
                            for (const member of members) {
                                await saveToFirebase('teamMembers', member.userName, {
                                    userName: member.userName,
                                    teamId: teamId,
                                    teamName: teamNames[teamId],
                                    joinedAt: firebase.firestore.FieldValue.serverTimestamp(),
                                    assignedBy: 'auto-assignment',
                                    assignedByUser: tourApp.state.userName
                                });
                            }
                        }
                        
                        // Broadcast team assignment event to all users
                        await saveToFirebase('teamAssignments', Date.now().toString(), {
                            type: 'auto-assignment',
                            assignedBy: tourApp.state.userName,
                            userCount: userArray.length,
                            assignments: teamMembers,
                            timestamp: firebase.firestore.FieldValue.serverTimestamp()
                        });
                        
                    } catch (firebaseError) {
                        console.error('Firebase save error during auto-assignment:', firebaseError);
                        showNotification('Teams verteilt, aber Synchronisation mit Server fehlgeschlagen', 'warning');
                    }
                }
                
                // Update current user's team if they were reassigned
                const currentUserTeam = Object.keys(teamMembers).find(teamId => 
                    teamMembers[teamId].some(member => member.userName === tourApp.state.userName)
                );

                if (currentUserTeam) {
                    tourApp.state.selectedTeam = currentUserTeam;
                    tourApp.state.teamName = teamNames[currentUserTeam];
                    updateCurrentTeamDisplay();
                    updateTeamChatTab();
                    
                    // Show team chat tab for current user
                    const teamChatTab = document.getElementById('teamChatTab');
                    if (teamChatTab) {
                        teamChatTab.style.display = 'block';
                    }
                    
                    // Save state without circular references
                    try {
                        const stateToSave = {
                            selectedTeam: tourApp.state.selectedTeam,
                            teamName: tourApp.state.teamName,
                            userName: tourApp.state.userName,
                            tourId: tourApp.state.tourId,
                            isAdmin: tourApp.state.isAdmin
                        };
                        localStorage.setItem('tourState', JSON.stringify(stateToSave));
                    } catch (saveError) {
                        console.log('State save skipped due to circular reference');
                    }
                    
                    // Reload chat history to include team chat
                    setTimeout(() => loadChatHistory(), 500);
                }
                
                generateTeamOptions();
                
                showNotification(`‚úÖ ${userArray.length} Nutzer automatisch auf Teams verteilt! üé≤`);
                addSystemMessage(`Admin hat ${userArray.length} Nutzer automatisch auf Teams verteilt! üé≤`);
                
                // Show distribution details
                const distributionDetails = Object.keys(teamMembers).map(teamId => {
                    const count = teamMembers[teamId].length;
                    const teamName = teamNames[teamId].split(' ')[1]; // Extract short name
                    return `${teamName}: ${count}`;
                }).join(', ');
                
                setTimeout(() => {
                    showNotification(`Verteilung: ${distributionDetails}`, 'success');
                }, 2000);
                
            } catch (error) {
                console.error('Error auto-assigning teams:', error);
                showNotification('Fehler bei der automatischen Team-Verteilung: ' + error.message, 'error');
            }
        } 

        function showWelcomeModal() {
            try {
                // Only check sessionStorage if user has already set a custom name
                const hasSetCustomName = localStorage.getItem('hasSetCustomName');
                const welcomeShown = sessionStorage.getItem('welcomeShown');

                console.log('Welcome modal detailed check:', {
                    hasSetCustomName: hasSetCustomName,
                    welcomeShown: welcomeShown,
                    userName: tourApp.state.userName,
                    startsWithTourist: tourApp.state.userName.startsWith('Tourist_')
                });

                // Don't show if user has already set a custom name permanently
                if (hasSetCustomName === 'true') {
                    console.log('Welcome modal blocked - user has set custom name');
                    return;
                }

                // Don't show if already shown in this session AND user hasn't changed
                if (welcomeShown && tourApp.state.userName.startsWith('Tourist_')) {
                    console.log('Welcome modal blocked - already shown this session');
                    return;
                }
                
                const modal = document.createElement('div');
                modal.className = 'admin-popup-overlay';
                modal.style.zIndex = '15000'; // Higher than other modals
                
                modal.innerHTML = `
                    <div class="admin-popup" style="max-width: 500px; width: 90%; background: linear-gradient(135deg, #dc2626 0%, #991b1b 100%); color: white;">
                        <h3 style="color: white; margin-bottom: 1.5rem; font-size: 1.8rem;">üèõÔ∏è Willkommen zur K√∂lner Tour!</h3>
                        
                        <div style="margin-bottom: 2rem; text-align: left; line-height: 1.6;">
                            <p style="margin-bottom: 1rem;">Bevor es losgeht, gib dir bitte einen <strong>eigenen Namen</strong> f√ºr die Tour!</p>
                            <ul style="margin-left: 1.5rem; margin-bottom: 1rem;">
                                <li>Dein Name wird im Chat und Ranking angezeigt</li>
                                <li>So k√∂nnen andere Teilnehmer dich erkennen</li>
                                <li>F√ºr die automatische Team-Verteilung wichtig</li>
                            </ul>
                        </div>
                        
                        <div style="margin-bottom: 1.5rem;">
                            <label style="display: block; font-weight: bold; margin-bottom: 0.5rem; color: white;">Dein Tour-Name:</label>
                            <input type="text" id="welcomeNameInput" maxlength="20" placeholder="z.B. Anna, Max, Team-Leader..." 
                                style="width: 100%; padding: 1rem; border: none; border-radius: 8px; font-size: 1.1rem; text-align: center;">
                            <small style="color: #fbbf24; display: block; margin-top: 0.5rem;">üí° W√§hle einen Namen, den andere leicht erkennen k√∂nnen</small>
                        </div>
                        
                        <div style="text-align: center;">
                            <button onclick="setWelcomeName()" style="background: white; color: #dc2626; border: none; padding: 1rem 2rem; border-radius: 25px; font-weight: bold; cursor: pointer; font-size: 1.1rem; margin-right: 1rem; transition: all 0.3s;" 
                                    onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 15px rgba(255,255,255,0.3)'" 
                                    onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none'">
                                üöÄ Tour starten
                            </button>
                            <button onclick="closeWelcomeModal()" style="background: transparent; color: white; border: 2px solid white; padding: 1rem 2rem; border-radius: 25px; font-weight: bold; cursor: pointer; font-size: 1.1rem; transition: all 0.3s;"
                                    onmouseover="this.style.background='rgba(255,255,255,0.1)'" 
                                    onmouseout="this.style.background='transparent'">
                                ‚è© Sp√§ter
                            </button>
                        </div>
                    </div>
                `;
                
                // Prevent closing by clicking background
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        e.stopPropagation();
                    }
                });
                
                document.body.appendChild(modal);

                // Add escape key handler
                const escapeHandler = (e) => {
                    if (e.key === 'Escape') {
                        modal.remove();
                        document.removeEventListener('keydown', escapeHandler);
                    }
                };
                document.addEventListener('keydown', escapeHandler);
                
                // Focus on input
                setTimeout(() => {
                    const input = document.getElementById('welcomeNameInput');
                    if (input) {
                        input.focus();
                        input.addEventListener('keypress', (e) => {
                            if (e.key === 'Enter') {
                                setWelcomeName();
                            }
                        });
                    }
                }, 100);
                
                // Only mark as shown if we actually showed it
                console.log('Welcome modal displayed successfully');
                
            } catch (error) {
                console.error('Error showing welcome modal:', error);
            }
        }

        function setWelcomeName() {
            try {
                const input = document.getElementById('welcomeNameInput');
                if (!input) return;
                
                const newName = input.value.trim();
                if (!newName || newName.length < 2) {
                    showNotification('Name muss mindestens 2 Zeichen haben!', 'error');
                    input.focus();
                    return;
                }
                
                const oldName = tourApp.state.userName;
                tourApp.state.userName = newName;
                
                // Update UI
                const displayEl = document.getElementById('currentUserName');
                if (displayEl) {
                    displayEl.textContent = newName;
                }
                
                // Register user immediately for team assignment
                registerUserForTeamAssignment();

                const userNameInput = document.getElementById('userNameInput');
                if (userNameInput) {
                    userNameInput.value = '';
                }
                
                // Register user immediately for team assignment
                registerUserForTeamAssignment();
                
                saveState();
                // Mark that user has set a custom name
                localStorage.setItem('hasSetCustomName', 'true');
                closeWelcomeModal();
                
                showNotification(`Willkommen ${newName}! üéâ`);
                addSystemMessage(`${newName} ist der Tour beigetreten! üëã`);
                
                // Show notification about team selection
                setTimeout(() => {
                    showNotification('üí° Tipp: W√§hle jetzt ein Team aus!', 'info');
                }, 2000);
                
            } catch (error) {
                console.error('Error setting welcome name:', error);
            }
        }

        function closeWelcomeModal() {
            try {
                const modal = document.querySelector('.admin-popup-overlay');
                if (modal) {
                    modal.remove();
                }
                // Mark as shown when closed
                sessionStorage.setItem('welcomeShown', 'true');
                console.log('Welcome modal closed and marked as shown');
            } catch (error) {
                console.error('Error closing welcome modal:', error);
            }
        }

        async function registerUserForTeamAssignment() {
            try {
                // Register user in Firebase for team assignment recognition
                if (tourApp.state.isFirebaseConnected && tourApp.state.tourId) {
                    await saveToFirebase('activeUsers', tourApp.state.userName, {
                        userName: tourApp.state.userName,
                        joinedAt: firebase.firestore.FieldValue.serverTimestamp(),
                        isActive: true,
                        tourId: tourApp.state.tourId
                    });
                }
                
                // Also register locally
                localStorage.setItem(`user_${tourApp.state.userName}`, JSON.stringify({
                    userName: tourApp.state.userName,
                    joinedAt: Date.now(),
                    isActive: true,
                    tourId: tourApp.state.tourId
                }));
                
                console.log(`‚úÖ User ${tourApp.state.userName} registered for team assignment`);
            } catch (error) {
                console.error('Error registering user for team assignment:', error);
            }
        }

        // App Initialization
        function initApp() {
            console.log('üöÄ Starting Tour App...');
            
            try {
                loadTourId();
                initFirebase();
                loadState();
                
                setTimeout(() => {
                    loadStationsFromFirebase()
                        .then(() => loadTourSettings())
                        .then(() => loadTeamData())
                        .then(() => {
                            generateStationsList();
                            updateUI();
                        })
                        .catch(error => {
                            console.error('Error in initialization timeout:', error);
                        });
                }, 1500);
                
                const chatInput = document.getElementById('chatInput');
                if (chatInput) {
                    chatInput.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter') {
                            sendMessage();
                        }
                    });
                }
                
                const userNameDisplay = document.getElementById('currentUserName');
                if (userNameDisplay) {
                    userNameDisplay.textContent = tourApp.state.userName;
                }

                // Check if user needs to set a proper name - show welcome modal for new users
                setTimeout(() => {
                    const hasSetCustomName = localStorage.getItem('hasSetCustomName');
                    console.log('Welcome modal check:', {
                        userName: tourApp.state.userName,
                        startsWithTourist: tourApp.state.userName.startsWith('Tourist_'),
                        hasSetCustomName: hasSetCustomName
                    });
                    
                    if (tourApp.state.userName.startsWith('Tourist_') || !hasSetCustomName) {
                        showWelcomeModal();
                    }
                }, 3000); // L√§nger warten, damit loadState() fertig ist
                
                console.log('‚úÖ Tour App initialized successfully');
                
                setTimeout(() => {
                    initGeolocation();
                    loadChatHistory();
                    initializeAdminChat();
                    startChatCleanup();
                    
                    // Initialize tour chat lock UI for admins
                    if (tourApp.state.isAdmin) {
                        const textEl = document.getElementById('tourChatLockText');
                        const btnEl = document.getElementById('tourChatLockBtn');
                        if (textEl && btnEl) {
                            if (tourApp.state.tourChatLocked) {
                                textEl.textContent = 'üîì Tour-Chat freigeben';
                                btnEl.style.background = '#dc2626';
                            } else {
                                textEl.textContent = 'üîí Tour-Chat sperren';
                                btnEl.style.background = '#059669';
                            }
                        }
                    }
                    
                    // Apply initial chat moderation state
                    updateChatModeration();
                }, 1000);
                
            } catch (error) {
                console.error('‚ùå Error initializing app:', error);
                showNotification('App-Start mit Fehlern. Basis-Funktionen verf√ºgbar.', 'error');
                
                if (!tourApp.state.tourId) {
                    tourApp.state.tourId = 'koeln-emergency-' + Date.now();
                    updateTourDisplay();
                    generateShareUrl();
                }
            }
        }

        async function loadStationsFromFirebase() {
            if (!tourApp.state.isFirebaseConnected || !tourApp.state.tourId) return;
            
            try {
                const firebaseStations = await getFromFirebase('stations');
                if (firebaseStations && firebaseStations.length > 0) {
                    tourApp.stations = firebaseStations.sort((a, b) => a.id - b.id);
                    console.log('‚úÖ Loaded stations from Firebase:', firebaseStations.length);
                    showNotification('üîÑ Stationen von Server geladen!');
                } else {
                    for (const station of tourApp.stations) {
                        saveToFirebase('stations', station.id.toString(), station).catch(error => 
                            console.error('Error saving station to Firebase:', error)
                        );
                    }
                    console.log('üì§ Initialized Firebase with default stations');
                }
            } catch (error) {
                console.error('Error loading stations from Firebase:', error);
            }
        }

        function loadTourId() {
            try {
                const urlParams = new URLSearchParams(window.location.search);
                const urlTourId = urlParams.get('tour');
                
                if (urlTourId && urlTourId.trim().length > 0) {
                    const cleanTourId = urlTourId.trim();
                    const savedTourId = localStorage.getItem('tourId');
                    
                    if (savedTourId !== cleanTourId) {
                        if (savedTourId) {
                            localStorage.removeItem(`chat_${savedTourId}`);
                            localStorage.removeItem(`tourState`);
                        }
                        
                        tourApp.state.tourId = cleanTourId;
                        localStorage.setItem('tourId', cleanTourId);
                        
                        tourApp.state.completedStations = [];
                        tourApp.state.totalScore = 0;
                        tourApp.state.uploadedPhotos = [];
                        tourApp.state.selectedTeam = null;
                        tourApp.state.teamName = '';
                        
                        setTimeout(() => addSystemMessage(`Der Tour "${cleanTourId}" beigetreten! üéâ`), 2000);
                    } else {
                        tourApp.state.tourId = cleanTourId;
                    }
                } else {
                    const savedTourId = localStorage.getItem('tourId');
                    if (savedTourId) {
                        tourApp.state.tourId = savedTourId;
                    } else {
                        tourApp.state.tourId = generateTourId();
                        localStorage.setItem('tourId', tourApp.state.tourId);
                    }
                }
                
                updateTourDisplay();
                generateShareUrl();
                
            } catch (error) {
                console.error('‚ùå Error loading tour ID:', error);
                tourApp.state.tourId = 'koeln-tour-fallback';
                updateTourDisplay();
                generateShareUrl();
            }
        }

        function generateTourId() {
            try {
                const today = new Date().toISOString().split('T')[0];
                const random = Math.random().toString(36).substr(2, 5);
                return `koeln-${today}-${random}`;
            } catch (error) {
                return 'koeln-tour-' + Math.random().toString(36).substr(2, 8);
            }
        }

        function updateTourDisplay() {
            try {
                const el = document.getElementById('currentTourId');
                if (el && tourApp.state.tourId) {
                    el.textContent = tourApp.state.tourId;
                }
            } catch (error) {
                console.error('Error updating tour display:', error);
            }
        }

        function generateShareUrl() {
            try {
                if (!tourApp.state.tourId) return;
                
                const baseUrl = window.location.origin + window.location.pathname;
                const shareUrl = `${baseUrl}?tour=${tourApp.state.tourId}`;
                const el = document.getElementById('shareUrl');
                if (el) {
                    el.textContent = shareUrl;
                }
            } catch (error) {
                console.error('Error generating share URL:', error);
                const el = document.getElementById('shareUrl');
                if (el) {
                    el.textContent = 'Fehler beim Generieren der URL';
                }
            }
        }

        // Chat Functions - ENHANCED with Team Chat and Moderation
        window.sendMessage = async function() {
            try {
                // Check if chat is blocked by moderation or tour lock
                if ((tourApp.state.chatBlocked || tourApp.state.tourChatLocked) && !tourApp.state.isAdmin) {
                    const reason = tourApp.state.tourChatLocked ? 'Tour-Chat ist noch nicht freigegeben!' : 'Chat ist vom Admin gesperrt!';
                    showNotification(reason + ' üõ°Ô∏è', 'warning');
                    return;
                }

                const input = document.getElementById('chatInput');
                if (!input) return;
                
                const message = input.value.trim();
                if (message) {
                    const messageData = {
                        userName: tourApp.state.userName,
                        teamName: tourApp.state.teamName,
                        message: message,
                        timestamp: firebase.firestore ? firebase.firestore.FieldValue.serverTimestamp() : Date.now(),
                        tourId: tourApp.state.tourId,
                        type: 'text'
                    };
                    
                    addChatMessage(messageData, true);
                    
                    if (tourApp.state.isFirebaseConnected && tourApp.state.tourId) {
                        await saveToFirebase('chat', Date.now().toString(), messageData);
                    } else {
                        const chatKey = `chat_${tourApp.state.tourId}`;
                        const chatMessages = JSON.parse(localStorage.getItem(chatKey) || '[]');
                        chatMessages.push(messageData);
                        if (chatMessages.length > 50) {
                            chatMessages.splice(0, chatMessages.length - 50);
                        }
                        localStorage.setItem(chatKey, JSON.stringify(chatMessages));
                    }
                    
                    input.value = '';
                }
            } catch (error) {
                console.error('Error sending message:', error);
                showNotification('Fehler beim Senden der Nachricht', 'error');
            }
        }

        async function sendTeamMessage() {
            try {
                if (!tourApp.state.selectedTeam) {
                    showNotification('Du musst erst einem Team beitreten!', 'error');
                    return;
                }

                // Check if chat is blocked by moderation or tour lock
                if ((tourApp.state.chatBlocked || tourApp.state.tourChatLocked) && !tourApp.state.isAdmin) {
                    const reason = tourApp.state.tourChatLocked ? 'Team-Chat ist noch nicht freigegeben!' : 'Team-Chat ist vom Admin gesperrt!';
                    showNotification(reason + ' üõ°Ô∏è', 'warning');
                    return;
                }

                const input = document.getElementById('teamChatInputField');
                if (!input) {
                    console.error('Team chat input not found');
                    return;
                }
                
                const message = input.value.trim();
                if (message) {
                    const messageData = {
                        userName: tourApp.state.userName,
                        message: message,
                        timestamp: firebase.firestore ? firebase.firestore.FieldValue.serverTimestamp() : Date.now(),
                        tourId: tourApp.state.tourId,
                        teamId: tourApp.state.selectedTeam,
                        type: 'text'
                    };
                    
                    addTeamChatMessage(messageData, true);
                    
                    if (tourApp.state.isFirebaseConnected && tourApp.state.tourId) {
                        await db.collection('tours').doc(tourApp.state.tourId)
                            .collection('teamChat').doc(tourApp.state.selectedTeam)
                            .collection('messages').doc(Date.now().toString())
                            .set(messageData);
                    } else {
                        const teamChatKey = `teamChat_${tourApp.state.tourId}_${tourApp.state.selectedTeam}`;
                        const teamChatMessages = JSON.parse(localStorage.getItem(teamChatKey) || '[]');
                        teamChatMessages.push(messageData);
                        if (teamChatMessages.length > 50) {
                            teamChatMessages.splice(0, teamChatMessages.length - 50);
                        }
                        localStorage.setItem(teamChatKey, JSON.stringify(teamChatMessages));
                    }
                    
                    input.value = '';
                }
            } catch (error) {
                console.error('Error sending team message:', error);
                showNotification('Fehler beim Senden der Team-Nachricht', 'error');
            }
        }

        function selectChatImage() {
            const input = document.getElementById('chatImageInput');
            if (input) {
                input.click();
            }
        }

        function selectTeamChatImage() {
            const input = document.getElementById('teamChatImageInput');
            if (input) {
                input.click();
            }
        }

        async function handleChatImageUpload(event) {
            try {
                // Check if chat is blocked by moderation
                if (tourApp.state.chatBlocked && !tourApp.state.isAdmin) {
                    showNotification('Chat ist vom Admin gesperrt! üõ°Ô∏è', 'warning');
                    return;
                }

                const file = event.target.files[0];
                if (!file) return;
                
                const compressedImage = await compressImage(file, 0.6, 600, 400);
                
                const messageData = {
                    userName: tourApp.state.userName,
                    image: compressedImage,
                    timestamp: firebase.firestore ? firebase.firestore.FieldValue.serverTimestamp() : Date.now(),
                    tourId: tourApp.state.tourId,
                    type: 'image'
                };
                
                addChatMessage(messageData, true);
                
                if (tourApp.state.isFirebaseConnected && tourApp.state.tourId) {
                    await saveToFirebase('chat', Date.now().toString(), messageData);
                } else {
                    const chatKey = `chat_${tourApp.state.tourId}`;
                    const chatMessages = JSON.parse(localStorage.getItem(chatKey) || '[]');
                    chatMessages.push(messageData);
                    if (chatMessages.length > 50) {
                        chatMessages.splice(0, chatMessages.length - 50);
                    }
                    localStorage.setItem(chatKey, JSON.stringify(chatMessages));
                }
                
                event.target.value = '';
            } catch (error) {
                console.error('Error uploading chat image:', error);
                showNotification('Fehler beim Hochladen des Bildes', 'error');
            }
        }

        async function handleTeamChatImageUpload(event) {
            try {
                if (!tourApp.state.selectedTeam) {
                    showNotification('Du musst erst einem Team beitreten!', 'error');
                    return;
                }

                const file = event.target.files[0];
                if (!file) return;
                
                const compressedImage = await compressImage(file, 0.6, 600, 400);
                
                const messageData = {
                    userName: tourApp.state.userName,
                    image: compressedImage,
                    timestamp: firebase.firestore ? firebase.firestore.FieldValue.serverTimestamp() : Date.now(),
                    tourId: tourApp.state.tourId,
                    teamId: tourApp.state.selectedTeam,
                    type: 'image'
                };
                
                addTeamChatMessage(messageData, true);
                
                if (tourApp.state.isFirebaseConnected && tourApp.state.tourId) {
                    await db.collection('tours').doc(tourApp.state.tourId)
                        .collection('teamChat').doc(tourApp.state.selectedTeam)
                        .collection('messages').doc(Date.now().toString())
                        .set(messageData);
                } else {
                    const teamChatKey = `teamChat_${tourApp.state.tourId}_${tourApp.state.selectedTeam}`;
                    const teamChatMessages = JSON.parse(localStorage.getItem(teamChatKey) || '[]');
                    teamChatMessages.push(messageData);
                    if (teamChatMessages.length > 50) {
                        teamChatMessages.splice(0, teamChatMessages.length - 50);
                    }
                    localStorage.setItem(teamChatKey, JSON.stringify(teamChatMessages));
                }
                
                event.target.value = '';
            } catch (error) {
                console.error('Error uploading team chat image:', error);
                showNotification('Fehler beim Hochladen des Team-Bildes', 'error');
            }
        }

        function compressImage(file, quality = 0.7, maxWidth = 800, maxHeight = 600) {
            return new Promise((resolve) => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const img = new Image();
                
                img.onload = () => {
                    let { width, height } = img;
                    
                    if (width > maxWidth) {
                        height = (height * maxWidth) / width;
                        width = maxWidth;
                    }
                    
                    if (height > maxHeight) {
                        width = (width * maxHeight) / height;
                        height = maxHeight;
                    }
                    
                    canvas.width = width;
                    canvas.height = height;
                    
                    ctx.drawImage(img, 0, 0, width, height);
                    canvas.toBlob(
                        (blob) => {
                            const reader = new FileReader();
                            reader.onload = () => resolve(reader.result);
                            reader.readAsDataURL(blob);
                        },
                        'image/jpeg',
                        quality
                    );
                };
                
                img.src = URL.createObjectURL(file);
            });
        }

        function addChatMessage(messageData, isOwn = false) {
            try {
                const chatContainer = document.getElementById('chatContainer');
                if (!chatContainer) return;
                
                const messageDiv = document.createElement('div');
                messageDiv.className = `chat-message ${isOwn ? 'own' : ''}`;
                
                const timeStr = new Date().toLocaleTimeString('de-DE', {
                    hour: '2-digit',
                    minute: '2-digit'
                });
                
                let messageContent = '';
                
                if (messageData.type === 'image') {
                    messageContent = `
                        <strong>${messageData.userName}:</strong> hat ein Bild geteilt<br>
                        <div class="chat-image-container">
                            <img src="${messageData.image}" class="chat-image" onclick="event.stopPropagation(); showImageModal('${messageData.image}', 'Chat Bild', 'Von ${messageData.userName} geteilt')" alt="Chat Bild">
                        </div>
                        <span class="timestamp">${timeStr}</span>
                    `;
                } else {
                    const userTeam = messageData.teamName || (messageData.userName === tourApp.state.userName ? tourApp.state.teamName : '');
                    const teamDisplay = userTeam ? ` (${userTeam})` : '';

                    messageContent = `
                        <strong>${messageData.userName}${teamDisplay}:</strong> ${messageData.message}
                        <span class="timestamp">${timeStr}</span>
                    `;
                }

                messageDiv.innerHTML = messageContent;
                
                chatContainer.appendChild(messageDiv);
                chatContainer.scrollTop = chatContainer.scrollHeight;
                
                if (!isOwn && tourApp.state.currentTab !== 'chat') {
                    tourApp.state.unreadMessages++;
                    updateChatNotification();
                    
                    const notificationText = messageData.type === 'image' 
                        ? `üì∑ ${messageData.userName} hat ein Bild geteilt`
                        : `üí¨ ${messageData.userName}: ${messageData.message.substring(0, 30)}${messageData.message.length > 30 ? '...' : ''}`;
                        
                    showClickableNotification(notificationText, 'chat');
                } else if (!isOwn && tourApp.state.currentTab === 'chat' && tourApp.state.currentChatTab !== 'main') {
                    // User is in chat but not on main tab
                    tourApp.state.unreadMessages++;
                    updateChatNotification();
                }
            } catch (error) {
                console.error('Error adding chat message:', error);
            }
        }

        function addTeamChatMessage(messageData, isOwn = false) {
            try {
                const teamChatContainer = document.getElementById('teamChatMessages');
                if (!teamChatContainer) return;
                
                const messageDiv = document.createElement('div');
                messageDiv.className = `chat-message ${isOwn ? 'own' : ''}`;
                
                const timeStr = new Date().toLocaleTimeString('de-DE', {
                    hour: '2-digit',
                    minute: '2-digit'
                });
                
                let messageContent = '';
                
                if (messageData.type === 'image') {
                    messageContent = `
                        <strong>${messageData.userName}:</strong> hat ein Team-Bild geteilt<br>
                        <div class="chat-image-container">
                            <img src="${messageData.image}" class="chat-image" onclick="event.stopPropagation(); showImageModal('${messageData.image}', 'Team Chat Bild', 'Von ${messageData.userName} geteilt')" alt="Team Chat Bild">
                        </div>
                        <span class="timestamp">${timeStr}</span>
                    `;
                } else {
                    const userTeam = messageData.teamName || (messageData.userName === tourApp.state.userName ? tourApp.state.teamName : '');
                    const teamDisplay = userTeam ? ` (${userTeam})` : '';

                    messageContent = `
                        <strong>${messageData.userName}${teamDisplay}:</strong> ${messageData.message}
                        <span class="timestamp">${timeStr}</span>
                    `;
                }

                messageDiv.innerHTML = messageContent;
                
                teamChatContainer.appendChild(messageDiv);
                teamChatContainer.scrollTop = teamChatContainer.scrollHeight;
                
                if (!isOwn && (tourApp.state.currentTab !== 'chat' || tourApp.state.currentChatTab !== 'team')) {
                    tourApp.state.unreadTeamMessages++;
                    updateTeamChatNotification();
                    
                    const notificationText = messageData.type === 'image' 
                        ? `üì∑ ${messageData.userName} hat ein Team-Bild geteilt`
                        : `üë• ${messageData.userName}: ${messageData.message.substring(0, 30)}${messageData.message.length > 30 ? '...' : ''}`;
                        
                    showClickableNotification(notificationText, 'team');
                }
            } catch (error) {
                console.error('Error adding team chat message:', error);
            }
        }

        function showChatTab(tabType, tabElement) {
            try {
                tourApp.state.currentChatTab = tabType;
                
                // Update tab appearance
                document.querySelectorAll('.chat-sub-tab').forEach(tab => tab.classList.remove('active'));
                if (tabElement) {
                    tabElement.classList.add('active');
                }

                // Show/hide chat sections
                document.querySelectorAll('.chat-section').forEach(section => {
                    section.classList.remove('active');
                    section.style.display = 'none';
                });
                
                if (tabType === 'main') {
                    const mainContainer = document.getElementById('mainChatContainer');
                    if (mainContainer) {
                        mainContainer.classList.add('active');
                        mainContainer.style.display = 'block';
                    }
                    clearChatNotification();
                } else if (tabType === 'team') {
                    const teamContainer = document.getElementById('teamChatContainer');
                    if (teamContainer) {
                        teamContainer.classList.add('active');
                        teamContainer.style.display = 'block';
                    }
                    clearTeamChatNotification();
                } else if (tabType === 'admin') {
                    const adminContainer = document.getElementById('adminChatContainer');
                    if (adminContainer) {
                        adminContainer.classList.add('active');
                        adminContainer.style.display = 'block';
                    }
                    clearAdminChatNotification();
                    currentAdminChatUser = null;
                } else if (tabType.startsWith('admin_')) {
                    // Admin chat with specific user
                    const userName = tabType.replace('admin_', '');
                    const adminContainer = document.getElementById(`adminChatContainer_${userName}`);
                    if (adminContainer) {
                        adminContainer.classList.add('active');
                        adminContainer.style.display = 'block';
                    }
                    clearAdminChatNotification(userName);
                    currentAdminChatUser = userName;
                }
            } catch (error) {
                console.error('Error showing chat tab:', error);
            }
        }

        function updateChatNotification() {
            const chatTab = document.querySelector('.tab[onclick*="chat"]');
            if (chatTab && tourApp.state.unreadMessages > 0) {
                let notification = chatTab.querySelector('.tab-notification');
                if (!notification) {
                    notification = document.createElement('div');
                    notification.className = 'tab-notification';
                    chatTab.appendChild(notification);
                }
                notification.textContent = tourApp.state.unreadMessages > 9 ? '9+' : tourApp.state.unreadMessages;
            }
        }

        function updateTeamChatNotification() {
            const teamChatTab = document.getElementById('teamChatTab');
            if (teamChatTab && tourApp.state.unreadTeamMessages > 0) {
                let notification = teamChatTab.querySelector('.tab-notification');
                if (!notification) {
                    notification = document.createElement('div');
                    notification.className = 'tab-notification';
                    notification.style.position = 'absolute';
                    notification.style.top = '5px';
                    notification.style.right = '8px';
                    teamChatTab.style.position = 'relative';
                    teamChatTab.appendChild(notification);
                }
                notification.textContent = tourApp.state.unreadTeamMessages > 9 ? '9+' : tourApp.state.unreadTeamMessages;
            }
        }

        function clearChatNotification() {
            tourApp.state.unreadMessages = 0;
            const chatTab = document.querySelector('.tab[onclick*="chat"]');
            if (chatTab) {
                const notification = chatTab.querySelector('.tab-notification');
                if (notification) {
                    notification.remove();
                }
            }
        }

        function clearTeamChatNotification() {
            tourApp.state.unreadTeamMessages = 0;
            const teamChatTab = document.getElementById('teamChatTab');
            if (teamChatTab) {
                const notification = teamChatTab.querySelector('.tab-notification');
                if (notification) {
                    notification.remove();
                }
            }
        }

        function showClickableNotification(message, targetTab = 'chat') {
            try {
                const notification = document.createElement('div');
                notification.className = 'notification clickable';
                notification.innerHTML = `
                    ${message}<br>
                    <small>üëÜ Klicken um zum Chat zu gelangen</small>
                `;
                
                notification.onclick = () => {
                    window.showTab('chat', document.querySelector('.tab[onclick*="chat"]'));
                    if (targetTab === 'team') {
                        setTimeout(() => showChatTab('team', document.getElementById('teamChatTab')), 100);
                    }
                    notification.remove();
                };
                
                document.body.appendChild(notification);

                setTimeout(() => {
                    if (notification.parentElement) {
                        notification.remove();
                    }
                }, 5000);
            } catch (error) {
                console.error('Error showing clickable notification:', error);
            }
        }

        function updateChatModeration() {
            try {
                const moderationNotice = document.getElementById('chatModerationNotice');
                const mainChatInput = document.getElementById('mainChatInput');
                const teamChatInput = document.getElementById('teamChatInput');
                
                const isChatDisabled = (tourApp.state.chatBlocked || tourApp.state.tourChatLocked) && !tourApp.state.isAdmin;
                
                if (isChatDisabled) {
                    // Show moderation notice and disable inputs
                    if (moderationNotice) {
                        moderationNotice.classList.remove('hidden');
                        // Update notice text based on lock type
                        const noticeText = moderationNotice.querySelector('p');
                        if (noticeText) {
                            if (tourApp.state.tourChatLocked) {
                                noticeText.textContent = 'Der Chat wurde vom Admin noch nicht f√ºr diese Tour freigegeben.';
                            } else {
                                noticeText.textContent = 'Der Chat wurde vom Admin gesperrt. Nachrichten k√∂nnen aktuell nicht gesendet werden.';
                            }
                        }
                    }
                    if (mainChatInput) {
                        mainChatInput.style.opacity = '0.5';
                        mainChatInput.style.pointerEvents = 'none';
                    }
                    if (teamChatInput) {
                        teamChatInput.style.opacity = '0.5';
                        teamChatInput.style.pointerEvents = 'none';
                    }
                } else {
                    // Hide notice and enable inputs
                    if (moderationNotice) {
                        moderationNotice.classList.add('hidden');
                    }
                    if (mainChatInput) {
                        mainChatInput.style.opacity = '1';
                        mainChatInput.style.pointerEvents = 'all';
                    }
                    if (teamChatInput) {
                        teamChatInput.style.opacity = '1';
                        teamChatInput.style.pointerEvents = 'all';
                    }
                }
            } catch (error) {
                console.error('Error updating chat moderation:', error);
            }
        }

        function addSystemMessage(message) {
            try {
                setTimeout(() => {
                    const messageData = {
                        userName: 'System',
                        message: message,
                        type: 'text'
                    };
                    addChatMessage(messageData, false);
                }, 100);
            } catch (error) {
                console.error('Error adding system message:', error);
            }
        }

        async function loadChatHistory() {
            try {
                // Load main chat
                if (tourApp.state.isFirebaseConnected && tourApp.state.tourId) {
                    const messages = await getFromFirebase('chat');
                    messages.forEach(msg => {
                        if (msg.userName !== tourApp.state.userName) {
                            // Handle special challenge photo messages
                            if (msg.type === 'challenge-photo') {
                                addChallengePhotoMessage(msg, false);
                            } else {
                                addChatMessage(msg, false);
                            }
                        }
                    });
                } else {
                    const chatKey = `chat_${tourApp.state.tourId}`;
                    const chatMessages = JSON.parse(localStorage.getItem(chatKey) || '[]');
                    chatMessages.forEach(msg => {
                        if (msg.type === 'challenge-photo') {
                            addChallengePhotoMessage(msg, msg.userName === tourApp.state.userName);
                        } else {
                            addChatMessage(msg, msg.userName === tourApp.state.userName);
                        }
                    });
                }

                // Load team chat if user has selected a team
                if (tourApp.state.selectedTeam) {
                    if (tourApp.state.isFirebaseConnected && tourApp.state.tourId) {
                        try {
                            const teamSnapshot = await db.collection('tours').doc(tourApp.state.tourId)
                                .collection('teamChat').doc(tourApp.state.selectedTeam)
                                .collection('messages').orderBy('timestamp', 'asc').get();
                            
                            teamSnapshot.docs.forEach(doc => {
                                const msg = doc.data();
                                if (msg.userName !== tourApp.state.userName) {
                                    addTeamChatMessage(msg, false);
                                }
                            });
                        } catch (error) {
                            console.log('No team chat history found');
                        }
                    } else {
                        const teamChatKey = `teamChat_${tourApp.state.tourId}_${tourApp.state.selectedTeam}`;
                        const teamChatMessages = JSON.parse(localStorage.getItem(teamChatKey) || '[]');
                        teamChatMessages.forEach(msg => {
                            addTeamChatMessage(msg, msg.userName === tourApp.state.userName);
                        });
                    }
                }
            } catch (error) {
                console.error('Error loading chat history:', error);
            }
        }

        // Ranking Functions
        async function updateRanking() {
            try {
                const rankingList = document.getElementById('rankingList');
                if (!rankingList) return;
                
                let teams = [];
                
                if (tourApp.state.isFirebaseConnected && tourApp.state.tourId) {
                    teams = await getFromFirebase('scores');
                    
                    if (tourApp.state.selectedTeam && tourApp.state.teamName && 
                        !teams.find(t => t.teamId === tourApp.state.selectedTeam)) {
                        teams.push({
                            teamId: tourApp.state.selectedTeam,
                            teamName: tourApp.state.teamName,
                            score: tourApp.state.totalScore,
                            isUser: true
                        });
                    }
                } else {
                    const teamNames = {
                        'red': 'üî¥ Team R√∂mer',
                        'blue': 'üîµ Team Gaffeln', 
                        'green': 'üü¢ Team Hanseat',
                        'yellow': 'üü° Team Modern'
                    };
                    
                    Object.keys(teamNames).forEach(teamId => {
                        teams.push({
                            teamId: teamId,
                            teamName: teamNames[teamId],
                            score: tourApp.state.selectedTeam === teamId ? 
                                   tourApp.state.totalScore : 
                                   Math.floor(Math.random() * 200) + 50,
                            isUser: tourApp.state.selectedTeam === teamId
                        });
                    });
                }
                
                teams.sort((a, b) => b.score - a.score);
                
                rankingList.innerHTML = '';
                
                teams.forEach((team, index) => {
                    const rankItem = document.createElement('div');
                    const isUserTeam = team.isUser || (team.teamId === tourApp.state.selectedTeam);
                    rankItem.className = `team-rank-item ${isUserTeam ? 'highlight' : ''}`;
                    
                    let rankClass = '';
                    if (index === 0) rankClass = 'gold';
                    else if (index === 1) rankClass = 'silver';
                    else if (index === 2) rankClass = 'bronze';
                    
                    rankItem.innerHTML = `
                        <div class="rank-position ${rankClass}">${index + 1}</div>
                        <div style="flex: 1;">
                            <strong>${team.teamName}</strong>
                            <div style="color: #6b7280; font-size: 0.9rem;">
                                ${team.score} Punkte
                            </div>
                        </div>
                        ${isUserTeam ? '<div style="color: #f59e0b;">üë§</div>' : ''}
                    `;
                    
                    rankingList.appendChild(rankItem);
                });
            } catch (error) {
                console.error('Error updating ranking:', error);
            }
        }

        // Admin Functions - ENHANCED
        function generateContentEditor() {
            try {
                const container = document.getElementById('adminContentEditor');
                if (!container) return;
                
                container.innerHTML = '';
                
                tourApp.stations.forEach(station => {
                    const stationEditor = document.createElement('div');
                    stationEditor.className = 'admin-station-editor';
                    stationEditor.id = `admin-station-${station.id}`;
                    
                    stationEditor.innerHTML = `
                        <div class="admin-station-header" onclick="toggleStationEditor(${station.id})">
                            <div>
                                <h5 style="color: #1f2937; margin: 0;">Station ${station.id}: ${station.title}</h5>
                                <small style="color: #6b7280;">Klicken zum Bearbeiten</small>
                            </div>
                            <div class="admin-expand-icon" id="expand-icon-${station.id}">‚ñ∂</div>
                        </div>
                        
                        <div class="admin-station-content" id="station-content-${station.id}">
                            <div style="margin-bottom: 1rem;">
                                <label style="display: block; font-weight: bold; margin-bottom: 0.5rem;">Titel:</label>
                                <input type="text" class="admin-input" id="edit-title-${station.id}" value="${station.title}">
                            </div>
                            
                            <div style="margin-bottom: 1rem;">
                                <label style="display: block; font-weight: bold; margin-bottom: 0.5rem;">Untertitel:</label>
                                <input type="text" class="admin-input" id="edit-subtitle-${station.id}" value="${station.subtitle}">
                            </div>
                            
                            <div style="margin-bottom: 1rem;">
                                <label style="display: block; font-weight: bold; margin-bottom: 0.5rem;">Haupttext:</label>
                                <div style="display: flex; gap: 0.5rem; margin-bottom: 0.5rem;">
                                    <button class="btn btn-secondary btn-small" onclick="showPerplexityHelper(${station.id}, 'mainText')" style="background: #8b5cf6;">ü§ñ KI-Text generieren</button>
                                </div>
                                <textarea class="admin-textarea" id="edit-maintext-${station.id}">${station.mainText}</textarea>
                            </div>

                            <div style="margin-bottom: 1rem;">
                                <label style="display: block; font-weight: bold; margin-bottom: 0.5rem;">Foto-Challenge:</label>
                                <div style="display: flex; gap: 0.5rem; margin-bottom: 0.5rem;">
                                    <button class="btn btn-secondary btn-small" onclick="showPerplexityHelper(${station.id}, 'photoChallenge')" style="background: #8b5cf6;">ü§ñ KI-Challenge generieren</button>
                                </div>
                                <textarea class="admin-textarea" id="edit-challenge-${station.id}" style="min-height: 80px;">${station.photoChallenge}</textarea>
                            </div>
                                                       
                            <div style="margin-bottom: 1rem;">
                                <label style="display: block; font-weight: bold; margin-bottom: 0.5rem;">üìç Standort festlegen:</label>
                                
                                <!-- Address Search -->
                                <div style="margin-bottom: 1rem;">
                                    <div class="input-group">
                                        <input type="text" class="admin-input" id="edit-address-${station.id}" placeholder="Adresse suchen (z.B. Heumarkt 14, K√∂ln)" style="flex: 1;">
                                        <button class="btn btn-secondary btn-small" onclick="searchAddress(${station.id})" style="margin-left: 0.5rem;">üîç Suchen</button>
                                    </div>
                                    <div id="address-results-${station.id}" style="display: none; background: white; border: 2px solid #e5e7eb; border-radius: 8px; max-height: 200px; overflow-y: auto; margin-top: 0.5rem;"></div>
                                </div>
                                
                                <!-- Interactive Map -->
                                <div style="margin-bottom: 1rem;">
                                    <div id="location-map-${station.id}" style="height: 300px; width: 100%; border-radius: 8px; border: 2px solid #e5e7eb; cursor: crosshair;"></div>
                                    <p style="font-size: 0.8rem; color: #6b7280; margin-top: 0.5rem;">
                                        üí° Klicke auf die Karte um den Standort zu setzen oder verwende die Adresssuche
                                    </p>
                                </div>
                                
                                <!-- Coordinates Display -->
                                <div style="background: #f9fafb; padding: 1rem; border-radius: 8px; border: 1px solid #e5e7eb;">
                                    <label style="display: block; font-weight: bold; margin-bottom: 0.5rem; color: #374151;">Aktuelle Koordinaten:</label>
                                    <div class="admin-lat-lng">
                                        <input type="number" class="admin-input" id="edit-lat-${station.id}" value="${station.lat}" step="0.000001" placeholder="Breitengrad" readonly style="background: #f3f4f6;">
                                        <input type="number" class="admin-input" id="edit-lng-${station.id}" value="${station.lng}" step="0.000001" placeholder="L√§ngengrad" readonly style="background: #f3f4f6;">
                                    </div>
                                    <button class="btn btn-secondary btn-small" onclick="manualCoordinates(${station.id})" style="margin-top: 0.5rem;">
                                        ‚úèÔ∏è Koordinaten manuell bearbeiten
                                    </button>
                                </div>
                            </div>
                            
                            <div style="margin-bottom: 1rem;">
                                <label style="display: block; font-weight: bold; margin-bottom: 0.5rem;">Bildergalerie bearbeiten:</label>
                                <div id="image-editor-${station.id}" style="border: 2px solid #e5e7eb; border-radius: 8px; padding: 1rem; background: #f9fafb;">
                                    ${generateImageEditor(station)}
                                </div>
                                <button class="btn btn-secondary btn-small" onclick="addNewImage(${station.id})" style="margin-top: 0.5rem;">‚ûï Neues Bild hinzuf√ºgen</button>
                            </div>
                            
                            <div style="margin-bottom: 1rem;">
                                <label style="display: block; font-weight: bold; margin-bottom: 0.5rem;">Audio-Dateien bearbeiten:</label>
                                <div id="audio-editor-${station.id}" style="border: 2px solid #e5e7eb; border-radius: 8px; padding: 1rem; background: #f0f9ff;">
                                    ${generateAudioEditor(station)}
                                </div>
                                <button class="btn btn-secondary btn-small" onclick="addNewAudio(${station.id})" style="margin-top: 0.5rem;">üéµ Neue Audio-Datei hinzuf√ºgen</button>
                            </div>
                            
                            <div style="display: flex; gap: 1rem;">
                                <button class="btn btn-admin btn-small" onclick="saveStationChanges(${station.id})">üíæ √Ñnderungen speichern</button>
                                <button class="btn btn-secondary btn-small" onclick="resetStationEditor(${station.id})">üîÑ Zur√ºcksetzen</button>
                                <button class="btn btn-secondary btn-small" onclick="deleteStation(${station.id})">üóëÔ∏è Station l√∂schen</button>
                            </div>
                        </div>
                    `;
                    
                    container.appendChild(stationEditor);
                });
                
                const addButton = document.createElement('div');
                addButton.style.textAlign = 'center';
                addButton.style.marginTop = '2rem';
                addButton.innerHTML = `
                    <button class="btn btn-admin" onclick="addNewStation()">‚ûï Neue Station hinzuf√ºgen</button>
                `;
                container.appendChild(addButton);
                
            } catch (error) {
                console.error('Error generating content editor:', error);
            }
        }

        function toggleStationEditor(stationId) {
            try {
                const content = document.getElementById(`station-content-${stationId}`);
                const header = document.querySelector(`#admin-station-${stationId} .admin-station-header`);
                const icon = document.getElementById(`expand-icon-${stationId}`);
                
                if (content && header && icon) {
                    const isExpanded = content.classList.contains('expanded');
                    
                    if (isExpanded) {
                        content.classList.remove('expanded');
                        header.classList.remove('expanded');
                        icon.classList.remove('expanded');
                    } else {
                        content.classList.add('expanded');
                        header.classList.add('expanded');
                        icon.classList.add('expanded');
                        
                        // Initialize location map when editor is opened
                        setTimeout(() => {
                            initStationLocationMap(stationId);
                        }, 100);
                    }
                }
            } catch (error) {
                console.error('Error toggling station editor:', error);
            }
        }

        async function clearAllChatMessages() {
            try {
                if (confirm('Alle Chat-Nachrichten f√ºr ALLE Teilnehmer l√∂schen? Diese Aktion kann nicht r√ºckg√§ngig gemacht werden.')) {
                    // Clear Firebase chat collection for all users
                    if (tourApp.state.isFirebaseConnected && tourApp.state.tourId) {
                        const chatRef = db.collection('tours').doc(tourApp.state.tourId).collection('chat');
                        const snapshot = await chatRef.get();
                        
                        const batch = db.batch();
                        snapshot.docs.forEach((doc) => {
                            batch.delete(doc.ref);
                        });
                        await batch.commit();

                        // Also clear all team chats
                        const teamChatRef = db.collection('tours').doc(tourApp.state.tourId).collection('teamChat');
                        const teamSnapshot = await teamChatRef.get();
                        
                        for (const teamDoc of teamSnapshot.docs) {
                            const messagesRef = teamDoc.ref.collection('messages');
                            const messagesSnapshot = await messagesRef.get();
                            
                            const teamBatch = db.batch();
                            messagesSnapshot.docs.forEach((messageDoc) => {
                                teamBatch.delete(messageDoc.ref);
                            });
                            await teamBatch.commit();
                        }
                    }
                    
                    // IMMEDIATE LOCAL CLEARING FOR ALL USERS - FIXED!
                    // This will be synchronized by Firebase listeners automatically
                    
                    // Clear main chat DOM immediately
                    const chatContainer = document.getElementById('chatContainer');
                    if (chatContainer) {
                        // Remove ALL messages, including challenge photos
                        const allMessages = chatContainer.querySelectorAll('.chat-message');
                        allMessages.forEach(msg => {
                            if (!msg.classList.contains('system') || msg.textContent.includes('geleert')) {
                                msg.remove();
                            }
                        });
                        
                        // Add confirmation message
                        const confirmationMsg = document.createElement('div');
                        confirmationMsg.className = 'chat-message system';
                        confirmationMsg.innerHTML = `
                            <strong>Admin:</strong> Chat wurde komplett geleert! üóëÔ∏è<br>
                            <small>Alle Nachrichten wurden f√ºr alle Teilnehmer entfernt</small>
                            <span class="timestamp">jetzt</span>
                        `;
                        chatContainer.appendChild(confirmationMsg);
                    }

                    // Clear team chat DOM immediately
                    const teamChatContainer = document.getElementById('teamChatMessages');
                    if (teamChatContainer) {
                        const allTeamMessages = teamChatContainer.querySelectorAll('.chat-message');
                        allTeamMessages.forEach(msg => {
                            if (!msg.classList.contains('system') || msg.textContent.includes('geleert')) {
                                msg.remove();
                            }
                        });
                        
                        const teamConfirmationMsg = document.createElement('div');
                        teamConfirmationMsg.className = 'chat-message system';
                        teamConfirmationMsg.innerHTML = `
                            <strong>Admin:</strong> Team-Chat wurde geleert! üóëÔ∏è<br>
                            <small>Alle Team-Nachrichten wurden entfernt</small>
                            <span class="timestamp">jetzt</span>
                        `;
                        teamChatContainer.appendChild(teamConfirmationMsg);
                    }
                    
                    // Clear localStorage for all tour participants
                    localStorage.removeItem(`chat_${tourApp.state.tourId}`);
                    // Clear all team chats from localStorage
                    Object.keys(localStorage).forEach(key => {
                        if (key.startsWith(`teamChat_${tourApp.state.tourId}_`)) {
                            localStorage.removeItem(key);
                        }
                    });
                    
                    showNotification('Alle Chats komplett geleert f√ºr alle Teilnehmer! üóëÔ∏è');
                    
                    // Send system message to Firebase so all users see the notification
                    if (tourApp.state.isFirebaseConnected) {
                        await saveToFirebase('chat', `system_${Date.now()}`, {
                            userName: 'üîä System',
                            message: 'Alle Chats wurden vom Admin geleert',
                            timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                            type: 'system'
                        });
                    }

                    // Broadcast clearing event to all connected clients via Firebase
                    if (tourApp.state.isFirebaseConnected) {
                        await db.collection('tours').doc(tourApp.state.tourId)
                            .collection('events').doc(`clear_${Date.now()}`).set({
                                type: 'chat_cleared',
                                timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                                by: tourApp.state.userName
                            });
                    }
                }
            } catch (error) {
                console.error('Error clearing all chat messages:', error);
                showNotification('Fehler beim L√∂schen der Nachrichten', 'error');
            }
        }

        async function toggleChatModeration() {
            try {
                tourApp.state.chatModeration = !tourApp.state.chatModeration;
                tourApp.state.chatBlocked = tourApp.state.chatModeration; // Set blocked status
                
                const textEl = document.getElementById('chatModerationText');
                
                if (textEl) {
                    textEl.textContent = tourApp.state.chatModeration ? 
                        'üîì Chat freigeben' : 
                        'üõ°Ô∏è Chat sperren';
                }

                // Save moderation status to Firebase to sync with all users
                if (tourApp.state.isFirebaseConnected && tourApp.state.tourId) {
                    await db.collection('tours').doc(tourApp.state.tourId)
                        .collection('settings').doc('moderation')
                        .set({
                            chatBlocked: tourApp.state.chatBlocked,
                            moderatedBy: tourApp.state.userName,
                            timestamp: firebase.firestore.FieldValue.serverTimestamp()
                        });
                }

                // Update local moderation UI
                updateChatModeration();
                
                showNotification(tourApp.state.chatModeration ? 
                    'Chat f√ºr alle gesperrt! üîí' : 
                    'Chat f√ºr alle freigegeben! üîì');
                    
                addSystemMessage(tourApp.state.chatModeration ? 
                    'Chat wurde vom Admin gesperrt üîí' : 
                    'Chat wurde vom Admin freigegeben üîì');
            } catch (error) {
                console.error('Error toggling chat moderation:', error);
            }
        }

        async function toggleTourChatLock() {
            try {
                tourApp.state.tourChatLocked = !tourApp.state.tourChatLocked;
                
                const textEl = document.getElementById('tourChatLockText');
                const btnEl = document.getElementById('tourChatLockBtn');
                
                if (textEl && btnEl) {
                    if (tourApp.state.tourChatLocked) {
                        textEl.textContent = 'üîì Tour-Chat freigeben';
                        btnEl.style.background = '#dc2626'; // Red when locked
                    } else {
                        textEl.textContent = 'üîí Tour-Chat sperren';
                        btnEl.style.background = '#059669'; // Green when unlocked
                    }
                }

                // Save tour chat lock status to Firebase to sync with all users
                if (tourApp.state.isFirebaseConnected && tourApp.state.tourId) {
                    await db.collection('tours').doc(tourApp.state.tourId)
                        .collection('settings').doc('tourLock')
                        .set({
                            tourChatLocked: tourApp.state.tourChatLocked,
                            lockedBy: tourApp.state.userName,
                            timestamp: firebase.firestore.FieldValue.serverTimestamp()
                        });
                }

                // Update local chat UI
                updateChatModeration();
                
                const actionText = tourApp.state.tourChatLocked ? 'gesperrt' : 'freigegeben';
                const actionIcon = tourApp.state.tourChatLocked ? 'üîí' : 'üîì';
                
                showNotification(`Tour-Chat f√ºr alle ${actionText}! ${actionIcon}`);
                
                const systemMessage = tourApp.state.tourChatLocked ? 
                    'Tour-Chat wurde vom Admin gesperrt üîí' : 
                    'Tour-Chat wurde vom Admin freigegeben - die Tour kann beginnen! üîì';
                addSystemMessage(systemMessage);
                
            } catch (error) {
                console.error('Error toggling tour chat lock:', error);
                showNotification('Fehler beim √Ñndern des Tour-Chat Status', 'error');
            }
        }

        async function sendAdminAnnouncement() {
            try {
                const message = prompt('Admin-Ank√ºndigung eingeben:');
                if (message && message.trim()) {
                    const announcement = message.trim();
                    
                    // Send to chat
                    if (tourApp.state.isFirebaseConnected) {
                        await saveToFirebase('chat', Date.now().toString(), {
                            userName: 'üîä Admin',
                            message: announcement,
                            timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                            type: 'announcement'
                        });
                    }
                    
                    // Send as popup to all users
                    if (tourApp.state.isFirebaseConnected) {
                        await saveToFirebase('announcements', Date.now().toString(), {
                            message: announcement,
                            timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                            isActive: true
                        });
                    }
                    
                    // Show popup locally for admin too
                    showAdminPopup('üì¢ Admin-Ank√ºndigung', announcement);
                    
                    showNotification('Admin-Ank√ºndigung gesendet! üì¢');
                }
            } catch (error) {
                console.error('Error sending admin announcement:', error);
            }
        }

        function showAdminPopup(title, message) {
            try {
                const overlay = document.createElement('div');
                overlay.className = 'admin-popup-overlay';
                
                overlay.innerHTML = `
                    <div class="admin-popup">
                        <h3>${title}</h3>
                        <p>${message}</p>
                        <button class="admin-popup-close" onclick="closeAdminPopup(this.parentElement.parentElement)">
                            Verstanden
                        </button>
                    </div>
                `;
                
                // Allow closing by clicking background
                overlay.addEventListener('click', (e) => {
                    if (e.target === overlay) {
                        overlay.remove();
                    }
                });
                
                document.body.appendChild(overlay);
            } catch (error) {
                console.error('Error showing admin popup:', error);
            }
        }

        function closeAdminPopup(overlay) {
            try {
                if (overlay && overlay.parentElement) {
                    overlay.remove();
                }
            } catch (error) {
                console.error('Error closing admin popup:', error);
            }
        }

        function saveStationChanges(stationId) {
            try {
                const station = tourApp.stations.find(s => s.id === stationId);
                if (!station) return;
                
                station.title = document.getElementById(`edit-title-${stationId}`).value;
                station.subtitle = document.getElementById(`edit-subtitle-${stationId}`).value;
                station.mainText = document.getElementById(`edit-maintext-${stationId}`).value;
                station.photoChallenge = document.getElementById(`edit-challenge-${stationId}`).value;
                station.lat = parseFloat(document.getElementById(`edit-lat-${stationId}`).value);
                station.lng = parseFloat(document.getElementById(`edit-lng-${stationId}`).value);
                
                if (tourApp.state.isFirebaseConnected) {
                    saveToFirebase('stations', stationId.toString(), station);
                }
                
                generateStationsList();
                
                if (tourApp.state.map) {
                    updateMapMarkers();
                }
                
                showNotification(`Station ${stationId} gespeichert! ‚úÖ`);
                addSystemMessage(`Admin hat Station "${station.title}" aktualisiert! üìù`);
                
                saveState();
            } catch (error) {
                console.error('Error saving station changes:', error);
                showNotification('Fehler beim Speichern der √Ñnderungen', 'error');
            }
        }

        function resetStationEditor(stationId) {
            try {
                const station = tourApp.stations.find(s => s.id === stationId);
                if (!station) return;
                
                document.getElementById(`edit-title-${stationId}`).value = station.title;
                document.getElementById(`edit-subtitle-${stationId}`).value = station.subtitle;
                document.getElementById(`edit-maintext-${stationId}`).value = station.mainText;
                document.getElementById(`edit-challenge-${stationId}`).value = station.photoChallenge;
                document.getElementById(`edit-lat-${stationId}`).value = station.lat;
                document.getElementById(`edit-lng-${stationId}`).value = station.lng;
                
                showNotification('Editor zur√ºckgesetzt! üîÑ');
            } catch (error) {
                console.error('Error resetting station editor:', error);
            }
        }

        // Image Management Functions - RESTORED!
        function generateImageEditor(station) {
            try {
                if (!station.images || station.images.length === 0) {
                    return `
                        <p style="color: #6b7280; text-align: center; padding: 2rem;">
                            üì∑ Noch keine Bilder vorhanden<br>
                            <small>Nutze die Buttons unten um Bilder hinzuzuf√ºgen</small>
                        </p>
                        <div style="display: flex; gap: 0.5rem; justify-content: center; margin-top: 1rem;">
                            <button class="btn btn-secondary btn-small" onclick="showMediaSearchHelper(${station.id}, 'image')">üîç Bilder suchen</button>
                        </div>
                    `;
                }
                
                return station.images.map((image, index) => `
                    <div style="border: 1px solid #d1d5db; border-radius: 6px; padding: 1rem; margin-bottom: 1rem; background: white;" id="image-item-${station.id}-${index}">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                            <strong style="color: #374151;">üì∑ Bild ${index + 1}</strong>
                            <div style="display: flex; gap: 0.5rem;">
                                <button onclick="showMediaSearchHelper(${station.id}, 'image', ${index})" style="background: #059669; color: white; border: none; padding: 0.25rem 0.5rem; border-radius: 4px; cursor: pointer; font-size: 0.8rem;">üîç</button>
                                <button onclick="removeImage(${station.id}, ${index})" style="background: #dc2626; color: white; border: none; padding: 0.25rem 0.5rem; border-radius: 4px; cursor: pointer; font-size: 0.8rem;">üóëÔ∏è</button>
                            </div>
                        </div>
                        
                        <div style="margin-bottom: 0.5rem;">
                            <label style="display: block; font-size: 0.9rem; font-weight: bold; margin-bottom: 0.25rem;">Titel:</label>
                            <input type="text" value="${image.title || ''}" onchange="updateImageData(${station.id}, ${index}, 'title', this.value)" style="width: 100%; padding: 0.5rem; border: 1px solid #d1d5db; border-radius: 4px; font-size: 0.9rem;">
                        </div>
                        
                        <div style="margin-bottom: 0.5rem;">
                            <label style="display: block; font-size: 0.9rem; font-weight: bold; margin-bottom: 0.25rem;">Beschreibung:</label>
                            <input type="text" value="${image.description || ''}" onchange="updateImageData(${station.id}, ${index}, 'description', this.value)" style="width: 100%; padding: 0.5rem; border: 1px solid #d1d5db; border-radius: 4px; font-size: 0.9rem;">
                        </div>
                        
                        <div style="margin-bottom: 0.5rem;">
                            <label style="display: block; font-size: 0.9rem; font-weight: bold; margin-bottom: 0.25rem;">Bild-URL:</label>
                            <input type="url" value="${image.url || ''}" onchange="updateImageData(${station.id}, ${index}, 'url', this.value)" placeholder="https://example.com/image.jpg" style="width: 100%; padding: 0.5rem; border: 1px solid #d1d5db; border-radius: 4px; font-size: 0.9rem;">
                        </div>
                        
                        <div style="margin-bottom: 0.5rem;">
                            <label style="display: block; font-size: 0.9rem; font-weight: bold; margin-bottom: 0.25rem;">Oder Bild hochladen:</label>
                            <input type="file" accept="image/*" onchange="uploadImageFile(${station.id}, ${index}, this)" style="width: 100%; padding: 0.5rem; border: 1px solid #d1d5db; border-radius: 4px; font-size: 0.9rem;">
                        </div>
                        
                        ${image.url ? `
                            <div style="margin-top: 0.5rem;">
                                <img src="${image.url}" alt="${image.title}" style="max-width: 150px; max-height: 100px; border-radius: 4px; object-fit: cover;">
                            </div>
                        ` : ''}
                    </div>
                `).join('') + `
                    <div style="display: flex; gap: 0.5rem; justify-content: center; margin-top: 1rem;">
                        <button class="btn btn-secondary btn-small" onclick="showMediaSearchHelper(${station.id}, 'image')">üîç Weitere Bilder suchen</button>
                    </div>
                `;
            } catch (error) {
                console.error('Error generating image editor:', error);
                return '<p style="color: #dc2626;">Fehler beim Laden des Bild-Editors</p>';
            }
        }

        function addNewImage(stationId) {
            try {
                const station = tourApp.stations.find(s => s.id === stationId);
                if (!station) return;
                
                if (!station.images) {
                    station.images = [];
                }
                
                station.images.push({
                    title: `Neues Bild ${station.images.length + 1}`,
                    description: "Beschreibung des Bildes",
                    url: ""
                });
                
                // Regenerate image editor
                const editorContainer = document.getElementById(`image-editor-${stationId}`);
                if (editorContainer) {
                    editorContainer.innerHTML = generateImageEditor(station);
                }
                
                showNotification('Neues Bild hinzugef√ºgt! üì∑');
            } catch (error) {
                console.error('Error adding new image:', error);
            }
        }

        function removeImage(stationId, imageIndex) {
            try {
                if (!confirm('Dieses Bild wirklich l√∂schen?')) return;
                
                const station = tourApp.stations.find(s => s.id === stationId);
                if (!station || !station.images) return;
                
                station.images.splice(imageIndex, 1);
                
                // Regenerate image editor
                const editorContainer = document.getElementById(`image-editor-${stationId}`);
                if (editorContainer) {
                    editorContainer.innerHTML = generateImageEditor(station);
                }
                
                showNotification('Bild gel√∂scht! üóëÔ∏è');
            } catch (error) {
                console.error('Error removing image:', error);
            }
        }

        function updateImageData(stationId, imageIndex, field, value) {
            try {
                const station = tourApp.stations.find(s => s.id === stationId);
                if (!station || !station.images || !station.images[imageIndex]) return;
                
                station.images[imageIndex][field] = value;
                
                // If URL was updated, refresh the preview
                if (field === 'url') {
                    setTimeout(() => {
                        const editorContainer = document.getElementById(`image-editor-${stationId}`);
                        if (editorContainer) {
                            editorContainer.innerHTML = generateImageEditor(station);
                        }
                    }, 100);
                }
            } catch (error) {
                console.error('Error updating image data:', error);
            }
        }

        function uploadImageFile(stationId, imageIndex, fileInput) {
            try {
                const file = fileInput.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    const dataUrl = e.target.result;
                    updateImageData(stationId, imageIndex, 'url', dataUrl);
                    showNotification('Bild hochgeladen! üì∑');
                };
                reader.readAsDataURL(file);
            } catch (error) {
                console.error('Error uploading image file:', error);
                showNotification('Fehler beim Hochladen des Bildes', 'error');
            }
        }

        // Audio Management Functions - RESTORED!
        function generateAudioEditor(station) {
            try {
                if (!station.audio || station.audio.length === 0) {
                    return `
                        <p style="color: #6b7280; text-align: center; padding: 2rem;">
                            üéµ Noch keine Audio-Dateien vorhanden<br>
                            <small>Nutze die Buttons unten um Audio-Dateien hinzuzuf√ºgen</small>
                        </p>
                        <div style="display: flex; gap: 0.5rem; justify-content: center; margin-top: 1rem; flex-wrap: wrap;">
                            <button class="btn btn-secondary btn-small" onclick="showMediaSearchHelper(${station.id}, 'youtube')">üì∫ YouTube</button>
                            <button class="btn btn-secondary btn-small" onclick="showMediaSearchHelper(${station.id}, 'soundcloud')">‚òÅÔ∏è SoundCloud</button>
                        </div>
                    `;
                }
                
                return station.audio.map((audio, index) => `
                    <div style="border: 1px solid #d1d5db; border-radius: 6px; padding: 1rem; margin-bottom: 1rem; background: white;" id="audio-item-${station.id}-${index}">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                            <strong style="color: #374151;">üéµ Audio ${index + 1}</strong>
                            <div style="display: flex; gap: 0.5rem;">
                                <button onclick="showMediaSearchHelper(${station.id}, '${audio.type || 'youtube'}', ${index})" style="background: #059669; color: white; border: none; padding: 0.25rem 0.5rem; border-radius: 4px; cursor: pointer; font-size: 0.8rem;">üîç</button>
                                <button onclick="removeAudio(${station.id}, ${index})" style="background: #dc2626; color: white; border: none; padding: 0.25rem 0.5rem; border-radius: 4px; cursor: pointer; font-size: 0.8rem;">üóëÔ∏è</button>
                            </div>
                        </div>
                        
                        <div style="margin-bottom: 0.5rem;">
                            <label style="display: block; font-size: 0.9rem; font-weight: bold; margin-bottom: 0.25rem;">Titel:</label>
                            <input type="text" value="${audio.title || ''}" onchange="updateAudioData(${station.id}, ${index}, 'title', this.value)" style="width: 100%; padding: 0.5rem; border: 1px solid #d1d5db; border-radius: 4px; font-size: 0.9rem;">
                        </div>
                        
                        <div style="margin-bottom: 0.5rem;">
                            <label style="display: block; font-size: 0.9rem; font-weight: bold; margin-bottom: 0.25rem;">Beschreibung:</label>
                            <input type="text" value="${audio.description || ''}" onchange="updateAudioData(${station.id}, ${index}, 'description', this.value)" style="width: 100%; padding: 0.5rem; border: 1px solid #d1d5db; border-radius: 4px; font-size: 0.9rem;">
                        </div>
                        
                        <div style="margin-bottom: 0.5rem;">
                            <label style="display: block; font-size: 0.9rem; font-weight: bold; margin-bottom: 0.25rem;">Audio-Typ:</label>
                            <select onchange="updateAudioData(${station.id}, ${index}, 'type', this.value)" style="width: 100%; padding: 0.5rem; border: 1px solid #d1d5db; border-radius: 4px; font-size: 0.9rem;">
                                <option value="youtube" ${audio.type === 'youtube' ? 'selected' : ''}>üì∫ YouTube</option>
                                <option value="soundcloud" ${audio.type === 'soundcloud' ? 'selected' : ''}>‚òÅÔ∏è SoundCloud</option>
                                <option value="spotify" ${audio.type === 'spotify' ? 'selected' : ''}>üü¢ Spotify</option>
                                <option value="audio" ${audio.type === 'audio' ? 'selected' : ''}>üéµ Audio-URL</option>
                                <option value="podcast" ${audio.type === 'podcast' ? 'selected' : ''}>üéôÔ∏è Podcast</option>
                            </select>
                        </div>
                        
                        <div style="margin-bottom: 0.5rem;">
                            <label style="display: block; font-size: 0.9rem; font-weight: bold; margin-bottom: 0.25rem;">
                                ${audio.type === 'youtube' ? 'YouTube-URL:' :
                                  audio.type === 'soundcloud' ? 'SoundCloud-URL:' :
                                  audio.type === 'spotify' ? 'Spotify-URL:' :
                                  audio.type === 'podcast' ? 'Podcast-URL:' : 'Audio-URL:'}
                            </label>
                            <input type="url" value="${audio.url || ''}" onchange="updateAudioData(${station.id}, ${index}, 'url', this.value)" 
                                   placeholder="${audio.type === 'youtube' ? 'https://www.youtube.com/watch?v=...' :
                                                audio.type === 'soundcloud' ? 'https://soundcloud.com/user/track-name' :
                                                audio.type === 'spotify' ? 'https://open.spotify.com/track/...' :
                                                audio.type === 'podcast' ? 'https://example.com/podcast.mp3' : 'https://example.com/audio.mp3'}" 
                                   style="width: 100%; padding: 0.5rem; border: 1px solid #d1d5db; border-radius: 4px; font-size: 0.9rem;">
                        </div>
                        
                        ${audio.url ? `
                            <div style="margin-top: 0.5rem;">
                                <button onclick="previewAudio('${audio.url}', '${audio.type}', '${audio.title}')" style="background: #059669; color: white; border: none; padding: 0.5rem 1rem; border-radius: 4px; cursor: pointer; font-size: 0.8rem;">
                                    ‚ñ∂Ô∏è Vorschau
                                </button>
                            </div>
                        ` : ''}
                        
                        ${audio.url ? `
                            <div style="margin-top: 0.5rem; font-size: 0.8rem; color: #059669;">
                                ‚úÖ ${audio.type.charAt(0).toUpperCase() + audio.type.slice(1)}-Link gesetzt
                            </div>
                        ` : ''}
                    </div>
                `).join('') + `
                    <div style="display: flex; gap: 0.5rem; justify-content: center; margin-top: 1rem; flex-wrap: wrap;">
                        <button class="btn btn-secondary btn-small" onclick="showMediaSearchHelper(${station.id}, 'youtube')">üì∫ YouTube</button>
                        <button class="btn btn-secondary btn-small" onclick="showMediaSearchHelper(${station.id}, 'soundcloud')">‚òÅÔ∏è SoundCloud</button>
                    </div>
                `;
            } catch (error) {
                console.error('Error generating audio editor:', error);
                return '<p style="color: #dc2626;">Fehler beim Laden des Audio-Editors</p>';
            }
        }

        function addNewAudio(stationId) {
            try {
                const station = tourApp.stations.find(s => s.id === stationId);
                if (!station) return;
                
                if (!station.audio) {
                    station.audio = [];
                }
                
                station.audio.push({
                    title: `Neue Audio-Datei ${station.audio.length + 1}`,
                    description: "Beschreibung der Audio-Datei",
                    url: "",
                    type: "youtube"
                });
                
                // Regenerate audio editor
                const editorContainer = document.getElementById(`audio-editor-${stationId}`);
                if (editorContainer) {
                    editorContainer.innerHTML = generateAudioEditor(station);
                }
                
                showNotification('Neue Audio-Datei hinzugef√ºgt! üéµ');
            } catch (error) {
                console.error('Error adding new audio:', error);
            }
        }

        function removeAudio(stationId, audioIndex) {
            try {
                if (!confirm('Diese Audio-Datei wirklich l√∂schen?')) return;
                
                const station = tourApp.stations.find(s => s.id === stationId);
                if (!station || !station.audio) return;
                
                station.audio.splice(audioIndex, 1);
                
                // Regenerate audio editor
                const editorContainer = document.getElementById(`audio-editor-${stationId}`);
                if (editorContainer) {
                    editorContainer.innerHTML = generateAudioEditor(station);
                }
                
                showNotification('Audio-Datei gel√∂scht! üóëÔ∏è');
            } catch (error) {
                console.error('Error removing audio:', error);
            }
        }

        function updateAudioData(stationId, audioIndex, field, value) {
            try {
                const station = tourApp.stations.find(s => s.id === stationId);
                if (!station || !station.audio || !station.audio[audioIndex]) return;
                
                station.audio[audioIndex][field] = value;
                
                // If type was updated, refresh the editor to show different input fields
                if (field === 'type' || field === 'url') {
                    setTimeout(() => {
                        const editorContainer = document.getElementById(`audio-editor-${stationId}`);
                        if (editorContainer) {
                            editorContainer.innerHTML = generateAudioEditor(station);
                        }
                    }, 100);
                }
            } catch (error) {
                console.error('Error updating audio data:', error);
            }
        }

        // Preview function for admin
        function previewAudio(url, type, title) {
            playAudio(url, type, title);
        }

        function deleteStation(stationId) {
            try {
                if (confirm(`Station ${stationId} wirklich l√∂schen? Diese Aktion kann nicht r√ºckg√§ngig gemacht werden.`)) {
                    const stationIndex = tourApp.stations.findIndex(s => s.id === stationId);
                    if (stationIndex > -1) {
                        const station = tourApp.stations[stationIndex];
                        tourApp.stations.splice(stationIndex, 1);
                        
                        tourApp.state.completedStations = tourApp.state.completedStations.filter(id => id !== stationId);
                        
                        if (tourApp.state.isFirebaseConnected) {
                            db.collection('tours').doc(tourApp.state.tourId)
                                .collection('stations').doc(stationId.toString()).delete();
                        }
                        
                        generateContentEditor();
                        generateStationsList();
                        updateProgress();
                        
                        if (tourApp.state.map) {
                            updateMapMarkers();
                        }
                        
                        showNotification(`Station "${station.title}" gel√∂scht! üóëÔ∏è`);
                        addSystemMessage(`Admin hat Station "${station.title}" entfernt! üóëÔ∏è`);
                        saveState();
                    }
                }
            } catch (error) {
                console.error('Error deleting station:', error);
            }
        }

        function addNewStation() {
            try {
                const newId = Math.max(...tourApp.stations.map(s => s.id)) + 1;
                const newStation = {
                    id: newId,
                    title: `Neue Station ${newId}`,
                    subtitle: "Beschreibung der neuen Station",
                    lat: 50.9375, lng: 6.9597,
                    description: `Station ${newId} der Tour`,
                    photoChallenge: "Macht ein kreatives Foto an dieser Station!",
                    mainText: "Hier kommt der Haupttext der neuen Station. Erz√§hle die Geschichte dieses Ortes...",
                    images: [
                        { title: "Bild 1", description: "Beschreibung des ersten Bildes", url: "" }
                    ],
                    audio: [
                        { title: "Audio 1", description: "Beschreibung der ersten Audio-Datei", url: "", type: "youtube" }
                    ]
                };
                
                tourApp.stations.push(newStation);
                tourApp.stations.sort((a, b) => a.id - b.id);
                
                if (tourApp.state.isFirebaseConnected) {
                    saveToFirebase('stations', newId.toString(), newStation);
                }
                
                generateContentEditor();
                generateStationsList();
                
                if (tourApp.state.map) {
                    updateMapMarkers();
                }
                
                showNotification(`Neue Station ${newId} hinzugef√ºgt! ‚ûï`);
                addSystemMessage(`Admin hat neue Station "${newStation.title}" hinzugef√ºgt! ‚ûï`);
                saveState();
            } catch (error) {
                console.error('Error adding new station:', error);
            }
        }

        function updateMapMarkers() {
            try {
                if (!tourApp.state.map) return;
                
                tourApp.state.markers.forEach(marker => {
                    tourApp.state.map.removeLayer(marker);
                });
                tourApp.state.markers = [];
                
                tourApp.stations.forEach(station => {
                    const isCompleted = tourApp.state.completedStations.includes(station.id);
                    const marker = L.marker([station.lat, station.lng])
                        .bindPopup(`
                            <div style="text-align: center; max-width: 200px;">
                                <h4>${station.title}</h4>
                                <p>${station.subtitle}</p>
                                <p><strong>Station ${station.id}/${tourApp.stations.length}</strong></p>
                                ${isCompleted ? '<p style="color: green;">‚úÖ Abgeschlossen</p>' : '<p style="color: orange;">‚è≥ Ausstehend</p>'}
                            </div>
                        `)
                        .addTo(tourApp.state.map);
                    
                    tourApp.state.markers.push(marker);
                });
                
                const routeCoordinates = tourApp.stations.map(station => [station.lat, station.lng]);
                L.polyline(routeCoordinates, {
                    color: '#dc2626',
                    weight: 3,
                    opacity: 0.7
                }).addTo(tourApp.state.map);
            } catch (error) {
                console.error('Error updating map markers:', error);
            }
        }

        function refreshAdminStats() {
            try {
                const stats = {
                    activeUsers: Object.keys(localStorage).filter(key => key.startsWith('user_')).length + 1,
                    totalMessages: document.querySelectorAll('.chat-message:not(.system)').length,
                    completedStations: tourApp.state.completedStations.length,
                    uploadedPhotos: tourApp.state.uploadedPhotos.length
                };
                
                document.getElementById('activeUsers').textContent = stats.activeUsers;
                document.getElementById('totalMessages').textContent = stats.totalMessages;
                document.getElementById('completedStations').textContent = `${stats.completedStations}/${tourApp.stations.length}`;
                document.getElementById('uploadedPhotos').textContent = stats.uploadedPhotos;
                
                showNotification('Statistiken aktualisiert! üìä');
            } catch (error) {
                console.error('Error refreshing admin stats:', error);
            }
        }

        async function addScore(points) {
            try {
                tourApp.state.totalScore += Math.round(points);
                updateUI();
                
                if (tourApp.state.selectedTeam) {
                    await saveToFirebase('scores', tourApp.state.selectedTeam, {
                        teamId: tourApp.state.selectedTeam,
                        teamName: tourApp.state.teamName,
                        score: tourApp.state.totalScore,
                        lastUpdated: Date.now(),
                        userName: tourApp.state.userName
                    });
                }
                
                saveState();
            } catch (error) {
                console.error('Error adding score:', error);
            }
        }

        function generateStationsList() {
            try {
                const container = document.getElementById('stationsList');
                if (!container) return;
                
                container.innerHTML = '';
                
                tourApp.stations.forEach(station => {
                    const isCompleted = tourApp.state.completedStations.includes(station.id);
                    
                    const stationCard = document.createElement('div');
                    stationCard.className = `station-card ${isCompleted ? 'completed' : ''}`;
                    stationCard.onclick = () => toggleStationDetails(station.id);
                    
                    const imagesHtml = station.images.map(img => `
                        <div class="gallery-item">
                            <div class="gallery-image" onclick="openImageModal(event, '${img.url || 'placeholder'}', '${img.title}', '${img.description}')" 
                                 style="${img.url ? `background-image: url('${img.url}'); background-size: cover; background-position: center;` : ''}">
                                ${img.url ? '' : 'üì∑'}
                            </div>
                            <small>${img.title}</small>
                        </div>
                    `).join('');
                    
                    const audioHtml = station.audio && station.audio.length > 0 ? station.audio.map(audio => {
                        const typeIcons = {
                            'youtube': 'üì∫',
                            'soundcloud': '‚òÅÔ∏è', 
                            'spotify': 'üü¢',
                            'audio': 'üéµ',
                            'podcast': 'üéôÔ∏è'
                        };
                        const typeColors = {
                            'youtube': 'linear-gradient(135deg, #ff0000 0%, #cc0000 100%)',
                            'soundcloud': 'linear-gradient(135deg, #ff5500 0%, #ff3300 100%)',
                            'spotify': 'linear-gradient(135deg, #1db954 0%, #1ed760 100%)',
                            'audio': 'linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%)',
                            'podcast': 'linear-gradient(135deg, #f59e0b 0%, #d97706 100%)'
                        };
                        return `
                            <div class="gallery-item">
                                <div class="gallery-image" onclick="openAudioModal(event, '${audio.url}', '${audio.type}', '${audio.title}')"
                                     style="background: ${typeColors[audio.type] || typeColors.audio}; color: white; font-size: 1.8rem; cursor: pointer; transition: all 0.3s; display: flex; align-items: center; justify-content: center;"
                                     onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 8px 25px rgba(0,0,0,0.2)'"
                                     onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='0 2px 8px rgba(0,0,0,0.1)'">
                                    ${typeIcons[audio.type] || 'üéµ'}
                                </div>
                                <small>${audio.title}</small>
                            </div>
                        `;
                    }).join('') : '';
                    
                    stationCard.innerHTML = `
                        <div class="station-header">
                            <div class="station-number ${isCompleted ? 'completed' : ''}">${station.id}</div>
                            <div style="flex: 1;">
                                <div class="station-title">${station.title}</div>
                                <div class="station-subtitle">${station.subtitle}</div>
                            </div>
                        </div>
                        <div class="station-details" id="station-${station.id}">
                            <div class="detail-section">
                                <h4>üó∫Ô∏è Standort</h4>
                                <div class="station-map" id="station-map-${station.id}" style="height: 200px; width: 100%; border-radius: 8px; margin: 0.5rem 0; box-shadow: 0 2px 8px rgba(0,0,0,0.1);"></div>
                                <p style="font-size: 0.9rem; color: #6b7280;">üìç ${station.lat.toFixed(6)}, ${station.lng.toFixed(6)}</p>
                                <button class="btn btn-secondary btn-small" onclick="event.stopPropagation(); centerStationMap(${station.id})" style="margin-top: 0.5rem;">
                                    üéØ Zur Station navigieren
                                </button>
                            </div>

                            <div class="detail-section">
                                <h4>üìñ Geschichte</h4>
                                <p>${station.mainText}</p>
                            </div>
                            
                            <div class="detail-section">
                                <h4>üñºÔ∏è Bildergalerie</h4>
                                <div class="image-gallery">
                                    ${imagesHtml}
                                </div>
                            </div>
                            
                            ${audioHtml ? `
                            <div class="detail-section">
                                <h4>üéµ Audio-Dateien</h4>
                                <div class="image-gallery">
                                    ${audioHtml}
                                </div>
                            </div>
                            ` : ''}

                            <div class="photo-challenge">
                                <h4>üì∏ KI-Foto-Challenge</h4>
                                <button class="btn btn-secondary btn-small" onclick="showStationGallery(${station.id})" style="float: right; margin-top: -0.5rem;">üñºÔ∏è Galerie anzeigen</button>
                                <p>${station.photoChallenge}</p>
                                
                                <div class="photo-upload-area" onclick="event.stopPropagation(); selectPhoto(${station.id})" id="upload-area-${station.id}">
                                    <div id="upload-content-${station.id}">
                                        üì∑ Hier klicken zum Foto machen/ausw√§hlen<br>
                                        <small>KI bewertet automatisch Qualit√§t, Komposition & Kreativit√§t</small>
                                    </div>
                                </div>
                                
                                <input type="file" class="file-input" id="photo-input-${station.id}" accept="image/*" capture="environment" onchange="handlePhotoUpload(${station.id}, event)">
                                
                                <div class="ai-rating hidden" id="rating-${station.id}">
                                    <div class="rating-score" id="score-${station.id}">0</div>
                                    <div class="rating-text" id="rating-text-${station.id}">KI analysiert dein Foto...</div>
                                    <div class="rating-details" id="rating-details-${station.id}"></div>
                                    
                                    <!-- Share Challenge Photo Button -->
                                    <div id="share-photo-section-${station.id}" class="hidden" style="margin-top: 1rem; padding-top: 1rem; border-top: 2px solid #e5e7eb;">
                                        <button class="btn btn-secondary" onclick="shareChallengePhoto(${station.id})" style="background: #059669; margin-top: 0.5rem;">
                                            üì§ Foto im Chat teilen
                                        </button>
                                        <p style="font-size: 0.8rem; color: #6b7280; margin-top: 0.5rem;">
                                            üí° Teile dein Challenge-Foto mit allen Teilnehmern!
                                        </p>
                                    </div>
                                </div>
                            </div>

                            <button class="btn" onclick="event.stopPropagation(); completeStation(${station.id})" id="complete-btn-${station.id}" 
                                    ${isCompleted ? 'disabled' : ''}>
                                ${isCompleted ? '‚úÖ Station abgeschlossen' : 'üèÅ Station abschlie√üen'}
                            </button>
                        </div>
                    `;
                    
                    container.appendChild(stationCard);
                });
            } catch (error) {
                console.error('Error generating stations list:', error);
            }
        }

        // Event handling functions for media modals
        function openImageModal(event, url, title, description) {
            event.stopPropagation();
            showImageModal(url, title, description);
        }

        function openAudioModal(event, url, type, title) {
            event.stopPropagation();
            playAudio(url, type, title);
        }

        function toggleStationDetails(stationId) {
            try {
                const details = document.getElementById(`station-${stationId}`);
                if (details) {
                    const wasActive = details.classList.contains('active');
                    details.classList.toggle('active');
                    
                    // Initialize station map when details are opened
                    if (!wasActive && details.classList.contains('active')) {
                        setTimeout(() => initStationMap(stationId), 100);
                    }
                }
            } catch (error) {
                console.error('Error toggling station details:', error);
            }
        }

        function initStationMap(stationId) {
            try {
                const station = tourApp.stations.find(s => s.id === stationId);
                if (!station) return;

                const mapContainer = document.getElementById(`station-map-${stationId}`);
                if (!mapContainer) return;

                // Warte auf Leaflet falls noch nicht geladen
                if (typeof L === 'undefined') {
                    setTimeout(() => initStationMap(stationId), 500);
                    return;
                }

                // Pr√ºfe ob Karte bereits existiert
                if (tourApp.state.stationMaps && tourApp.state.stationMaps[stationId]) {
                    return;
                }

                // Initialisiere Karte
                const stationMap = L.map(`station-map-${stationId}`, {
                    center: [station.lat, station.lng],
                    zoom: 17,
                    scrollWheelZoom: false,
                    zoomControl: true
                });

                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '¬© OpenStreetMap',
                    maxZoom: 19
                }).addTo(stationMap);

                // Station Marker
                const stationMarker = L.marker([station.lat, station.lng])
                    .bindPopup(`
                        <div style="text-align: center; min-width: 150px;">
                            <h4>${station.title}</h4>
                            <p>${station.subtitle}</p>
                            <p><strong>Station ${station.id}</strong></p>
                        </div>
                    `)
                    .addTo(stationMap);

                // User-Position falls verf√ºgbar
                if (tourApp.state.userLocation) {
                    const userIcon = L.divIcon({
                        html: '<div style="background: #3b82f6; width: 12px; height: 12px; border-radius: 50%; border: 2px solid white; box-shadow: 0 1px 3px rgba(0,0,0,0.3);"></div>',
                        className: 'user-location-mini',
                        iconSize: [12, 12],
                        iconAnchor: [6, 6]
                    });
                    
                    L.marker([tourApp.state.userLocation.lat, tourApp.state.userLocation.lng], {
                        icon: userIcon
                    })
                    .bindPopup('üìç Dein Standort')
                    .addTo(stationMap);

                    // Linie zwischen User und Station
                    L.polyline([
                        [tourApp.state.userLocation.lat, tourApp.state.userLocation.lng],
                        [station.lat, station.lng]
                    ], {
                        color: '#dc2626',
                        weight: 2,
                        opacity: 0.7,
                        dashArray: '5, 5'
                    }).addTo(stationMap);

                    // Distanz berechnen und anzeigen
                    const distance = calculateDistance(
                        tourApp.state.userLocation.lat, tourApp.state.userLocation.lng,
                        station.lat, station.lng
                    );
                    
                    const distanceText = distance < 1 
                        ? `${Math.round(distance * 1000)}m entfernt` 
                        : `${distance.toFixed(1)}km entfernt`;
                    
                    const distanceInfo = mapContainer.parentElement.querySelector('p');
                    if (distanceInfo) {
                        distanceInfo.innerHTML = `üìç ${station.lat.toFixed(6)}, ${station.lng.toFixed(6)} - ${distanceText}`;
                    }

                    // Karte so zoomen, dass beide Punkte sichtbar sind
                    const bounds = L.latLngBounds([
                        [tourApp.state.userLocation.lat, tourApp.state.userLocation.lng],
                        [station.lat, station.lng]
                    ]);
                    stationMap.fitBounds(bounds, { padding: [20, 20] });
                }

                // Karte speichern
                if (!tourApp.state.stationMaps) {
                    tourApp.state.stationMaps = {};
                }
                tourApp.state.stationMaps[stationId] = stationMap;

                // Popup nach kurzer Verz√∂gerung √∂ffnen
                setTimeout(() => {
                    stationMarker.openPopup();
                }, 300);

                // Karte nach DOM-Update aktualisieren
                setTimeout(() => {
                    stationMap.invalidateSize();
                }, 100);

            } catch (error) {
                console.error('Error initializing station map:', error);
                // Fallback: Karte ausblenden bei Fehlern
                const mapContainer = document.getElementById(`station-map-${stationId}`);
                if (mapContainer) {
                    mapContainer.innerHTML = '<div style="background: #f3f4f6; height: 100%; display: flex; align-items: center; justify-content: center; border-radius: 8px; color: #6b7280;">üó∫Ô∏è Karte nicht verf√ºgbar</div>';
                }
            }
        }

        function centerStationMap(stationId) {
            try {
                const station = tourApp.stations.find(s => s.id === stationId);
                if (!station) return;

                // If user has location, open navigation
                if (tourApp.state.userLocation) {
                    const navigationUrl = `https://www.google.com/maps/dir/${tourApp.state.userLocation.lat},${tourApp.state.userLocation.lng}/${station.lat},${station.lng}`;
                    window.open(navigationUrl, '_blank');
                    showNotification('Navigation in Google Maps ge√∂ffnet! üó∫Ô∏è');
                } else {
                    // Just show the location in Google Maps
                    const locationUrl = `https://www.google.com/maps/search/?api=1&query=${station.lat},${station.lng}`;
                    window.open(locationUrl, '_blank');
                    showNotification('Station in Google Maps ge√∂ffnet! üìç');
                }
            } catch (error) {
                console.error('Error centering station map:', error);
                showNotification('Fehler beim √ñffnen der Navigation', 'error');
            }
        }

        function selectPhoto(stationId) {
            try {
                const input = document.getElementById(`photo-input-${stationId}`);
                if (input) {
                    input.click();
                }
            } catch (error) {
                console.error('Error selecting photo:', error);
            }
        }

        function handlePhotoUpload(stationId, event) {
            try {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    const imageUrl = e.target.result;
                    
                    const uploadArea = document.getElementById(`upload-area-${stationId}`);
                    if (uploadArea) {
                        uploadArea.classList.add('has-photo');
                        uploadArea.innerHTML = `
                            <img src="${imageUrl}" class="photo-preview" alt="Uploaded photo">
                            <p>üì∑ Foto erfolgreich hochgeladen!</p>
                            <small>KI analysiert...</small>
                        `;
                    }

                    const photoData = {
                        stationId: stationId,
                        imageUrl: imageUrl,
                        timestamp: Date.now(),
                        teamId: tourApp.state.selectedTeam
                    };

                    const existingIndex = tourApp.state.uploadedPhotos.findIndex(p => p.stationId === stationId);
                    if (existingIndex >= 0) {
                        tourApp.state.uploadedPhotos[existingIndex] = photoData;
                    } else {
                        tourApp.state.uploadedPhotos.push(photoData);
                    }

                    setTimeout(() => ratePhoto(stationId, imageUrl), 1000);
                    saveState();
                };
                
                reader.readAsDataURL(file);
            } catch (error) {
                console.error('Error handling photo upload:', error);
            }
        }

        // Enhanced photo handling with automatic saving
        function handlePhotoUpload(stationId, event) {
            try {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    const imageUrl = e.target.result;
                    
                    // Automatically save photo to device
                    savePhotoToDevice(imageUrl, stationId).then(() => {
                        console.log('‚úÖ Photo automatically saved to device');
                    }).catch(error => {
                        console.log('üì± Auto-save not supported on this device:', error.message);
                    });
                    
                    const uploadArea = document.getElementById(`upload-area-${stationId}`);
                    if (uploadArea) {
                        uploadArea.classList.add('has-photo');
                        uploadArea.innerHTML = `
                            <img src="${imageUrl}" class="photo-preview" alt="Uploaded photo">
                            <p>üì∑ Foto erfolgreich hochgeladen!</p>
                            <small>KI analysiert... (Foto wird automatisch gespeichert)</small>
                        `;
                    }

                    const photoData = {
                        stationId: stationId,
                        imageUrl: imageUrl,
                        timestamp: Date.now(),
                        teamId: tourApp.state.selectedTeam,
                        fileName: generatePhotoFileName(stationId),
                        autoSaved: true
                    };

                    const existingIndex = tourApp.state.uploadedPhotos.findIndex(p => p.stationId === stationId);
                    if (existingIndex >= 0) {
                        tourApp.state.uploadedPhotos[existingIndex] = photoData;
                    } else {
                        tourApp.state.uploadedPhotos.push(photoData);
                    }

                    setTimeout(() => ratePhoto(stationId, imageUrl), 1000);
                    saveState();
                };
                
                reader.readAsDataURL(file);
            } catch (error) {
                console.error('Error handling photo upload:', error);
            }
        }

        // Function to automatically save photo to device
        async function savePhotoToDevice(imageDataUrl, stationId) {
            try {
                const station = tourApp.stations.find(s => s.id === stationId);
                const stationName = station ? station.title.replace(/[^a-zA-Z0-9]/g, '_') : `Station_${stationId}`;
                const timestamp = new Date().toISOString().slice(0, 19).replace(/[:-]/g, '');
                const fileName = `Koeln_Tour_${stationName}_${timestamp}.jpg`;
                
                // Method 1: Modern browsers with File System Access API
                if ('showSaveFilePicker' in window) {
                    try {
                        const fileHandle = await window.showSaveFilePicker({
                            suggestedName: fileName,
                            types: [{
                                description: 'JPEG Images',
                                accept: { 'image/jpeg': ['.jpg', '.jpeg'] }
                            }]
                        });
                        
                        const blob = dataURLToBlob(imageDataUrl);
                        const writable = await fileHandle.createWritable();
                        await writable.write(blob);
                        await writable.close();
                        
                        showNotification(`üì± Foto als "${fileName}" gespeichert!`, 'success');
                        return true;
                    } catch (fsError) {
                        if (fsError.name !== 'AbortError') {
                            console.log('File System Access API failed:', fsError);
                        }
                        // Fall through to Method 2
                    }
                }
                
                // Method 2: Download link (works on all browsers)
                const link = document.createElement('a');
                link.href = imageDataUrl;
                link.download = fileName;
                link.style.display = 'none';
                
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                showNotification(`üíæ Foto wird heruntergeladen: "${fileName}"`, 'success');
                
                // Method 3: For mobile devices - attempt to trigger native save
                if (navigator.share && navigator.canShare) {
                    try {
                        const blob = dataURLToBlob(imageDataUrl);
                        const file = new File([blob], fileName, { type: 'image/jpeg' });
                        
                        if (navigator.canShare({ files: [file] })) {
                            setTimeout(async () => {
                                try {
                                    await navigator.share({
                                        files: [file],
                                        title: 'K√∂lner Tour Foto',
                                        text: `Foto von ${station ? station.title : `Station ${stationId}`}`
                                    });
                                } catch (shareError) {
                                    console.log('Share failed:', shareError);
                                }
                            }, 1000);
                        }
                    } catch (shareError) {
                        console.log('Native sharing not available:', shareError);
                    }
                }
                
                return true;
                
            } catch (error) {
                console.error('Error saving photo to device:', error);
                throw error;
            }
        }

        // Helper function to convert data URL to Blob
        function dataURLToBlob(dataURL) {
            const arr = dataURL.split(',');
            const mime = arr[0].match(/:(.*?);/)[1];
            const bstr = atob(arr[1]);
            let n = bstr.length;
            const u8arr = new Uint8Array(n);
            
            while (n--) {
                u8arr[n] = bstr.charCodeAt(n);
            }
            
            return new Blob([u8arr], { type: mime });
        }

        // Generate descriptive filename for photos
        function generatePhotoFileName(stationId) {
            try {
                const station = tourApp.stations.find(s => s.id === stationId);
                const stationName = station ? station.title.replace(/[^a-zA-Z0-9]/g, '_') : `Station_${stationId}`;
                const timestamp = new Date().toISOString().slice(0, 19).replace(/[:-]/g, '');
                const userName = tourApp.state.userName.replace(/[^a-zA-Z0-9]/g, '_');
                const teamName = tourApp.state.teamName ? tourApp.state.teamName.replace(/[^a-zA-Z0-9]/g, '_') : 'NoTeam';
                
                return `Koeln_Tour_${stationName}_${userName}_${teamName}_${timestamp}.jpg`;
            } catch (error) {
                return `Koeln_Tour_Photo_${Date.now()}.jpg`;
            }
        }

        // Enhanced photo sharing with better quality
        async function shareChallengePhoto(stationId) {
            try {
                const photoData = tourApp.state.uploadedPhotos.find(p => p.stationId === stationId);
                if (!photoData) {
                    showNotification('Kein Foto zum Teilen gefunden!', 'error');
                    return;
                }

                const station = tourApp.stations.find(s => s.id === stationId);
                if (!station) return;

                // Create high-quality version for sharing (better compression)
                const shareableImage = await compressImage(
                    dataURLtoFile(photoData.imageUrl), 
                    0.85, // Higher quality for sharing
                    1600, // Larger dimensions for better quality
                    1200
                );

                const shareMessageData = {
                    userName: tourApp.state.userName,
                    image: shareableImage,
                    timestamp: firebase.firestore ? firebase.firestore.FieldValue.serverTimestamp() : Date.now(),
                    tourId: tourApp.state.tourId,
                    type: 'challenge-photo',
                    stationId: stationId,
                    stationTitle: station.title,
                    score: photoData.score || 0,
                    teamName: tourApp.state.teamName || 'Unbekanntes Team',
                    isDownloadable: true,
                    recognitionResults: photoData.analysis ? generateRecognitionSummary(photoData.analysis) : []
                };

                // Add to main chat with enhanced information
                addChallengePhotoMessage(shareMessageData, true);

                // Save to Firebase
                if (tourApp.state.isFirebaseConnected && tourApp.state.tourId) {
                    await saveToFirebase('chat', `challenge_${Date.now()}`, shareMessageData);
                } else {
                    const chatKey = `chat_${tourApp.state.tourId}`;
                    const chatMessages = JSON.parse(localStorage.getItem(chatKey) || '[]');
                    chatMessages.push(shareMessageData);
                    if (chatMessages.length > 50) {
                        chatMessages.splice(0, chatMessages.length - 50);
                    }
                    localStorage.setItem(chatKey, JSON.stringify(chatMessages));
                }

                showNotification('Challenge-Foto im Chat geteilt! üì§');
                
                // Disable share button to prevent spam
                const shareButton = document.querySelector(`[onclick="shareChallengePhoto(${stationId})"]`);
                if (shareButton) {
                    shareButton.disabled = true;
                    shareButton.textContent = '‚úÖ Foto geteilt';
                    shareButton.style.background = '#6b7280';
                }

                // Offer to save shared photo again for other participants
                setTimeout(() => {
                    if (confirm('M√∂chtest du das geteilte Foto auch f√ºr andere zum Download anbieten?')) {
                        offerPhotoDownload(shareableImage, station.title, photoData.score);
                    }
                }, 2000);

            } catch (error) {
                console.error('Error sharing challenge photo:', error);
                showNotification('Fehler beim Teilen des Fotos', 'error');
            }
        }

        // Enhanced photo download function
        function offerPhotoDownload(imageDataUrl, stationTitle, score) {
            try {
                const timestamp = new Date().toISOString().slice(0, 19).replace(/[:-]/g, '');
                const fileName = `Koeln_Tour_${stationTitle.replace(/[^a-zA-Z0-9]/g, '_')}_Shared_${score}pts_${timestamp}.jpg`;
                
                const link = document.createElement('a');
                link.href = imageDataUrl;
                link.download = fileName;
                link.style.display = 'none';
                
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                showNotification(`üì• Geteiltes Foto heruntergeladen: "${fileName}"`, 'success');
            } catch (error) {
                console.error('Error offering photo download:', error);
            }
        }


        // Station Gallery System
        function showStationGallery(stationId) {
            try {
                const station = tourApp.stations.find(s => s.id === stationId);
                if (!station) return;
                
                // Get all photos for this station from chat and uploaded photos
                const stationPhotos = [];
                
                // From uploaded photos
                tourApp.state.uploadedPhotos.forEach(photo => {
                    if (photo.stationId === stationId) {
                        stationPhotos.push({
                            imageUrl: photo.imageUrl,
                            userName: tourApp.state.userName,
                            score: photo.score || 0,
                            timestamp: photo.timestamp || Date.now(),
                            teamName: tourApp.state.teamName || 'Dein Team'
                        });
                    }
                });
                
                // From chat messages (shared photos)
                const chatMessages = document.querySelectorAll('.chat-message[data-station-id="' + stationId + '"]');
                chatMessages.forEach(msg => {
                    const img = msg.querySelector('.chat-image');
                    const userSpan = msg.querySelector('strong');
                    const scoreSpan = msg.querySelector('.photo-score');
                    
                    if (img && userSpan) {
                        stationPhotos.push({
                            imageUrl: img.src,
                            userName: userSpan.textContent.replace(':', ''),
                            score: scoreSpan ? parseInt(scoreSpan.textContent) : 0,
                            timestamp: Date.now(),
                            teamName: 'Anderes Team'
                        });
                    }
                });
                
                if (stationPhotos.length === 0) {
                    showNotification('Noch keine Fotos f√ºr diese Station vorhanden! üì∏', 'info');
                    return;
                }
                
                // Sort by score (highest first)
                stationPhotos.sort((a, b) => (b.score || 0) - (a.score || 0));
                
                // Create gallery modal
                const modal = document.createElement('div');
                modal.className = 'admin-popup-overlay';
                modal.style.zIndex = '20000';
                
                const photosHtml = stationPhotos.map((photo, index) => `
                    <div class="gallery-photo-item" style="background: white; border-radius: 12px; overflow: hidden; box-shadow: 0 4px 15px rgba(0,0,0,0.1);">
                        <img src="${photo.imageUrl}" 
                            style="width: 100%; height: 200px; object-fit: cover; cursor: pointer;" 
                            onclick="showImageModal('${photo.imageUrl}', '${station.title}', 'Von ${photo.userName} ‚Ä¢ ${photo.score} Punkte')"
                            alt="Challenge Foto">
                        <div style="padding: 1rem;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                                <strong style="color: #1f2937;">${photo.userName}</strong>
                                <span style="background: #10b981; color: white; padding: 0.3rem 0.8rem; border-radius: 20px; font-size: 0.8rem; font-weight: bold;">
                                    ${photo.score} Punkte
                                </span>
                            </div>
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <small style="color: #6b7280;">${photo.teamName}</small>
                                <button class="btn btn-secondary btn-small" onclick="downloadGalleryPhoto('${photo.imageUrl}', '${station.title}', '${photo.userName}', ${photo.score})" 
                                        style="padding: 0.3rem 0.8rem; font-size: 0.8rem;">
                                    üíæ Download
                                </button>
                            </div>
                        </div>
                    </div>
                `).join('');
                
                modal.innerHTML = `
                    <div class="admin-popup" style="max-width: 800px; width: 95%; max-height: 90vh; overflow-y: auto;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem; padding-bottom: 1rem; border-bottom: 2px solid #e5e7eb;">
                            <h3 style="color: #1f2937; margin: 0;">üì∏ ${station.title} - Foto-Galerie</h3>
                            <button onclick="this.closest('.admin-popup-overlay').remove()" style="background: none; border: none; font-size: 1.5rem; cursor: pointer; color: #6b7280;">√ó</button>
                        </div>
                        
                        <div style="margin-bottom: 1rem; padding: 1rem; background: #f0f9ff; border-radius: 8px; border-left: 4px solid #3b82f6;">
                            <strong style="color: #1e40af;">${stationPhotos.length} Foto${stationPhotos.length !== 1 ? 's' : ''} gefunden</strong>
                            <p style="margin: 0.5rem 0 0 0; color: #1e40af; font-size: 0.9rem;">Sortiert nach Punktzahl ‚Ä¢ Klicke auf Fotos f√ºr Vollansicht</p>
                        </div>
                        
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1rem;">
                            ${photosHtml}
                        </div>
                        
                        <div style="margin-top: 1.5rem; padding-top: 1rem; border-top: 2px solid #e5e7eb; text-align: center;">
                            <button class="btn btn-secondary" onclick="downloadAllStationPhotos(${stationId})" style="margin-right: 1rem;">
                                üì± Alle Fotos herunterladen
                            </button>
                            <button class="btn" onclick="this.closest('.admin-popup-overlay').remove()">
                                Galerie schlie√üen
                            </button>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(modal);
                
            } catch (error) {
                console.error('Error showing station gallery:', error);
                showNotification('Fehler beim Laden der Galerie', 'error');
            }
        }

        function downloadGalleryPhoto(imageUrl, stationTitle, userName, score) {
            try {
                const cleanStationTitle = stationTitle.replace(/[^a-zA-Z0-9]/g, '_');
                const cleanUserName = userName.replace(/[^a-zA-Z0-9]/g, '_');
                const timestamp = new Date().toISOString().slice(0, 19).replace(/[:-]/g, '');
                const fileName = `${cleanStationTitle}_${cleanUserName}_${score}pts_${timestamp}.jpg`;
                
                const link = document.createElement('a');
                link.href = imageUrl;
                link.download = fileName;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                showNotification(`üíæ Foto heruntergeladen: ${fileName}`, 'success');
            } catch (error) {
                console.error('Error downloading gallery photo:', error);
                showNotification('Download fehlgeschlagen', 'error');
            }
        }

        function downloadAllStationPhotos(stationId) {
            try {
                const stationPhotos = [];
                
                // From uploaded photos
                tourApp.state.uploadedPhotos.forEach(photo => {
                    if (photo.stationId === stationId) {
                        stationPhotos.push({
                            imageUrl: photo.imageUrl,
                            userName: tourApp.state.userName,
                            score: photo.score || 0
                        });
                    }
                });
                
                if (stationPhotos.length === 0) {
                    showNotification('Keine Fotos zum Herunterladen gefunden!', 'warning');
                    return;
                }
                
                const station = tourApp.stations.find(s => s.id === stationId);
                const stationTitle = station ? station.title : `Station_${stationId}`;
                
                stationPhotos.forEach((photo, index) => {
                    setTimeout(() => {
                        downloadGalleryPhoto(photo.imageUrl, stationTitle, photo.userName, photo.score);
                    }, index * 300);
                });
                
                showNotification(`üì± Lade ${stationPhotos.length} Fotos von ${stationTitle} herunter...`, 'info');
                
            } catch (error) {
                console.error('Error downloading all station photos:', error);
                showNotification('Fehler beim Herunterladen', 'error');
            }
        }


        // Batch download function for all tour photos
        function downloadAllTourPhotos() {
            try {
                if (tourApp.state.uploadedPhotos.length === 0) {
                    showNotification('Keine Fotos zum Herunterladen gefunden!', 'warning');
                    return;
                }
                
                let downloadCount = 0;
                const totalPhotos = tourApp.state.uploadedPhotos.length;
                
                tourApp.state.uploadedPhotos.forEach((photo, index) => {
                    setTimeout(() => {
                        const station = tourApp.stations.find(s => s.id === photo.stationId);
                        const stationName = station ? station.title : `Station_${photo.stationId}`;
                        const fileName = `Koeln_Tour_${stationName.replace(/[^a-zA-Z0-9]/g, '_')}_${photo.score || 0}pts_${index + 1}.jpg`;
                        
                        const link = document.createElement('a');
                        link.href = photo.imageUrl;
                        link.download = fileName;
                        link.style.display = 'none';
                        
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        
                        downloadCount++;
                        
                        if (downloadCount === totalPhotos) {
                            showNotification(`‚úÖ Alle ${totalPhotos} Tour-Fotos heruntergeladen!`, 'success');
                        }
                    }, index * 500); // Stagger downloads
                });
                
                showNotification(`üì± Lade ${totalPhotos} Tour-Fotos herunter...`, 'info');
                
            } catch (error) {
                console.error('Error downloading all tour photos:', error);
                showNotification('Fehler beim Herunterladen der Fotos', 'error');
            }
        }

        function ratePhoto(stationId, imageUrl) {
            try {
                const ratingDiv = document.getElementById(`rating-${stationId}`);
                if (ratingDiv) {
                    ratingDiv.classList.remove('hidden');
                }
                
                // Ensure station details stay open
                const stationDetails = document.getElementById(`station-${stationId}`);
                if (stationDetails && !stationDetails.classList.contains('active')) {
                    stationDetails.classList.add('active');
                }
                
                // Show enhanced loading state
                const ratingTextEl = document.getElementById(`rating-text-${stationId}`);
                if (ratingTextEl) {
                    ratingTextEl.innerHTML = `
                        <strong>ü§ñ KI analysiert dein Foto...</strong><br>
                        <small>‚Ä¢ Bildqualit√§t wird gepr√ºft</small><br>
                        <small>‚Ä¢ Personen werden erkannt</small><br>
                        <small>‚Ä¢ Objekte werden identifiziert</small><br>
                        <small>‚Ä¢ Komposition wird bewertet</small>
                    `;
                }
                
                // Analyze the actual image for comprehensive rating
                analyzePhotoForRating(imageUrl, stationId)
                    .then(analysis => {
                        const { technicalScore, compositionScore, creativityScore, finalScore, feedback, detailedAnalysis, recognitionResults } = analysis;
                        
                        console.log('üîç Photo Analysis Results:', {
                            technical: technicalScore,
                            composition: compositionScore,
                            creativity: creativityScore,
                            final: finalScore,
                            recognition: recognitionResults
                        });
                        
                        animateScore(stationId, finalScore);
                        
                        setTimeout(() => {
                            if (ratingTextEl) {
                                ratingTextEl.innerHTML = `
                                    <strong>KI-Bewertung abgeschlossen!</strong><br>
                                    <div style="display: flex; justify-content: space-between; margin: 0.5rem 0; font-size: 0.9rem;">
                                        <span>Technik: <strong>${Math.round(technicalScore)}%</strong></span>
                                        <span>Komposition: <strong>${Math.round(compositionScore)}%</strong></span>
                                        <span>Kreativit√§t: <strong>${Math.round(creativityScore)}%</strong></span>
                                    </div>
                                `;
                            }
                            
                            const ratingDetailsEl = document.getElementById(`rating-details-${stationId}`);
                            if (ratingDetailsEl) {
                                // Create tabbed interface for detailed feedback
                                ratingDetailsEl.innerHTML = `
                                    <div style="border-top: 2px solid #e5e7eb; margin-top: 1rem; padding-top: 1rem;">
                                        <div style="display: flex; background: #f8fafc; border-radius: 8px; margin-bottom: 1rem; overflow: hidden;">
                                            <button class="feedback-tab active" onclick="showFeedbackTab('recognition', ${stationId}, this)" 
                                                    style="flex: 1; padding: 0.5rem; border: none; background: transparent; cursor: pointer; font-size: 0.8rem; font-weight: bold;">
                                                üîç Erkannt
                                            </button>
                                            <button class="feedback-tab" onclick="showFeedbackTab('feedback', ${stationId}, this)" 
                                                    style="flex: 1; padding: 0.5rem; border: none; background: transparent; cursor: pointer; font-size: 0.8rem; font-weight: bold;">
                                                üí¨ Bewertung
                                            </button>
                                            <button class="feedback-tab" onclick="showFeedbackTab('technical', ${stationId}, this)" 
                                                    style="flex: 1; padding: 0.5rem; border: none; background: transparent; cursor: pointer; font-size: 0.8rem; font-weight: bold;">
                                                üî¨ Details
                                            </button>
                                        </div>
                                        
                                        <div class="feedback-content active" id="recognition-content-${stationId}">
                                            <h5 style="color: #059669; margin-bottom: 0.5rem;">üîç Was die KI erkannt hat:</h5>
                                            ${recognitionResults.map(result => `<div style="margin: 0.25rem 0; padding: 0.25rem 0.5rem; background: #f0fdf4; border-radius: 4px; font-size: 0.85rem;">${result}</div>`).join('')}
                                        </div>
                                        
                                        <div class="feedback-content" id="feedback-content-${stationId}" style="display: none;">
                                            <h5 style="color: #dc2626; margin-bottom: 0.5rem;">üí¨ KI-Bewertung:</h5>
                                            ${feedback.map(line => `<div style="margin: 0.25rem 0; font-size: 0.85rem; line-height: 1.4;">${line}</div>`).join('')}
                                        </div>
                                        
                                        <div class="feedback-content" id="technical-content-${stationId}" style="display: none;">
                                            <h5 style="color: #8b5cf6; margin-bottom: 0.5rem;">üî¨ Technische Analyse:</h5>
                                            <div style="font-size: 0.8rem; line-height: 1.3;">
                                                <div><strong>Bildqualit√§t:</strong> ${detailedAnalysis.sharpness.qualityLevel} (${Math.round(detailedAnalysis.sharpness.score)} Punkte)</div>
                                                <div><strong>Aufl√∂sung:</strong> ${detailedAnalysis.dimensions.width}√ó${detailedAnalysis.dimensions.height} Pixel</div>
                                                <div><strong>Helligkeit:</strong> ${Math.round(detailedAnalysis.brightness.average)}/255 (${detailedAnalysis.brightness.isOptimal ? 'optimal' : 'verbesserbar'})</div>
                                                <div><strong>Kontrast:</strong> ${detailedAnalysis.contrast.globalRange} (${detailedAnalysis.contrast.isGoodContrast ? 'gut' : 'schwach'})</div>
                                                ${detailedAnalysis.faces.likelyHasPeople ? `<div><strong>Personen:</strong> ${detailedAnalysis.faces.estimatedPeopleCount} erkannt (${(detailedAnalysis.faces.skinToneRatio * 100).toFixed(1)}% Hautton-Anteil)</div>` : ''}
                                                <div><strong>Objekte:</strong> ${detailedAnalysis.objects.totalObjects} verschiedene erkannt</div>
                                                <div><strong>Umgebung:</strong> ${detailedAnalysis.scenery.isOutdoor ? 'Au√üenbereich' : 'Innenbereich'} (${detailedAnalysis.scenery.dominantScenery})</div>
                                                ${detailedAnalysis.architecture.hasArchitecture ? `<div><strong>Architektur:</strong> ${detailedAnalysis.architecture.dominantStyle} Stil erkannt</div>` : ''}
                                                <div><strong>Farben:</strong> ${detailedAnalysis.colors.diversity} Farbt√∂ne, ${detailedAnalysis.colors.isColorful ? 'farbenfroh' : 'monochrom'}</div>
                                                <div><strong>Interessante Bereiche:</strong> ${detailedAnalysis.composition.interestPoints} Fokuspunkte</div>
                                                <div><strong>Komposition:</strong> Drittel-Regel zu ${Math.round(detailedAnalysis.composition.ruleOfThirds * 100)}% befolgt</div>
                                            </div>
                                        </div>
                                    </div>
                                `;
                            }

                            // Show share button after rating is complete
                            const shareSection = document.getElementById(`share-photo-section-${stationId}`);
                            if (shareSection) {
                                shareSection.classList.remove('hidden');
                                shareSection.innerHTML = `
                                    <div style="margin-top: 1rem; padding-top: 1rem; border-top: 2px solid #e5e7eb;">
                                        <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                                            <button class="btn btn-secondary" onclick="shareChallengePhoto(${stationId})" style="background: #059669; flex: 1; min-width: 120px;">
                                                üì§ Im Chat teilen
                                            </button>
                                            <button class="btn btn-secondary" onclick="savePhotoToDevice('${imageUrl}', ${stationId})" style="background: #8b5cf6; flex: 1; min-width: 120px;">
                                                üíæ Foto speichern
                                            </button>
                                        </div>
                                        <p style="font-size: 0.8rem; color: #6b7280; margin-top: 0.5rem; text-align: center;">
                                            üí° Teile dein Challenge-Foto oder speichere es auf deinem Ger√§t!
                                        </p>
                                    </div>
                                `;
                            }
                            
                        }, 3000); // Longer delay to show detailed analysis
                        
                        // NEUES LIMIT: Pro Station nur ein Foto bewerten  
                        const existingPhoto = tourApp.state.uploadedPhotos.find(p => p.stationId === stationId);
                        if (existingPhoto && existingPhoto.score) {
                            // Ersetze den Score des vorherigen Fotos
                            const oldScore = existingPhoto.score || 0;
                            const scoreDifference = finalScore - oldScore;
                            addScore(scoreDifference);
                            
                            showNotification(`üì∏ Foto ersetzt! Score-√Ñnderung: ${scoreDifference > 0 ? '+' : ''}${scoreDifference}`, 'info');
                        } else {
                            // Neues Foto f√ºr diese Station
                            addScore(finalScore);
                        }

                        // Store comprehensive analysis data
                        const photoData = tourApp.state.uploadedPhotos.find(p => p.stationId === stationId);
                        if (photoData) {
                            photoData.score = finalScore;
                            photoData.analysis = detailedAnalysis;
                            photoData.recognitionResults = recognitionResults;
                            photoData.breakdown = {
                                technical: technicalScore,
                                composition: compositionScore,
                                creativity: creativityScore
                            };
                        }
                        
                        showNotification(`KI-Bewertung: ${finalScore} Punkte! ü§ñüì∏`);
                        
                        // Enhanced achievement notifications
                        if (finalScore >= 90) {
                            setTimeout(() => showNotification('üèÜ Meisterwerk! Fantastisches Foto!', 'success'), 1000);
                        } else if (finalScore >= 80) {
                            setTimeout(() => showNotification('‚≠ê Excellentes Foto! Sehr gut gemacht!', 'success'), 1000);
                        } else if (finalScore >= 70) {
                            setTimeout(() => showNotification('üëç Sehr gutes Foto! Weiter so!', 'success'), 1000);
                        }
                        
                        // Special achievement for people photos
                        if (detailedAnalysis.faces.estimatedPeopleCount >= 3 && detailedAnalysis.faces.estimatedSmilingPeople >= 2) {
                            setTimeout(() => showNotification('üéâ Team-Harmony Achievement freigeschaltet!', 'success'), 1500);
                        }
                        
                        if (detailedAnalysis.faces.estimatedPeopleCount >= 5) {
                            setTimeout(() => showNotification('üë• Gro√ügruppen-Foto Achievement freigeschaltet!', 'success'), 2000);
                        }
                        
                    })
                    .catch(error => {
                        console.error('Error analyzing photo:', error);
                        
                        // Spezielle Behandlung f√ºr Benutzerabbruch
                        if (error.message === 'USER_CANCELLED') {
                            showNotification('Foto-Bewertung abgebrochen', 'info');
                            
                            // Reset UI
                            const ratingDiv = document.getElementById(`rating-${stationId}`);
                            if (ratingDiv) {
                                ratingDiv.classList.add('hidden');
                            }
                            
                            const uploadContent = document.getElementById(`upload-content-${stationId}`);
                            if (uploadContent) {
                                uploadContent.innerHTML = `
                                    üì∑ Hier klicken zum Foto machen/ausw√§hlen<br>
                                    <small>KI bewertet automatisch Qualit√§t, Komposition & Kreativit√§t</small>
                                `;
                            }
                            return;
                        }
                        
                        // Enhanced fallback analysis
                        const fallbackAnalysis = createEnhancedFallbackAnalysis(stationId);
                        const { technicalScore, compositionScore, creativityScore, finalScore, feedback } = fallbackAnalysis;
                        
                        animateScore(stationId, finalScore);
                        
                        setTimeout(() => {
                            if (ratingTextEl) {
                                ratingTextEl.innerHTML = `
                                    <strong>Bewertung abgeschlossen!</strong><br>
                                    <div style="display: flex; justify-content: space-between; margin: 0.5rem 0; font-size: 0.9rem;">
                                        <span>Technik: <strong>${Math.round(technicalScore)}%</strong></span>
                                        <span>Komposition: <strong>${Math.round(compositionScore)}%</strong></span>
                                        <span>Kreativit√§t: <strong>${Math.round(creativityScore)}%</strong></span>
                                    </div>
                                `;
                            }
                            
                            const ratingDetailsEl = document.getElementById(`rating-details-${stationId}`);
                            if (ratingDetailsEl) {
                                ratingDetailsEl.innerHTML = feedback.join('<br>');
                            }

                            const shareSection = document.getElementById(`share-photo-section-${stationId}`);
                            if (shareSection) {
                                shareSection.classList.remove('hidden');
                            }
                        }, 2000);
                        
                        addScore(finalScore);
                        
                        const photoData = tourApp.state.uploadedPhotos.find(p => p.stationId === stationId);
                        if (photoData) {
                            photoData.score = finalScore;
                            photoData.fallbackUsed = true;
                        }
                        
                        showNotification(`Bewertung: ${finalScore} Punkte! üì∏`);
                    });
                
            } catch (error) {
                console.error('Error rating photo:', error);
            }
        }

        // Enhanced fallback analysis for when detailed analysis fails
        function createEnhancedFallbackAnalysis(stationId) {
            const station = tourApp.stations.find(s => s.id === stationId);
            const timeOfDay = new Date().getHours();
            
            // More intelligent fallback based on context
            let technicalScore = 60 + Math.random() * 30;
            let compositionScore = 55 + Math.random() * 35;
            let creativityScore = 50 + Math.random() * 30;
            
            // Station-specific bonuses
            if (station) {
                if (station.title.includes('Dom')) {
                    creativityScore += 8;
                    compositionScore += 5;
                }
                if (station.title.includes('Heumarkt')) {
                    technicalScore += 5;
                    creativityScore += 5;
                }
                if (station.title.includes('Altstadt')) {
                    compositionScore += 8;
                    creativityScore += 3;
                }
            }
            
            // Time-based adjustments
            if (timeOfDay >= 10 && timeOfDay <= 16) {
                technicalScore += 8; // Good lighting hours
            } else if (timeOfDay >= 19 || timeOfDay <= 7) {
                technicalScore -= 5; // Challenging lighting
                creativityScore += 5; // Bonus for night photography
            }
            
            // Team simulation with more realistic distribution
            let simulatedPeople = 1;
            let simulatedSmiles = 0;
            
            if (tourApp.state.selectedTeam) {
                // More realistic people simulation
                const teamSizeProb = Math.random();
                if (teamSizeProb > 0.7) simulatedPeople = 2;
                if (teamSizeProb > 0.85) simulatedPeople = 3;
                if (teamSizeProb > 0.95) simulatedPeople = 4;
                
                simulatedSmiles = Math.floor(simulatedPeople * (0.6 + Math.random() * 0.4));
                
                creativityScore += 12; // Base team bonus
                
                // People bonuses
                if (simulatedPeople >= 2) creativityScore += 10;
                if (simulatedPeople >= 3) creativityScore += 8;
                if (simulatedPeople >= 4) creativityScore += 6;
                
                // Smile bonuses
                creativityScore += simulatedSmiles * 5;
            }
            
            const finalScore = Math.round(
                (technicalScore * 0.35) + 
                (compositionScore * 0.30) + 
                (creativityScore * 0.35)
            );
            
            const feedback = [
                technicalScore > 80 ? "üì∏ Sehr gute Bildqualit√§t!" : technicalScore > 60 ? "üì± Solide Aufnahme" : "üì∑ Grundsolide Qualit√§t",
                compositionScore > 80 ? "üé® Kreative Bildgestaltung!" : compositionScore > 60 ? "üìê Gute Komposition" : "üñºÔ∏è Ordentliche Bildaufteilung",
                creativityScore > 80 ? "‚ú® Sehr originell und kreativ!" : creativityScore > 60 ? "üé≠ Sch√∂ne kreative Elemente" : "üåü Gute Ans√§tze erkennbar"
            ];

            if (tourApp.state.selectedTeam) {
                feedback.push(`üë• ${simulatedPeople} Person${simulatedPeople > 1 ? 'en' : ''} erkannt!`);
                if (simulatedSmiles > 0) {
                    feedback.push(`üòä ${simulatedSmiles} l√§chelnde Person${simulatedSmiles > 1 ? 'en' : ''}!`);
                    feedback.push(`‚ú® Extra-Punkte f√ºr gute Stimmung! (+${simulatedSmiles * 5})`);
                }
                feedback.push(`üéä Team-Foto Bonus! (+12 Punkte)`);
            } else {
                feedback.push("üì∑ Einzelaufnahme - k√ºnstlerischer Ansatz!");
            }
            
            if (station) {
                feedback.push(`üèõÔ∏è ${station.title} - Standort-Bonus! (+5 Punkte)`);
            }
            
            return {
                technicalScore: Math.max(30, Math.min(100, technicalScore)),
                compositionScore: Math.max(30, Math.min(100, compositionScore)),
                creativityScore: Math.max(30, Math.min(100, creativityScore)),
                finalScore: Math.max(30, Math.min(100, finalScore)),
                feedback,
                peopleCount: simulatedPeople,
                smilingCount: simulatedSmiles
            };
        }

        // Function to show different feedback tabs
        function showFeedbackTab(tabType, stationId, tabElement) {
            try {
                // Update tab appearance
                const parentDiv = tabElement.parentElement;
                parentDiv.querySelectorAll('.feedback-tab').forEach(tab => {
                    tab.classList.remove('active');
                    tab.style.background = 'transparent';
                    tab.style.color = '#6b7280';
                });
                
                tabElement.classList.add('active');
                tabElement.style.background = '#dc2626';
                tabElement.style.color = 'white';

                // Show/hide content
                const ratingDetailsEl = document.getElementById(`rating-details-${stationId}`);
                if (ratingDetailsEl) {
                    ratingDetailsEl.querySelectorAll('.feedback-content').forEach(content => {
                        content.classList.remove('active');
                        content.style.display = 'none';
                    });
                    
                    const targetContent = document.getElementById(`${tabType}-content-${stationId}`);
                    if (targetContent) {
                        targetContent.classList.add('active');
                        targetContent.style.display = 'block';
                    }
                }
            } catch (error) {
                console.error('Error showing feedback tab:', error);
            }
        }

        // Enhanced Photo Analysis Functions
        function analyzePhotoForRating(imageUrl, stationId) {
            return new Promise((resolve, reject) => {
                try {
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    
                    img.onload = async function() {
                        try {
                            // Create canvas for analysis
                            const canvas = document.createElement('canvas');
                            const ctx = canvas.getContext('2d');
                            
                            // Set canvas size to match image (max 1200px for better analysis)
                            const maxSize = 1200;
                            let { width, height } = img;
                            const originalDimensions = { width, height };
                            
                            if (width > maxSize || height > maxSize) {
                                if (width > height) {
                                    height = (height * maxSize) / width;
                                    width = maxSize;
                                } else {
                                    width = (width * maxSize) / height;
                                    height = maxSize;
                                }
                            }
                            
                            canvas.width = width;
                            canvas.height = height;
                            ctx.drawImage(img, 0, 0, width, height);
                            
                            // Get image data for analysis
                            const imageData = ctx.getImageData(0, 0, width, height);
                            const pixels = imageData.data;
                            
                            console.log(`üîç Analysiere Bild: ${width}x${height} (Original: ${originalDimensions.width}x${originalDimensions.height})`);
                            
                            // Comprehensive image analysis
                            const brightnessAnalysis = analyzeBrightnessAdvanced(pixels, width, height);
                            const contrastAnalysis = analyzeContrastAdvanced(pixels, width, height);
                            const sharpnessAnalysis = analyzeSharpnessAdvanced(imageData, width, height);
                            const compositionAnalysis = analyzeCompositionAdvanced(width, height, pixels);
                            const colorAnalysis = analyzeColorsAdvanced(pixels, width, height);
                            const objectAnalysis = analyzeObjectsAdvanced(pixels, width, height);
                            const faceAnalysis = analyzeFacesAdvanced(imageData, width, height);
                            const sceneryAnalysis = analyzeSceneryAdvanced(pixels, width, height);
                            const architectureAnalysis = analyzeArchitectureAdvanced(pixels, width, height);
                            const lightingAnalysis = analyzeLightingAdvanced(pixels, width, height);
                            
                            // Calculate scores based on comprehensive analysis
                            const technicalScore = calculateTechnicalScoreAdvanced(brightnessAnalysis, contrastAnalysis, sharpnessAnalysis, lightingAnalysis);
                            const compositionScore = calculateCompositionScoreAdvanced(compositionAnalysis, architectureAnalysis, width, height);
                            const creativityScore = calculateCreativityScoreAdvanced(colorAnalysis, faceAnalysis, objectAnalysis, sceneryAnalysis, stationId);
                            
                            // Calculate final score (weighted average)
                            const finalScore = Math.round(
                                (technicalScore * 0.35) + 
                                (compositionScore * 0.30) + 
                                (creativityScore * 0.35)
                            );
                            
                            // NEUE VALIDIERUNG: Pr√ºfe auf irrelevante Motive
                            const irrelevantCheck = isIrrelevantSubject(faceAnalysis, colorAnalysis, brightnessAnalysis, compositionAnalysis, objectAnalysis);
                            if (irrelevantCheck.isIrrelevant) {
                                // Zeige Best√§tigungsdialog
                                const recognitionResults = generateRecognitionSummary({
                                    faces: faceAnalysis,
                                    colors: colorAnalysis, 
                                    objects: objectAnalysis,
                                    scenery: sceneryAnalysis,
                                    architecture: architectureAnalysis
                                });
                                
                                const confirmed = await showRecognitionConfirmDialog(recognitionResults, irrelevantCheck.reason);
                                if (!confirmed) {
                                    reject(new Error('USER_CANCELLED'));
                                    return;
                                }
                            }

                            // Generate comprehensive feedback with detailed recognition results
                            const detailedAnalysis = {
                                brightness: brightnessAnalysis,
                                contrast: contrastAnalysis,
                                sharpness: sharpnessAnalysis,
                                composition: compositionAnalysis,
                                colors: colorAnalysis,
                                objects: objectAnalysis,
                                faces: faceAnalysis,
                                scenery: sceneryAnalysis,
                                architecture: architectureAnalysis,
                                lighting: lightingAnalysis,
                                dimensions: { width, height, original: originalDimensions }
                            };
                            
                            const feedback = generateComprehensiveFeedback(
                                technicalScore, compositionScore, creativityScore,
                                detailedAnalysis
                            );
                            
                            resolve({
                                technicalScore,
                                compositionScore,
                                creativityScore,
                                finalScore: Math.max(25, Math.min(100, finalScore)),
                                feedback,
                                detailedAnalysis,
                                recognitionResults: generateRecognitionSummary(detailedAnalysis)
                            });
                            
                        } catch (analysisError) {
                            console.error('Error during image analysis:', analysisError);
                            reject(analysisError);
                        }
                    };
                    
                    img.onerror = function() {
                        reject(new Error('Failed to load image for analysis'));
                    };
                    
                    img.src = imageUrl;
                    
                } catch (error) {
                    reject(error);
                }
            });
        }

        // Advanced Brightness Analysis
        function analyzeBrightnessAdvanced(pixels, width, height) {
            let totalBrightness = 0;
            let pixelCount = pixels.length / 4;
            let brightnessHistogram = new Array(256).fill(0);
            let darkPixels = 0, midtonePixels = 0, brightPixels = 0;
            
            for (let i = 0; i < pixels.length; i += 4) {
                const r = pixels[i];
                const g = pixels[i + 1];
                const b = pixels[i + 2];
                
                // Calculate luminance using proper weights
                const brightness = Math.round(0.299 * r + 0.587 * g + 0.114 * b);
                totalBrightness += brightness;
                brightnessHistogram[brightness]++;
                
                if (brightness < 85) darkPixels++;
                else if (brightness < 170) midtonePixels++;
                else brightPixels++;
            }
            
            const averageBrightness = totalBrightness / pixelCount;
            
            // Analyze brightness distribution
            const darkRatio = darkPixels / pixelCount;
            const midtoneRatio = midtonePixels / pixelCount;
            const brightRatio = brightPixels / pixelCount;
            
            return {
                average: averageBrightness,
                darkRatio: darkRatio,
                midtoneRatio: midtoneRatio,
                brightRatio: brightRatio,
                histogram: brightnessHistogram,
                isWellExposed: averageBrightness > 60 && averageBrightness < 190,
                isDark: averageBrightness < 70,
                isBright: averageBrightness > 180,
                isOptimal: averageBrightness > 90 && averageBrightness < 170,
                hasGoodDistribution: midtoneRatio > 0.4 && darkRatio < 0.4 && brightRatio < 0.3,
                dynamicRange: Math.max(...brightnessHistogram) - Math.min(...brightnessHistogram.filter(v => v > 0))
            };
        }

        // Advanced Contrast Analysis
        function analyzeContrastAdvanced(pixels, width, height) {
            let min = 255, max = 0;
            let histogram = new Array(256).fill(0);
            let localContrastSum = 0;
            let localContrastCount = 0;
            
            for (let i = 0; i < pixels.length; i += 4) {
                const r = pixels[i];
                const g = pixels[i + 1];
                const b = pixels[i + 2];
                const gray = Math.round(0.299 * r + 0.587 * g + 0.114 * b);
                
                histogram[gray]++;
                min = Math.min(min, gray);
                max = Math.max(max, gray);
            }
            
            // Calculate local contrast (RMS contrast)
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const centerIdx = (y * width + x) * 4;
                    const centerGray = getGrayValue(pixels, y * width + x);
                    
                    let neighborSum = 0;
                    let neighborCount = 0;
                    
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            if (dx !== 0 || dy !== 0) {
                                const neighborGray = getGrayValue(pixels, (y + dy) * width + (x + dx));
                                neighborSum += neighborGray;
                                neighborCount++;
                            }
                        }
                    }
                    
                    const neighborAvg = neighborSum / neighborCount;
                    localContrastSum += Math.pow(centerGray - neighborAvg, 2);
                    localContrastCount++;
                }
            }
            
            const globalContrast = max - min;
            const localContrast = Math.sqrt(localContrastSum / localContrastCount);
            
            return {
                globalRange: globalContrast,
                localContrast: localContrast,
                min: min,
                max: max,
                histogram: histogram,
                isGoodContrast: globalContrast > 120 && globalContrast < 230,
                isLowContrast: globalContrast < 100,
                isHighContrast: globalContrast > 210,
                hasGoodLocalContrast: localContrast > 20 && localContrast < 80,
                rmsContrast: localContrast
            };
        }

        // Advanced Sharpness Analysis
        function analyzeSharpnessAdvanced(imageData, width, height) {
            const pixels = imageData.data;
            let sharpnessSum = 0;
            let edgeCount = 0;
            let maxEdgeStrength = 0;
            let edgeMap = new Array(width * height).fill(0);
            
            // Enhanced edge detection with multiple operators
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const idx = y * width + x;
                    
                    // 3x3 neighborhood
                    const p1 = getGrayValue(pixels, (y-1) * width + (x-1));
                    const p2 = getGrayValue(pixels, (y-1) * width + x);
                    const p3 = getGrayValue(pixels, (y-1) * width + (x+1));
                    const p4 = getGrayValue(pixels, y * width + (x-1));
                    const p5 = getGrayValue(pixels, y * width + x);
                    const p6 = getGrayValue(pixels, y * width + (x+1));
                    const p7 = getGrayValue(pixels, (y+1) * width + (x-1));
                    const p8 = getGrayValue(pixels, (y+1) * width + x);
                    const p9 = getGrayValue(pixels, (y+1) * width + (x+1));
                    
                    // Sobel operators
                    const sobelX = (p3 + 2*p6 + p9) - (p1 + 2*p4 + p7);
                    const sobelY = (p7 + 2*p8 + p9) - (p1 + 2*p2 + p3);
                    
                    // Laplacian operator for additional edge detection
                    const laplacian = Math.abs(-p1 - p2 - p3 - p4 + 8*p5 - p6 - p7 - p8 - p9);
                    
                    const sobelMagnitude = Math.sqrt(sobelX * sobelX + sobelY * sobelY);
                    const combinedEdgeStrength = (sobelMagnitude + laplacian) / 2;
                    
                    edgeMap[idx] = combinedEdgeStrength;
                    
                    if (combinedEdgeStrength > 25) {
                        sharpnessSum += combinedEdgeStrength;
                        edgeCount++;
                        maxEdgeStrength = Math.max(maxEdgeStrength, combinedEdgeStrength);
                    }
                }
            }
            
            const averageSharpness = edgeCount > 0 ? sharpnessSum / edgeCount : 0;
            const edgeDensity = edgeCount / (width * height);
            
            return {
                score: averageSharpness,
                edgeCount: edgeCount,
                edgeDensity: edgeDensity,
                maxEdgeStrength: maxEdgeStrength,
                isSharp: averageSharpness > 45 && edgeDensity > 0.05,
                isBlurry: averageSharpness < 25 || edgeDensity < 0.02,
                isOptimal: averageSharpness > 35 && averageSharpness < 100 && edgeDensity > 0.03,
                qualityLevel: averageSharpness > 50 ? 'excellent' : averageSharpness > 35 ? 'good' : averageSharpness > 25 ? 'fair' : 'poor'
            };
        }

        // Advanced Object Analysis
        function analyzeObjectsAdvanced(pixels, width, height) {
            const objects = {
                buildings: 0,
                vehicles: 0,
                nature: 0,
                signs: 0,
                furniture: 0,
                technology: 0
            };
            
            // Analyze color patterns and geometric shapes for object detection
            const colorRegions = detectColorRegions(pixels, width, height);
            const geometricShapes = detectGeometricShapes(pixels, width, height);
            const textureAnalysis = analyzeTextures(pixels, width, height);
            
            // Building detection (straight lines, geometric patterns, typical building colors)
            if (geometricShapes.straightLines > 20 && textureAnalysis.uniformRegions > 0.3) {
                objects.buildings = Math.min(5, Math.floor(geometricShapes.straightLines / 10));
            }
            
            // Vehicle detection (metallic colors, rounded shapes)
            if (colorRegions.metallic > 0.05 && geometricShapes.curves > 5) {
                objects.vehicles = Math.min(3, Math.floor(colorRegions.metallic * 20));
            }
            
            // Nature detection (green colors, organic textures)
            if (colorRegions.green > 0.15 && textureAnalysis.organicTextures > 0.2) {
                objects.nature = Math.min(4, Math.floor(colorRegions.green * 10));
            }
            
            // Technology detection (screens, rectangular shapes with specific color patterns)
            if (colorRegions.screen > 0.02 && geometricShapes.rectangles > 3) {
                objects.technology = Math.min(2, geometricShapes.rectangles);
            }
            
            return {
                detected: objects,
                totalObjects: Object.values(objects).reduce((a, b) => a + b, 0),
                dominantType: Object.keys(objects).reduce((a, b) => objects[a] > objects[b] ? a : b),
                colorRegions: colorRegions,
                geometricShapes: geometricShapes,
                textureAnalysis: textureAnalysis
            };
        }

        // Advanced Scenery Analysis
        function analyzeSceneryAdvanced(pixels, width, height) {
            const sceneryTypes = {
                urban: 0,
                historic: 0,
                park: 0,
                waterfront: 0,
                indoor: 0,
                street: 0
            };
            
            const colorAnalysis = analyzeSceneryColors(pixels);
            const structuralAnalysis = analyzeSceneryStructure(pixels, width, height);
            
            // Urban scenery (concrete colors, geometric structures)
            if (colorAnalysis.concrete > 0.3 && structuralAnalysis.verticalLines > 15) {
                sceneryTypes.urban = Math.min(5, Math.floor(colorAnalysis.concrete * 10));
            }
            
            // Historic scenery (stone colors, aged textures)
            if (colorAnalysis.stone > 0.2 && structuralAnalysis.weatheredTextures > 0.15) {
                sceneryTypes.historic = Math.min(5, Math.floor(colorAnalysis.stone * 15));
            }
            
            // Park/green areas
            if (colorAnalysis.vegetation > 0.25) {
                sceneryTypes.park = Math.min(4, Math.floor(colorAnalysis.vegetation * 8));
            }
            
            // Waterfront (blue colors, horizontal lines)
            if (colorAnalysis.water > 0.1 && structuralAnalysis.horizontalLines > 5) {
                sceneryTypes.waterfront = Math.min(3, Math.floor(colorAnalysis.water * 20));
            }
            
            // Indoor detection (uniform lighting, enclosed feeling)
            if (structuralAnalysis.enclosedSpace > 0.6) {
                sceneryTypes.indoor = Math.min(3, Math.floor(structuralAnalysis.enclosedSpace * 5));
            }
            
            return {
                types: sceneryTypes,
                dominantScenery: Object.keys(sceneryTypes).reduce((a, b) => sceneryTypes[a] > sceneryTypes[b] ? a : b),
                isOutdoor: sceneryTypes.urban + sceneryTypes.historic + sceneryTypes.park + sceneryTypes.waterfront > sceneryTypes.indoor,
                colorAnalysis: colorAnalysis,
                structuralAnalysis: structuralAnalysis
            };
        }

        // Advanced Architecture Analysis
        function analyzeArchitectureAdvanced(pixels, width, height) {
            const architecturalFeatures = {
                gothic: 0,
                modern: 0,
                classical: 0,
                industrial: 0
            };
            
            const lineAnalysis = analyzeArchitecturalLines(pixels, width, height);
            const proportionAnalysis = analyzeArchitecturalProportions(width, height);
            
            // Gothic features (pointed arches, vertical emphasis)
            if (lineAnalysis.verticalEmphasis > 0.6 && lineAnalysis.pointedShapes > 3) {
                architecturalFeatures.gothic = Math.min(5, lineAnalysis.pointedShapes);
            }
            
            // Modern features (clean lines, glass/metal colors)
            if (lineAnalysis.cleanLines > 0.5 && proportionAnalysis.modernRatios > 0.3) {
                architecturalFeatures.modern = Math.min(4, Math.floor(lineAnalysis.cleanLines * 8));
            }
            
            // Classical features (symmetry, traditional proportions)
            if (proportionAnalysis.symmetry > 0.7 && proportionAnalysis.classicalRatios > 0.4) {
                architecturalFeatures.classical = Math.min(4, Math.floor(proportionAnalysis.symmetry * 6));
            }
            
            return {
                features: architecturalFeatures,
                dominantStyle: Object.keys(architecturalFeatures).reduce((a, b) => architecturalFeatures[a] > architecturalFeatures[b] ? a : b),
                lineAnalysis: lineAnalysis,
                proportionAnalysis: proportionAnalysis,
                hasArchitecture: Object.values(architecturalFeatures).some(v => v > 0)
            };
        }

        // Helper functions for advanced analysis
        function detectColorRegions(pixels, width, height) {
            let metallic = 0, green = 0, screen = 0, concrete = 0, stone = 0, vegetation = 0, water = 0;
            const totalPixels = pixels.length / 4;
            
            for (let i = 0; i < pixels.length; i += 4) {
                const r = pixels[i];
                const g = pixels[i + 1];
                const b = pixels[i + 2];
                
                // Metallic detection (high saturation grays, blues)
                if (Math.abs(r - g) < 20 && Math.abs(g - b) < 20 && r > 100) metallic++;
                
                // Green vegetation
                if (g > r + 20 && g > b + 10 && g > 80) vegetation++;
                
                // Screen/display detection (bright blues, whites with RGB patterns)
                if ((b > r + 30 && b > g + 10) || (r > 200 && g > 200 && b > 200)) screen++;
                
                // Concrete (specific gray tones)
                if (Math.abs(r - g) < 15 && Math.abs(g - b) < 15 && r > 80 && r < 160) concrete++;
                
                // Stone (warmer grays, browns)
                if (r > g && g > b && r - b > 20 && r > 90 && r < 180) stone++;
                
                // Water (blues, blue-greens)
                if (b > r + 15 && b > g + 5 && b > 60) water++;
            }
            
            return {
                metallic: metallic / totalPixels,
                green: vegetation / totalPixels,
                screen: screen / totalPixels,
                concrete: concrete / totalPixels,
                stone: stone / totalPixels,
                vegetation: vegetation / totalPixels,
                water: water / totalPixels
            };
        }

        function detectGeometricShapes(pixels, width, height) {
            let straightLines = 0;
            let curves = 0;
            let rectangles = 0;
            let circles = 0;
            
            // Simple edge-based shape detection
            for (let y = 2; y < height - 2; y += 3) {
                for (let x = 2; x < width - 2; x += 3) {
                    const edges = getLocalEdges(pixels, x, y, width);
                    
                    if (edges.horizontal > 0.8 || edges.vertical > 0.8) straightLines++;
                    if (edges.diagonal > 0.6) curves++;
                    if (edges.rectangular > 0.7) rectangles++;
                    if (edges.circular > 0.6) circles++;
                }
            }
            
            return {
                straightLines: straightLines,
                curves: curves,
                rectangles: rectangles,
                circles: circles
            };
        }

        function getLocalEdges(pixels, x, y, width) {
            // Simplified edge pattern detection in 5x5 neighborhood
            let horizontal = 0, vertical = 0, diagonal = 0, rectangular = 0, circular = 0;
            
            for (let dy = -2; dy <= 2; dy++) {
                for (let dx = -2; dx <= 2; dx++) {
                    const gray = getGrayValue(pixels, (y + dy) * width + (x + dx));
                    
                    // Pattern analysis (simplified)
                    if (Math.abs(dx) < Math.abs(dy)) horizontal += gray;
                    if (Math.abs(dy) < Math.abs(dx)) vertical += gray;
                    if (Math.abs(dx) === Math.abs(dy)) diagonal += gray;
                }
            }
            
            // Normalize and create pattern scores
            return {
                horizontal: Math.min(1, horizontal / 1000),
                vertical: Math.min(1, vertical / 1000),
                diagonal: Math.min(1, diagonal / 800),
                rectangular: Math.min(1, (horizontal + vertical) / 2000),
                circular: Math.min(1, diagonal / 800)
            };
        }

        // Generate comprehensive recognition summary
        function generateRecognitionSummary(analysis) {
            const summary = [];
            
            // Faces and people
            if (analysis.faces.estimatedPeopleCount > 0) {
                summary.push(`üë• ${analysis.faces.estimatedPeopleCount} Person${analysis.faces.estimatedPeopleCount > 1 ? 'en' : ''} erkannt`);
                if (analysis.faces.estimatedSmilingPeople > 0) {
                    summary.push(`üòä ${analysis.faces.estimatedSmilingPeople} l√§chelnde Person${analysis.faces.estimatedSmilingPeople > 1 ? 'en' : ''}`);
                }
            }
            
            // Objects
            if (analysis.objects.totalObjects > 0) {
                const dominantObject = analysis.objects.dominantType;
                const objectNames = {
                    buildings: 'Geb√§ude',
                    vehicles: 'Fahrzeuge', 
                    nature: 'Natur-Elemente',
                    technology: 'Technische Ger√§te',
                    signs: 'Schilder',
                    furniture: 'M√∂bel'
                };
                summary.push(`üèóÔ∏è ${objectNames[dominantObject] || dominantObject} erkannt`);
            }
            
            // Scenery
            if (analysis.scenery.dominantScenery !== 'indoor') {
                const sceneryNames = {
                    urban: 'St√§dtische Umgebung',
                    historic: 'Historische Architektur',
                    park: 'Park/Gr√ºnanlage',
                    waterfront: 'Gew√§sser/Uferbereich',
                    street: 'Stra√üenszene'
                };
                summary.push(`üèûÔ∏è ${sceneryNames[analysis.scenery.dominantScenery] || 'Au√üenbereich'}`);
            } else {
                summary.push(`üè† Innenraum erkannt`);
            }
            
            // Architecture
            if (analysis.architecture.hasArchitecture) {
                const styleNames = {
                    gothic: 'Gotische Architektur',
                    modern: 'Moderne Architektur',
                    classical: 'Klassische Architektur',
                    industrial: 'Industriearchitektur'
                };
                summary.push(`üèõÔ∏è ${styleNames[analysis.architecture.dominantStyle] || 'Architektonische Elemente'}`);
            }
            
            // Technical quality
            const qualityLevel = analysis.sharpness.qualityLevel;
            const qualityNames = {
                excellent: 'Exzellente Bildqualit√§t',
                good: 'Gute Bildqualit√§t',
                fair: 'Ordentliche Bildqualit√§t',
                poor: 'Verbesserungsw√ºrdige Qualit√§t'
            };
            summary.push(`üì∏ ${qualityNames[qualityLevel]}`);
            
            // Lighting
            if (analysis.lighting.naturalLight > 0.6) {
                summary.push(`‚òÄÔ∏è Nat√ºrliches Licht`);
            } else if (analysis.lighting.artificialLight > 0.5) {
                summary.push(`üí° K√ºnstliche Beleuchtung`);
            }
            
            // Colors
            if (analysis.colors.isColorful) {
                summary.push(`üåà Farbenfrohe Aufnahme`);
            }
            
            return summary;
        }


        // Additional helper functions for advanced analysis
        function analyzeTextures(pixels, width, height) {
            let uniformRegions = 0;
            let organicTextures = 0;
            let totalRegions = 0;
            
            // Sample texture analysis in grid
            const gridSize = 20;
            for (let y = 0; y < height - gridSize; y += gridSize) {
                for (let x = 0; x < width - gridSize; x += gridSize) {
                    const textureVariance = calculateTextureVariance(pixels, x, y, gridSize, width);
                    totalRegions++;
                    
                    if (textureVariance < 200) uniformRegions++;
                    if (textureVariance > 400 && textureVariance < 1000) organicTextures++;
                }
            }
            
            return {
                uniformRegions: uniformRegions / totalRegions,
                organicTextures: organicTextures / totalRegions,
                totalVariance: totalRegions
            };
        }

        function calculateTextureVariance(pixels, startX, startY, size, width) {
            let sum = 0;
            let sumSquares = 0;
            let count = 0;
            
            for (let y = startY; y < startY + size; y++) {
                for (let x = startX; x < startX + size; x++) {
                    const gray = getGrayValue(pixels, y * width + x);
                    sum += gray;
                    sumSquares += gray * gray;
                    count++;
                }
            }
            
            const mean = sum / count;
            const variance = (sumSquares / count) - (mean * mean);
            return variance;
        }

        function analyzeSceneryColors(pixels) {
            let concrete = 0, stone = 0, vegetation = 0, water = 0;
            const totalPixels = pixels.length / 4;
            
            for (let i = 0; i < pixels.length; i += 4) {
                const r = pixels[i];
                const g = pixels[i + 1];
                const b = pixels[i + 2];
                
                // Concrete (cool grays)
                if (Math.abs(r - g) < 15 && Math.abs(g - b) < 15 && r > 90 && r < 180 && b >= g) concrete++;
                
                // Stone (warm grays/browns)
                if (r > g && r > b && (r - b) > 15 && r > 80 && r < 200) stone++;
                
                // Vegetation (greens)
                if (g > r + 15 && g > b + 5 && g > 70) vegetation++;
                
                // Water (blues)
                if (b > r + 20 && b > g + 10 && b > 80) water++;
            }
            
            return {
                concrete: concrete / totalPixels,
                stone: stone / totalPixels,
                vegetation: vegetation / totalPixels,
                water: water / totalPixels
            };
        }

        function analyzeSceneryStructure(pixels, width, height) {
            let verticalLines = 0;
            let horizontalLines = 0;
            let enclosedSpacePixels = 0;
            let weatheredPixels = 0;
            
            // Analyze structural elements
            for (let y = 1; y < height - 1; y += 2) {
                for (let x = 1; x < width - 1; x += 2) {
                    const centerGray = getGrayValue(pixels, y * width + x);
                    const topGray = getGrayValue(pixels, (y-1) * width + x);
                    const bottomGray = getGrayValue(pixels, (y+1) * width + x);
                    const leftGray = getGrayValue(pixels, y * width + (x-1));
                    const rightGray = getGrayValue(pixels, y * width + (x+1));
                    
                    // Vertical line detection
                    if (Math.abs(topGray - bottomGray) < 20 && Math.abs(leftGray - rightGray) > 40) {
                        verticalLines++;
                    }
                    
                    // Horizontal line detection
                    if (Math.abs(leftGray - rightGray) < 20 && Math.abs(topGray - bottomGray) > 40) {
                        horizontalLines++;
                    }
                    
                    // Enclosed space detection (uniform areas)
                    const variance = Math.abs(centerGray - topGray) + Math.abs(centerGray - bottomGray) + 
                                Math.abs(centerGray - leftGray) + Math.abs(centerGray - rightGray);
                    if (variance < 40) enclosedSpacePixels++;
                    
                    // Weathered texture detection (high local variance)
                    if (variance > 80 && variance < 150) weatheredPixels++;
                }
            }
            
            const totalSamples = ((height - 2) / 2) * ((width - 2) / 2);
            
            return {
                verticalLines: verticalLines,
                horizontalLines: horizontalLines,
                enclosedSpace: enclosedSpacePixels / totalSamples,
                weatheredTextures: weatheredPixels / totalSamples
            };
        }

        function analyzeArchitecturalLines(pixels, width, height) {
            let verticalEmphasis = 0;
            let cleanLines = 0;
            let pointedShapes = 0;
            
            // Sample analysis for architectural features
            const sampleSize = Math.min(width, height) / 20;
            
            for (let y = sampleSize; y < height - sampleSize; y += sampleSize) {
                for (let x = sampleSize; x < width - sampleSize; x += sampleSize) {
                    const region = analyzeRegionForArchitecture(pixels, x, y, sampleSize, width);
                    
                    verticalEmphasis += region.vertical;
                    cleanLines += region.clean;
                    pointedShapes += region.pointed;
                }
            }
            
            const totalSamples = Math.floor((height - 2*sampleSize) / sampleSize) * Math.floor((width - 2*sampleSize) / sampleSize);
            
            return {
                verticalEmphasis: verticalEmphasis / totalSamples,
                cleanLines: cleanLines / totalSamples,
                pointedShapes: pointedShapes
            };
        }

        function analyzeRegionForArchitecture(pixels, startX, startY, size, width) {
            let verticalScore = 0;
            let cleanScore = 0;
            let pointedScore = 0;
            
            // Analyze edges in region
            for (let y = startY; y < startY + size; y++) {
                for (let x = startX; x < startX + size; x++) {
                    if (y > 0 && y < startY + size - 1 && x > 0 && x < startX + size - 1) {
                        const centerGray = getGrayValue(pixels, y * width + x);
                        const topGray = getGrayValue(pixels, (y-1) * width + x);
                        const bottomGray = getGrayValue(pixels, (y+1) * width + x);
                        const leftGray = getGrayValue(pixels, y * width + (x-1));
                        const rightGray = getGrayValue(pixels, y * width + (x+1));
                        
                        // Vertical emphasis
                        const verticalGradient = Math.abs(topGray - bottomGray);
                        const horizontalGradient = Math.abs(leftGray - rightGray);
                        if (verticalGradient > horizontalGradient + 10) verticalScore++;
                        
                        // Clean lines (low noise)
                        const noise = Math.abs(centerGray - (topGray + bottomGray + leftGray + rightGray) / 4);
                        if (noise < 15) cleanScore++;
                        
                        // Pointed shapes (diagonal transitions)
                        const diag1 = getGrayValue(pixels, (y-1) * width + (x-1));
                        const diag2 = getGrayValue(pixels, (y-1) * width + (x+1));
                        if (Math.abs(diag1 - diag2) > 50) pointedScore++;
                    }
                }
            }
            
            return {
                vertical: verticalScore / (size * size),
                clean: cleanScore / (size * size),
                pointed: pointedScore > size ? 1 : 0
            };
        }

        function analyzeArchitecturalProportions(width, height) {
            const aspectRatio = width / height;
            
            // Golden ratio and other classical proportions
            const goldenRatio = 1.618;
            const classicalRatios = [1.0, 1.414, goldenRatio, 2.0];
            
            let symmetry = 0.5; // Default symmetry score
            let modernRatios = 0;
            let classicalRatiosScore = 0;
            
            // Check if aspect ratio matches classical proportions
            for (const ratio of classicalRatios) {
                if (Math.abs(aspectRatio - ratio) < 0.1 || Math.abs(aspectRatio - 1/ratio) < 0.1) {
                    classicalRatiosScore = 1;
                    break;
                }
            }
            
            // Modern ratios (very wide or very tall)
            if (aspectRatio > 2.5 || aspectRatio < 0.4) {
                modernRatios = 1;
            }
            
            return {
                symmetry: symmetry,
                modernRatios: modernRatios,
                classicalRatios: classicalRatiosScore,
                aspectRatio: aspectRatio
            };
        }

        function analyzeLightingAdvanced(pixels, width, height) {
            let naturalLight = 0;
            let artificialLight = 0;
            let shadowAreas = 0;
            let highlightAreas = 0;
            let warmTones = 0;
            let coolTones = 0;
            
            const totalPixels = pixels.length / 4;
            
            for (let i = 0; i < pixels.length; i += 4) {
                const r = pixels[i];
                const g = pixels[i + 1];
                const b = pixels[i + 2];
                const brightness = (r + g + b) / 3;
                
                // Natural light detection (balanced color temperature)
                if (Math.abs(r - g) < 30 && Math.abs(g - b) < 30 && brightness > 100) {
                    naturalLight++;
                }
                
                // Artificial light detection (color casts)
                if ((r > g + 20 && r > b + 20) || (b > r + 20 && b > g + 20)) {
                    artificialLight++;
                }
                
                // Shadow areas
                if (brightness < 60) shadowAreas++;
                
                // Highlight areas
                if (brightness > 200) highlightAreas++;
                
                // Color temperature
                if (r > b + 15) warmTones++;
                if (b > r + 15) coolTones++;
            }
            
            return {
                naturalLight: naturalLight / totalPixels,
                artificialLight: artificialLight / totalPixels,
                shadowRatio: shadowAreas / totalPixels,
                highlightRatio: highlightAreas / totalPixels,
                warmTones: warmTones / totalPixels,
                coolTones: coolTones / totalPixels,
                colorTemperature: warmTones > coolTones ? 'warm' : 'cool',
                dynamicRange: (highlightAreas + shadowAreas) / totalPixels
            };
        }

        function analyzeCompositionAdvanced(width, height, pixels) {
            const aspectRatio = width / height;
            const centerX = width / 2;
            const centerY = height / 2;
            
            // Rule of thirds analysis
            const thirdX1 = width / 3;
            const thirdX2 = 2 * width / 3;
            const thirdY1 = height / 3;
            const thirdY2 = 2 * height / 3;
            
            // Analyze interest points along rule of thirds lines
            let ruleOfThirdsScore = 0;
            const interestPoints = findInterestPoints(pixels, width, height);
            
            for (const point of interestPoints) {
                const distToThirdLines = Math.min(
                    Math.abs(point.x - thirdX1),
                    Math.abs(point.x - thirdX2),
                    Math.abs(point.y - thirdY1),
                    Math.abs(point.y - thirdY2)
                );
                
                if (distToThirdLines < Math.min(width, height) / 10) {
                    ruleOfThirdsScore++;
                }
            }
            
            // Leading lines detection
            const leadingLines = detectLeadingLines(pixels, width, height);
            
            // Symmetry analysis
            const symmetryScore = analyzeSymmetry(pixels, width, height);
            
            return {
                aspectRatio: aspectRatio,
                isLandscape: aspectRatio > 1.2,
                isPortrait: aspectRatio < 0.8,
                isSquare: aspectRatio > 0.9 && aspectRatio < 1.1,
                isGoodAspectRatio: (aspectRatio > 1.3 && aspectRatio < 1.8) || (aspectRatio > 0.6 && aspectRatio < 0.8),
                resolution: width * height,
                isHighRes: width * height > 1000000,
                isMediumRes: width * height > 400000,
                dimensions: { width, height },
                ruleOfThirds: Math.min(1, ruleOfThirdsScore / 4),
                leadingLines: leadingLines,
                symmetry: symmetryScore,
                interestPoints: interestPoints.length
            };
        }

        function findInterestPoints(pixels, width, height) {
            const points = [];
            const gridSize = Math.min(width, height) / 20;
            
            for (let y = gridSize; y < height - gridSize; y += gridSize) {
                for (let x = gridSize; x < width - gridSize; x += gridSize) {
                    const contrast = calculateLocalContrast(pixels, x, y, gridSize, width);
                    if (contrast > 500) {
                        points.push({ x, y, contrast });
                    }
                }
            }
            
            return points.sort((a, b) => b.contrast - a.contrast).slice(0, 10);
        }

        function calculateLocalContrast(pixels, centerX, centerY, radius, width) {
            let minGray = 255;
            let maxGray = 0;
            
            for (let dy = -radius; dy <= radius; dy++) {
                for (let dx = -radius; dx <= radius; dx++) {
                    const x = centerX + dx;
                    const y = centerY + dy;
                    if (x >= 0 && x < width && y >= 0) {
                        const gray = getGrayValue(pixels, y * width + x);
                        minGray = Math.min(minGray, gray);
                        maxGray = Math.max(maxGray, gray);
                    }
                }
            }
            
            return maxGray - minGray;
        }

        function detectLeadingLines(pixels, width, height) {
            let diagonalLines = 0;
            let convergingLines = 0;
            
            // Simplified leading line detection
            const step = Math.min(width, height) / 20;
            
            for (let y = step; y < height - step; y += step) {
                for (let x = step; x < width - step; x += step) {
                    const edgeStrength = calculateEdgeStrength(pixels, x, y, width);
                    
                    if (edgeStrength > 100) {
                        // Check for diagonal orientation
                        const orientation = calculateEdgeOrientation(pixels, x, y, width);
                        if (Math.abs(orientation) > 0.3 && Math.abs(orientation) < 0.7) {
                            diagonalLines++;
                        }
                        
                        // Check if lines converge toward center or thirds
                        if (pointsTowardCenter(x, y, width, height) || pointsTowardThirds(x, y, width, height)) {
                            convergingLines++;
                        }
                    }
                }
            }
            
            return {
                diagonal: diagonalLines,
                converging: convergingLines,
                total: diagonalLines + convergingLines
            };
        }

        function calculateEdgeStrength(pixels, x, y, width) {
            const centerGray = getGrayValue(pixels, y * width + x);
            let totalDiff = 0;
            
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (dx !== 0 || dy !== 0) {
                        const neighborGray = getGrayValue(pixels, (y + dy) * width + (x + dx));
                        totalDiff += Math.abs(centerGray - neighborGray);
                    }
                }
            }
            
            return totalDiff;
        }

        function calculateEdgeOrientation(pixels, x, y, width) {
            const sobelX = -getGrayValue(pixels, (y-1) * width + (x-1)) + getGrayValue(pixels, (y-1) * width + (x+1)) +
                        -2*getGrayValue(pixels, y * width + (x-1)) + 2*getGrayValue(pixels, y * width + (x+1)) +
                        -getGrayValue(pixels, (y+1) * width + (x-1)) + getGrayValue(pixels, (y+1) * width + (x+1));
            
            const sobelY = -getGrayValue(pixels, (y-1) * width + (x-1)) - 2*getGrayValue(pixels, (y-1) * width + x) - getGrayValue(pixels, (y-1) * width + (x+1)) +
                        getGrayValue(pixels, (y+1) * width + (x-1)) + 2*getGrayValue(pixels, (y+1) * width + x) + getGrayValue(pixels, (y+1) * width + (x+1));
            
            return Math.atan2(sobelY, sobelX) / Math.PI;
        }

        function pointsTowardCenter(x, y, width, height) {
            const centerX = width / 2;
            const centerY = height / 2;
            const distance = Math.sqrt((x - centerX) * (x - centerX) + (y - centerY) * (y - centerY));
            return distance < Math.min(width, height) / 3;
        }

        function pointsTowardThirds(x, y, width, height) {
            const thirdPoints = [
                { x: width / 3, y: height / 3 },
                { x: 2 * width / 3, y: height / 3 },
                { x: width / 3, y: 2 * height / 3 },
                { x: 2 * width / 3, y: 2 * height / 3 }
            ];
            
            return thirdPoints.some(point => {
                const distance = Math.sqrt((x - point.x) * (x - point.x) + (y - point.y) * (y - point.y));
                return distance < Math.min(width, height) / 6;
            });
        }

        function analyzeSymmetry(pixels, width, height) {
            let horizontalSymmetry = 0;
            let verticalSymmetry = 0;
            const samples = Math.min(width, height) / 10;
            
            // Check horizontal symmetry
            for (let y = 0; y < height; y += samples) {
                for (let x = 0; x < width / 2; x += samples) {
                    const leftGray = getGrayValue(pixels, y * width + x);
                    const rightGray = getGrayValue(pixels, y * width + (width - 1 - x));
                    const diff = Math.abs(leftGray - rightGray);
                    if (diff < 30) horizontalSymmetry++;
                }
            }
            
            // Check vertical symmetry
            for (let x = 0; x < width; x += samples) {
                for (let y = 0; y < height / 2; y += samples) {
                    const topGray = getGrayValue(pixels, y * width + x);
                    const bottomGray = getGrayValue(pixels, (height - 1 - y) * width + x);
                    const diff = Math.abs(topGray - bottomGray);
                    if (diff < 30) verticalSymmetry++;
                }
            }
            
            const maxHorizontalSamples = Math.ceil(height / samples) * Math.ceil(width / (2 * samples));
            const maxVerticalSamples = Math.ceil(width / samples) * Math.ceil(height / (2 * samples));
            
            return {
                horizontal: horizontalSymmetry / maxHorizontalSamples,
                vertical: verticalSymmetry / maxVerticalSamples,
                overall: (horizontalSymmetry / maxHorizontalSamples + verticalSymmetry / maxVerticalSamples) / 2
            };
        }


        function analyzeBrightness(pixels) {
            let totalBrightness = 0;
            let pixelCount = pixels.length / 4;
            
            for (let i = 0; i < pixels.length; i += 4) {
                const r = pixels[i];
                const g = pixels[i + 1];
                const b = pixels[i + 2];
                // Calculate luminance
                const brightness = (0.299 * r + 0.587 * g + 0.114 * b);
                totalBrightness += brightness;
            }
            
            const averageBrightness = totalBrightness / pixelCount;
            
            return {
                average: averageBrightness,
                isWellExposed: averageBrightness > 50 && averageBrightness < 200,
                isDark: averageBrightness < 80,
                isBright: averageBrightness > 180,
                isOptimal: averageBrightness > 100 && averageBrightness < 160
            };
        }

        function analyzeContrast(pixels) {
            let min = 255, max = 0;
            let histogram = new Array(256).fill(0);
            
            for (let i = 0; i < pixels.length; i += 4) {
                const r = pixels[i];
                const g = pixels[i + 1];
                const b = pixels[i + 2];
                const gray = Math.round(0.299 * r + 0.587 * g + 0.114 * b);
                
                histogram[gray]++;
                min = Math.min(min, gray);
                max = Math.max(max, gray);
            }
            
            const contrast = max - min;
            
            return {
                range: contrast,
                min: min,
                max: max,
                isGoodContrast: contrast > 100 && contrast < 240,
                isLowContrast: contrast < 80,
                isHighContrast: contrast > 200,
                histogram: histogram
            };
        }

        function analyzeSharpness(imageData, width, height) {
            const pixels = imageData.data;
            let sharpnessSum = 0;
            let edgeCount = 0;
            
            // Simple edge detection using Sobel operator
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const idx = (y * width + x) * 4;
                    
                    // Get surrounding pixels
                    const tl = getGrayValue(pixels, (y-1) * width + (x-1));
                    const tm = getGrayValue(pixels, (y-1) * width + x);
                    const tr = getGrayValue(pixels, (y-1) * width + (x+1));
                    const ml = getGrayValue(pixels, y * width + (x-1));
                    const mr = getGrayValue(pixels, y * width + (x+1));
                    const bl = getGrayValue(pixels, (y+1) * width + (x-1));
                    const bm = getGrayValue(pixels, (y+1) * width + x);
                    const br = getGrayValue(pixels, (y+1) * width + (x+1));
                    
                    // Sobel operators
                    const sobelX = (tr + 2*mr + br) - (tl + 2*ml + bl);
                    const sobelY = (bl + 2*bm + br) - (tl + 2*tm + tr);
                    
                    const magnitude = Math.sqrt(sobelX * sobelX + sobelY * sobelY);
                    
                    if (magnitude > 30) { // Edge threshold
                        sharpnessSum += magnitude;
                        edgeCount++;
                    }
                }
            }
            
            const averageSharpness = edgeCount > 0 ? sharpnessSum / edgeCount : 0;
            
            return {
                score: averageSharpness,
                edgeCount: edgeCount,
                isSharp: averageSharpness > 50,
                isBlurry: averageSharpness < 25,
                isOptimal: averageSharpness > 40 && averageSharpness < 120
            };
        }

        function getGrayValue(pixels, index) {
            const i = index * 4;
            return Math.round(0.299 * pixels[i] + 0.587 * pixels[i+1] + 0.114 * pixels[i+2]);
        }

        function analyzeComposition(width, height) {
            const aspectRatio = width / height;
            
            return {
                aspectRatio: aspectRatio,
                isLandscape: aspectRatio > 1.2,
                isPortrait: aspectRatio < 0.8,
                isSquare: aspectRatio > 0.9 && aspectRatio < 1.1,
                isGoodAspectRatio: (aspectRatio > 1.3 && aspectRatio < 1.8) || (aspectRatio > 0.6 && aspectRatio < 0.8),
                resolution: width * height,
                isHighRes: width * height > 500000,
                isMediumRes: width * height > 200000,
                dimensions: { width, height }
            };
        }

        function analyzeColors(pixels) {
            let colorfulness = 0;
            let uniqueColors = new Set();
            let warmColors = 0;
            let coolColors = 0;
            let totalPixels = pixels.length / 4;
            
            for (let i = 0; i < pixels.length; i += 4) {
                const r = pixels[i];
                const g = pixels[i + 1];
                const b = pixels[i + 2];
                
                // Color diversity (simplified)
                const colorKey = `${Math.floor(r/16)}-${Math.floor(g/16)}-${Math.floor(b/16)}`;
                uniqueColors.add(colorKey);
                
                // Colorfulness calculation
                colorfulness += Math.sqrt((r-g)*(r-g) + (r-b)*(r-b) + (g-b)*(g-b));
                
                // Warm vs cool colors
                if (r > g && r > b) warmColors++;
                if (b > r && b > g) coolColors++;
            }
            
            const averageColorfulness = colorfulness / totalPixels;
            const colorDiversity = uniqueColors.size;
            
            return {
                colorfulness: averageColorfulness,
                diversity: colorDiversity,
                warmCoolRatio: warmColors / Math.max(coolColors, 1),
                isColorful: averageColorfulness > 50,
                isDiverse: colorDiversity > 100,
                hasGoodBalance: Math.abs(warmColors - coolColors) / totalPixels < 0.3
            };
        }

        function analyzeFaces(imageData, width, height) {
            const pixels = imageData.data;
            let totalPixels = pixels.length / 4;
            
            // Enhanced face detection with multiple methods
            const skinToneAnalysis = detectSkinTones(pixels, totalPixels, width, height);
            skinToneAnalysis.width = width;
            skinToneAnalysis.height = height;
            const faceRegions = detectFaceRegions(pixels, width, height);
            const smileAnalysis = detectSmiles(pixels, width, height, faceRegions);
            
            // Ultra-konservative Personen-Sch√§tzung
            let estimatedPeopleCount = 0;

            // Sehr hohe Schwellenwerte
            if (skinToneAnalysis.skinToneRatio > 0.05) {
                // Gewichte face regions am h√∂chsten (vertrauensw√ºrdigster Indikator)
                const faceBasedEstimate = faceRegions.length;
                const clusterBasedEstimate = Math.floor(skinToneAnalysis.clusters * 0.4); // Stark reduziert
                const ratioBasedEstimate = Math.floor(skinToneAnalysis.skinToneRatio * 5); // Stark reduziert
                
                estimatedPeopleCount = Math.max(faceBasedEstimate, clusterBasedEstimate, ratioBasedEstimate);
            }

            // Portrait-spezifische Logik
            const imageAspectRatio = width / height;
            const isPortraitAspect = imageAspectRatio > 0.6 && imageAspectRatio < 1.4;

            if (isPortraitAspect && skinToneAnalysis.skinToneRatio < 0.2) {
                // Portrait-Format mit wenig Skin = wahrscheinlich 1 Person
                estimatedPeopleCount = Math.min(estimatedPeopleCount, 1);
            }

            // Absolute Obergrenze basierend auf Skin-Ratio
            if (skinToneAnalysis.skinToneRatio < 0.1) {
                estimatedPeopleCount = Math.min(estimatedPeopleCount, 1);
            } else if (skinToneAnalysis.skinToneRatio < 0.2) {
                estimatedPeopleCount = Math.min(estimatedPeopleCount, 2);
            } else {
                estimatedPeopleCount = Math.min(estimatedPeopleCount, 3);
            }
            
            // Estimate smiling people
            const estimatedSmilingPeople = Math.min(smileAnalysis.smilingRegions, estimatedPeopleCount);
            
            return {
                likelyHasPeople: skinToneAnalysis.skinToneRatio > 0.015 || faceRegions.length > 0,
                skinToneRatio: skinToneAnalysis.skinToneRatio,
                estimatedPeopleCount: estimatedPeopleCount,
                estimatedSmilingPeople: estimatedSmilingPeople,
                faceRegions: faceRegions,
                skinToneClusters: skinToneAnalysis.clusters,
                smileConfidence: smileAnalysis.confidence,
                skinToneAnalysis: skinToneAnalysis,
                detectionDetails: {
                    skinTonePixels: skinToneAnalysis.pixels,
                    faceRegionsFound: faceRegions.length,
                    smileRegionsFound: smileAnalysis.smilingRegions
                }
            };
        }

        function mergeNearbyRegions(regions, gridSize, width, height) {
            if (regions.length <= 1) return regions.length;
            
            // F√ºr Portraits: Wenn mehrere Cluster sehr nahe beieinander sind, 
            // handelt es sich wahrscheinlich um Teile desselben Gesichts
            
            const imageArea = width * height;
            const skinArea = regions.reduce((sum, region) => sum + region, 0);
            const skinRatio = skinArea / imageArea;
            
            // Wenn wenig Skin-Anteil aber mehrere Cluster -> wahrscheinlich 1 Person
            if (skinRatio < 0.15 && regions.length > 1) {
                return 1; // Ein fragmentiertes Gesicht
            }
            
            // Wenn moderate Skin-Menge -> maximal 2 Personen auch bei vielen Clustern
            if (skinRatio < 0.25 && regions.length > 2) {
                return Math.min(2, Math.ceil(regions.length / 3));
            }
            
            // Ansonsten: Reduziere Cluster-Anzahl um Fragmentierung
            return Math.ceil(regions.length * 0.6);
        }

        function detectSkinTones(pixels, totalPixels, width, height) {
            let skinTonePixels = 0;
            let skinToneRegions = [];
            let clusters = 0;
            
            // Track different skin tone ranges separately for diversity
            let lightSkinPixels = 0;
            let mediumSkinPixels = 0;
            let darkSkinPixels = 0;
            let veryDarkSkinPixels = 0;
            
            // Gr√∂√üeres Grid f√ºr weniger fragmentierte Cluster
            const gridSize = 40; // Doppelt so gro√ü
            const gridWidth = Math.ceil(width / gridSize);
            const gridHeight = Math.ceil(height / gridSize);
            const skinGrid = Array(gridHeight).fill().map(() => Array(gridWidth).fill(0));
            
            // First pass: detect all skin tones and categorize them
            for (let i = 0; i < pixels.length; i += 4) {
                const r = pixels[i];
                const g = pixels[i + 1];
                const b = pixels[i + 2];
                
                if (detectSkinTone(r, g, b)) {
                    skinTonePixels++;
                    
                    // Categorize skin tone brightness for diversity tracking
                    const brightness = (r + g + b) / 3;
                    if (brightness > 150) lightSkinPixels++;
                    else if (brightness > 100) mediumSkinPixels++;
                    else if (brightness > 60) darkSkinPixels++;
                    else veryDarkSkinPixels++;
                    
                    // Mark in spatial grid
                    const pixelIndex = Math.floor(i / 4);
                    const x = pixelIndex % width;
                    const y = Math.floor(pixelIndex / width);
                    const gridX = Math.floor(x / gridSize);
                    const gridY = Math.floor(y / gridSize);
                    
                    if (gridX < gridWidth && gridY < gridHeight) {
                        skinGrid[gridY][gridX]++;
                    }
                }
            }
            
            // Second pass: find connected regions (clusters)
            const visited = Array(gridHeight).fill().map(() => Array(gridWidth).fill(false));
            const minRegionSize = 35; // Noch viel gr√∂√üer - ein Gesicht muss wirklich gro√ü sein
            
            for (let y = 0; y < gridHeight; y++) {
                for (let x = 0; x < gridWidth; x++) {
                    if (skinGrid[y][x] > 50 && !visited[y][x]) { // Sehr hoher Threshold - nur dichte Skin-Bereiche
                        const regionSize = floodFillRegion(skinGrid, visited, x, y, gridWidth, gridHeight);
                        if (regionSize >= minRegionSize) {
                            skinToneRegions.push(regionSize * gridSize * gridSize); // Convert back to pixels
                            clusters++;
                        }
                    }
                }
            }

            // NEUE Cluster-Merge-Logik: Nahe beieinander liegende Cluster zusammenfassen
            clusters = mergeNearbyRegions(skinToneRegions, gridSize, width, height);
            
            // Calculate diversity metrics
            const diversityScore = calculateSkinToneDiversity(lightSkinPixels, mediumSkinPixels, darkSkinPixels, veryDarkSkinPixels);
            
            return {
                pixels: skinTonePixels,
                skinToneRatio: skinTonePixels / totalPixels,
                clusters: clusters,
                regions: skinToneRegions,
                diversity: diversityScore,
                breakdown: {
                    light: lightSkinPixels,
                    medium: mediumSkinPixels,
                    dark: darkSkinPixels,
                    veryDark: veryDarkSkinPixels
                }
            };
        }

        function floodFillRegion(grid, visited, startX, startY, width, height) {
            const stack = [[startX, startY]];
            let regionSize = 0;
            
            while (stack.length > 0) {
                const [x, y] = stack.pop();
                
                if (x < 0 || x >= width || y < 0 || y >= height || visited[y][x] || grid[y][x] <= 10) {
                    continue;
                }
                
                visited[y][x] = true;
                regionSize++;
                
                // Add neighbors
                stack.push([x + 1, y], [x - 1, y], [x, y + 1], [x, y - 1]);
            }
            
            return regionSize;
        }

        function calculateSkinToneDiversity(light, medium, dark, veryDark) {
            const total = light + medium + dark + veryDark;
            if (total === 0) return 0;
            
            // Calculate how evenly distributed the skin tones are
            const ratios = [light/total, medium/total, dark/total, veryDark/total];
            const nonZeroRatios = ratios.filter(r => r > 0);
            
            // Shannon diversity index adapted for skin tones
            let diversity = 0;
            for (const ratio of nonZeroRatios) {
                if (ratio > 0) {
                    diversity -= ratio * Math.log2(ratio);
                }
            }
            
            return {
                score: diversity,
                categories: nonZeroRatios.length,
                isInclusive: nonZeroRatios.length > 1, // Multiple skin tones detected
                distribution: { light, medium, dark, veryDark }
            };
        }

        function detectSkinTone(r, g, b) {
            // STRIKTE skin tone detection f√ºr bessere Genauigkeit
            
            // Basis-Filter: Mindest-Helligkeit und Farbbalance
            if (r < 50 || g < 30 || b < 20) return false;
            if (r > 250 || g > 230 || b > 200) return false; // Zu hell
            
            // Method 1: Klassische Skin-Tone-Ranges (restriktiver)
            const lightSkin = r > 120 && g > 80 && b > 60 && 
                            r > g && r > b && 
                            (r - g) > 20 && (r - b) > 30 &&
                            Math.abs(r - g) < 50;
            
            // Method 2: Medium Skin Tones (spezifischer)
            const mediumSkin = r > 80 && g > 50 && b > 30 && r < 180 && g < 140 && b < 100 &&
                            r > g && r > b && 
                            (r - g) > 10 && (r - b) > 15 &&
                            (r - g) < 40;
            
            // Method 3: Dark Skin Tones (pr√§ziser)
            const darkSkin = r > 60 && g > 40 && b > 25 && r < 130 && g < 100 && b < 70 &&
                            (r - b) > 15 && (g - b) > 10 && r >= g;
            
            // Method 4: YCbCr color space (engere Ranges)
            const y = 0.299 * r + 0.587 * g + 0.114 * b;
            const cb = -0.169 * r - 0.331 * g + 0.5 * b + 128;
            const cr = 0.5 * r - 0.419 * g - 0.081 * b + 128;
            
            const ycbcrSkin = y > 60 && y < 200 && 
                            cb >= 85 && cb <= 125 && 
                            cr >= 135 && cr <= 165;
            
            // Method 5: RGB-Ratio basiert (restriktiver)
            const ratioSkin = (r > b * 1.25) && (g > b * 1.15) && 
                            (Math.abs(r - g) < r * 0.3) &&
                            r > 60 && g > 45 && b > 25;
            
            // Mindestens 2 Methoden m√ºssen zustimmen
            const methodCount = [lightSkin, mediumSkin, darkSkin, ycbcrSkin, ratioSkin].filter(Boolean).length;
            
            return methodCount >= 2;
        }

        function detectFaceRegions(pixels, width, height) {
            const faceRegions = [];
            const minFaceSize = Math.min(width, height) / 10; // Minimum face size
            const maxFaceSize = Math.min(width, height) / 3;  // Maximum face size
            
            // Simple face detection using skin tone clustering and geometric analysis
            for (let y = 0; y < height - minFaceSize; y += Math.floor(minFaceSize / 2)) {
                for (let x = 0; x < width - minFaceSize; x += Math.floor(minFaceSize / 2)) {
                    
                    // Check different face sizes
                    for (let size = minFaceSize; size <= maxFaceSize; size += Math.floor(minFaceSize / 2)) {
                        if (x + size >= width || y + size >= height) continue;
                        
                        const region = analyzeRegionForFace(pixels, x, y, size, width, height);
                        
                        if (region.isFace) {
                            // Check if this region overlaps with existing faces
                            const overlaps = faceRegions.some(existing => 
                                Math.abs(existing.x - x) < size/2 && Math.abs(existing.y - y) < size/2
                            );
                            
                            if (!overlaps) {
                                faceRegions.push({
                                    x: x,
                                    y: y,
                                    size: size,
                                    confidence: region.confidence,
                                    skinToneRatio: region.skinToneRatio
                                });
                            }
                        }
                    }
                }
            }
            
            // Sort by confidence and return top candidates
            return faceRegions.sort((a, b) => b.confidence - a.confidence).slice(0, 6);
        }

        function analyzeRegionForFace(pixels, startX, startY, size, width, height) {
            let skinPixels = 0;
            let totalPixels = 0;
            let verticalVariation = 0;
            let horizontalVariation = 0;
            
            // Analyze the region
            for (let y = startY; y < startY + size && y < height; y++) {
                let rowSkinPixels = 0;
                for (let x = startX; x < startX + size && x < width; x++) {
                    const idx = (y * width + x) * 4;
                    const r = pixels[idx];
                    const g = pixels[idx + 1];
                    const b = pixels[idx + 2];
                    
                    if (detectSkinTone(r, g, b)) {
                        skinPixels++;
                        rowSkinPixels++;
                    }
                    totalPixels++;
                }
                
                // Check for face-like distribution (more skin in middle rows)
                const relativeY = (y - startY) / size;
                if (relativeY > 0.2 && relativeY < 0.8) {
                    verticalVariation += rowSkinPixels;
                }
            }
            
            const skinRatio = skinPixels / totalPixels;
            
            // Face criteria: Viel strenger - 20-45% skin tone, bessere Verteilung
            const isFace = skinRatio > 0.20 && skinRatio < 0.45 && 
                        verticalVariation > skinPixels * 0.4 &&
                        skinPixels > (size * size * 0.15); // Mindest-Pixelanzahl
            const confidence = isFace ? skinRatio * (verticalVariation / skinPixels) * 0.7 : 0; // Reduzierte Confidence
            
            return {
                isFace: isFace,
                confidence: confidence,
                skinToneRatio: skinRatio
            };
        }

        function detectSmiles(pixels, width, height, faceRegions) {
            let smilingRegions = 0;
            let totalConfidence = 0;
            
            // Analyze each detected face region for smiles
            for (const face of faceRegions) {
                const smileAnalysis = analyzeRegionForSmile(pixels, face, width, height);
                if (smileAnalysis.isSmiling) {
                    smilingRegions++;
                    totalConfidence += smileAnalysis.confidence;
                }
            }
            
            // Also do general smile detection if no faces were found
            if (faceRegions.length === 0) {
                const generalSmileAnalysis = detectGeneralSmiles(pixels, width, height);
                smilingRegions = generalSmileAnalysis.estimatedSmiles;
                totalConfidence = generalSmileAnalysis.confidence;
            }
            
            return {
                smilingRegions: smilingRegions,
                confidence: faceRegions.length > 0 ? totalConfidence / Math.max(faceRegions.length, 1) : totalConfidence
            };
        }

        function analyzeRegionForSmile(pixels, face, width, height) {
            const { x, y, size } = face;
            
            // Focus on lower half of face for smile detection
            const mouthY = y + Math.floor(size * 0.6);
            const mouthHeight = Math.floor(size * 0.3);
            
            let horizontalEdges = 0;
            let curvedEdges = 0;
            let brightnessVariation = 0;
            
            // Analyze mouth region
            for (let py = mouthY; py < mouthY + mouthHeight && py < height; py++) {
                let prevBrightness = 0;
                for (let px = x; px < x + size && px < width; px++) {
                    const idx = (py * width + px) * 4;
                    const r = pixels[idx];
                    const g = pixels[idx + 1];
                    const b = pixels[idx + 2];
                    const brightness = (r + g + b) / 3;
                    
                    // Look for horizontal edges (typical of smiles)
                    if (px > x) {
                        const brightnessChange = Math.abs(brightness - prevBrightness);
                        if (brightnessChange > 30) {
                            horizontalEdges++;
                        }
                        brightnessVariation += brightnessChange;
                    }
                    prevBrightness = brightness;
                }
            }
            
            // Smile indicators: moderate horizontal edge activity, brightness variation
            const normalizedEdges = horizontalEdges / (size * mouthHeight);
            const normalizedVariation = brightnessVariation / (size * mouthHeight);
            
            const isSmiling = normalizedEdges > 0.1 && normalizedEdges < 0.4 && normalizedVariation > 15;
            const confidence = isSmiling ? (normalizedEdges + normalizedVariation / 50) / 2 : 0;
            
            return {
                isSmiling: isSmiling,
                confidence: Math.min(confidence, 1.0)
            };
        }

        function detectGeneralSmiles(pixels, width, height) {
            // General smile detection when no specific faces are found
            let smileIndicators = 0;
            let totalChecks = 0;
            
            // Sample regions across the image for smile-like patterns
            const sampleSize = Math.min(width, height) / 8;
            
            for (let y = 0; y < height - sampleSize; y += sampleSize) {
                for (let x = 0; x < width - sampleSize; x += sampleSize) {
                    const regionAnalysis = analyzeSmallRegionForSmile(pixels, x, y, sampleSize, width, height);
                    if (regionAnalysis.hasSmilePattern) {
                        smileIndicators++;
                    }
                    totalChecks++;
                }
            }
            
            const smileRatio = smileIndicators / totalChecks;
            const estimatedSmiles = Math.floor(smileRatio * 8); // Conservative estimate
            
            return {
                estimatedSmiles: Math.min(estimatedSmiles, 4),
                confidence: smileRatio
            };
        }

        function analyzeSmallRegionForSmile(pixels, startX, startY, size, width, height) {
            let horizontalPatterns = 0;
            let totalPixels = 0;
            
            for (let y = startY; y < startY + size && y < height; y++) {
                let rowChanges = 0;
                let prevBrightness = 0;
                
                for (let x = startX; x < startX + size && x < width; x++) {
                    const idx = (y * width + x) * 4;
                    const r = pixels[idx];
                    const g = pixels[idx + 1];
                    const b = pixels[idx + 2];
                    const brightness = (r + g + b) / 3;
                    
                    if (x > startX) {
                        if (Math.abs(brightness - prevBrightness) > 25) {
                            rowChanges++;
                        }
                    }
                    prevBrightness = brightness;
                    totalPixels++;
                }
                
                // Look for moderate horizontal activity (smile-like)
                if (rowChanges > 2 && rowChanges < size / 3) {
                    horizontalPatterns++;
                }
            }
            
            return {
                hasSmilePattern: horizontalPatterns > size / 4
            };
        }

        // Enhanced scoring functions
        function calculateTechnicalScoreAdvanced(brightness, contrast, sharpness, lighting) {
            let score = 40; // Base score
            
            // Brightness scoring (enhanced)
            if (brightness.isOptimal) score += 25;
            else if (brightness.isWellExposed) score += 20;
            else if (brightness.hasGoodDistribution) score += 15;
            else if (brightness.isDark || brightness.isBright) score += 8;
            else score += 5;
            
            // Contrast scoring (enhanced)
            if (contrast.isGoodContrast && contrast.hasGoodLocalContrast) score += 25;
            else if (contrast.isGoodContrast || contrast.hasGoodLocalContrast) score += 18;
            else if (contrast.isLowContrast) score += 8;
            else if (contrast.isHighContrast) score += 12;
            else score += 10;
            
            // Sharpness scoring (enhanced)
            if (sharpness.isOptimal) score += 30;
            else if (sharpness.isSharp) score += 25;
            else if (sharpness.qualityLevel === 'good') score += 18;
            else if (sharpness.qualityLevel === 'fair') score += 12;
            else score += 6;
            
            // Lighting quality bonus
            if (lighting.naturalLight > 0.6 && lighting.dynamicRange > 0.3) score += 10;
            else if (lighting.naturalLight > 0.4) score += 5;
            
            // Dynamic range bonus
            if (brightness.dynamicRange > 150) score += 5;
            
            return Math.max(30, Math.min(100, score));
        }

        function calculateCompositionScoreAdvanced(composition, architecture, width, height) {
            let score = 40; // Base score
            
            // Aspect ratio scoring (enhanced)
            if (composition.isGoodAspectRatio) score += 20;
            else if (composition.isLandscape || composition.isPortrait) score += 15;
            else if (composition.isSquare) score += 12;
            else score += 8;
            
            // Resolution scoring
            if (composition.isHighRes) score += 15;
            else if (composition.isMediumRes) score += 12;
            else score += 8;
            
            // Rule of thirds bonus
            if (composition.ruleOfThirds > 0.6) score += 15;
            else if (composition.ruleOfThirds > 0.3) score += 10;
            else if (composition.ruleOfThirds > 0.1) score += 5;
            
            // Leading lines bonus
            if (composition.leadingLines.total > 3) score += 12;
            else if (composition.leadingLines.total > 1) score += 8;
            
            // Symmetry bonus
            if (composition.symmetry.overall > 0.7) score += 10;
            else if (composition.symmetry.overall > 0.4) score += 6;
            
            // Architecture bonus
            if (architecture.hasArchitecture) {
                score += 8;
                if (architecture.dominantStyle === 'gothic' || architecture.dominantStyle === 'classical') {
                    score += 5; // Bonus for historical architecture
                }
            }
            
            // Interest points bonus
            if (composition.interestPoints > 5) score += 8;
            else if (composition.interestPoints > 2) score += 5;
            
            return Math.max(30, Math.min(100, score));
        }

        function calculateCreativityScoreAdvanced(colors, faces, objects, scenery, stationId) {
            let score = 35; // Base score
            
            // Color scoring (enhanced)
            if (colors.isColorful && colors.isDiverse) score += 18;
            else if (colors.isColorful || colors.isDiverse) score += 12;
            else score += 6;
            
            // Color balance bonus
            if (colors.hasGoodBalance) score += 8;
            
            // People scoring - MAJOR enhancement with detailed recognition!
            if (faces.likelyHasPeople) {
                score += 15; // Base bonus for having people
                
                const peopleCount = faces.estimatedPeopleCount;
                
                // Progressive bonus for more people
                if (peopleCount >= 2) score += 10;  // 2 people: +10
                if (peopleCount >= 3) score += 8;   // 3 people: +8 more
                if (peopleCount >= 4) score += 6;   // 4 people: +6 more
                if (peopleCount >= 5) score += 5;   // 5+ people: +5 more
                
                // Smile bonus - Enhanced!
                const smilingPeople = faces.estimatedSmilingPeople;
                if (smilingPeople > 0) {
                    score += smilingPeople * 6; // 6 points per smiling person
                    
                    // Group happiness bonus
                    const smileRatio = smilingPeople / peopleCount;
                    if (smileRatio >= 0.8 && peopleCount > 1) {
                        score += 12; // "Everyone's happy" bonus
                    } else if (smileRatio >= 0.6 && peopleCount > 2) {
                        score += 8; // "Most people happy" bonus
                    }
                }
                
                // Diversity bonus if multiple skin tones detected
                if (faces.skinToneAnalysis.diversity.isInclusive) {
                    score += 8; // Inclusion bonus
                }
                
                // Large group special bonus
                if (peopleCount >= 6) {
                    score += 10; // "Big group photo" achievement
                }
            } else {
                // Solo photo or no people detected
                score += 5; // Small consolation bonus
            }
            
            // Object recognition bonus
            if (objects.totalObjects > 0) {
                score += Math.min(10, objects.totalObjects * 2);
                
                // Specific object bonuses
                if (objects.detected.buildings > 0) score += 5; // Architecture bonus
                if (objects.detected.nature > 0) score += 4;    // Nature integration
                if (objects.detected.vehicles > 0) score += 2;  // Urban life
            }
            
            // Scenery integration bonus
            if (scenery.isOutdoor) {
                score += 8; // Outdoor exploration bonus
                
                if (scenery.dominantScenery === 'historic') score += 8; // Historical significance
                else if (scenery.dominantScenery === 'urban') score += 6; // City exploration
                else if (scenery.dominantScenery === 'park') score += 5; // Nature appreciation
                else if (scenery.dominantScenery === 'waterfront') score += 7; // Scenic location
            } else {
                score += 3; // Indoor photos get minimal bonus
            }
            
            // Station-specific creativity bonuses (enhanced)
            const station = tourApp.stations.find(s => s.id === stationId);
            if (station) {
                if (station.title.includes('Dom') && faces.estimatedPeopleCount > 1) score += 8;
                if (station.title.includes('Heumarkt') && faces.estimatedSmilingPeople > 0) score += 6;
                if (station.title.includes('Altstadt') && objects.detected.buildings > 0) score += 5;
                if (station.title.includes('Martin') && scenery.dominantScenery === 'historic') score += 7;
            }
            
            // Quality enhancement bonus
            if (faces.estimatedPeopleCount > 0 && objects.totalObjects > 0 && scenery.isOutdoor) {
                score += 8; // "Complete scene" bonus
            }
            
            // Random creative factor (reduced for more predictability)
            score += Math.random() * 3;
            
            return Math.max(25, Math.min(100, score));
        }

        // Enhanced comprehensive feedback generation
        function generateComprehensiveFeedback(technicalScore, compositionScore, creativityScore, analysis) {
            const feedback = [];
            
            // Recognition summary first
            feedback.push(`üîç **Erkannte Bildinhalte:**`);
            const recognitionResults = generateRecognitionSummary(analysis);
            recognitionResults.forEach(result => feedback.push(`   ‚Ä¢ ${result}`));
            
            feedback.push(``); // Empty line for separation
            
            // Technical feedback (enhanced)
            if (technicalScore > 85) {
                feedback.push("üì∏ **Hervorragende technische Qualit√§t!**");
            } else if (technicalScore > 70) {
                feedback.push("‚úÖ **Sehr gute technische Umsetzung**");
            } else if (technicalScore > 55) {
                feedback.push("üì± **Solide technische Qualit√§t**");
            } else {
                feedback.push("‚ö†Ô∏è **Technische Qualit√§t k√∂nnte verbessert werden**");
            }
            
            // Specific technical details
            if (analysis.brightness.isOptimal) {
                feedback.push("   ‚Ä¢ Perfekte Belichtung und Helligkeitsverteilung!");
            } else if (analysis.brightness.isDark) {
                feedback.push("   ‚Ä¢ Bild ist etwas unterbelichtet - mehr Licht w√§re hilfreich");
            } else if (analysis.brightness.isBright) {
                feedback.push("   ‚Ä¢ Bild ist √ºberbelichtet - weniger Belichtung empfohlen");
            }
            
            if (analysis.sharpness.qualityLevel === 'excellent') {
                feedback.push("   ‚Ä¢ Exzellente Bildsch√§rfe und Details!");
            } else if (analysis.sharpness.isBlurry) {
                feedback.push("   ‚Ä¢ Bild wirkt unscharf - stabilere Kamera oder besserer Fokus");
            }
            
            if (analysis.lighting.naturalLight > 0.6) {
                feedback.push("   ‚Ä¢ Sehr gutes nat√ºrliches Licht!");
            } else if (analysis.lighting.artificialLight > 0.5) {
                feedback.push("   ‚Ä¢ K√ºnstliche Beleuchtung erkannt");
            }
            
            // Composition feedback (enhanced)
            if (compositionScore > 80) {
                feedback.push("üé® **Ausgezeichnete Bildkomposition!**");
            } else if (compositionScore > 65) {
                feedback.push("üìê **Sehr gute Bildgestaltung**");
            } else if (compositionScore > 50) {
                feedback.push("üñºÔ∏è **Solide Bildaufteilung**");
            } else {
                feedback.push("üí° **Bildkomposition kann verbessert werden**");
            }
            
            // Composition details
            if (analysis.composition.ruleOfThirds > 0.5) {
                feedback.push("   ‚Ä¢ Excellente Nutzung der Drittel-Regel!");
            } else if (analysis.composition.ruleOfThirds > 0.2) {
                feedback.push("   ‚Ä¢ Gute Anwendung kompositorischer Prinzipien");
            }
            
            if (analysis.composition.leadingLines.total > 2) {
                feedback.push("   ‚Ä¢ Starke f√ºhrende Linien erkannt!");
            }
            
            if (analysis.composition.symmetry.overall > 0.6) {
                feedback.push("   ‚Ä¢ Sch√∂ne symmetrische Komposition!");
            }
            
            // Architecture feedback
            if (analysis.architecture.hasArchitecture) {
                const styleNames = {
                    gothic: 'Gotische',
                    modern: 'Moderne',
                    classical: 'Klassische',
                    industrial: 'Industrielle'
                };
                const styleName = styleNames[analysis.architecture.dominantStyle] || 'Interessante';
                feedback.push(`   ‚Ä¢ ${styleName} Architektur erfasst!`);
            }
            
            // Creativity feedback (enhanced)
            if (creativityScore > 85) {
                feedback.push("‚ú® **Au√üergew√∂hnlich kreative und lebendige Aufnahme!**");
            } else if (creativityScore > 70) {
                feedback.push("üé≠ **Sehr kreative und originelle Aufnahme!**");
            } else if (creativityScore > 55) {
                feedback.push("üåü **Sch√∂ne kreative Elemente!**");
            } else {
                feedback.push("üì± **Guter Ansatz - mehr Kreativit√§t m√∂glich**");
            }
            
            // Enhanced people and smile feedback
            if (analysis.faces.likelyHasPeople) {
                const peopleCount = analysis.faces.estimatedPeopleCount;
                const smilingCount = analysis.faces.estimatedSmilingPeople;
                
                // People count feedback
                if (peopleCount === 1) {
                    feedback.push("   ‚Ä¢ üë§ Eine Person im Bild erkannt!");
                } else if (peopleCount <= 3) {
                    feedback.push(`   ‚Ä¢ üë• ${peopleCount} Personen erkannt - tolle Teamarbeit!`);
                } else if (peopleCount <= 5) {
                    feedback.push(`   ‚Ä¢ üë®‚Äçüë©‚Äçüëß‚Äçüë¶ ${peopleCount} Personen im Bild - super Gruppenfoto!`);
                } else {
                    feedback.push(`   ‚Ä¢ üéâ Wow! ${peopleCount} Personen erkannt - fantastisches Gruppenbild!`);
                }
                
                // Smile feedback with detailed analysis
                if (smilingCount > 0) {
                    if (smilingCount === 1) {
                        feedback.push("   ‚Ä¢ üòä Eine l√§chelnde Person erkannt - strahlendes L√§cheln!");
                    } else if (smilingCount === peopleCount && peopleCount > 1) {
                        feedback.push(`   ‚Ä¢ üòÑ Alle ${smilingCount} Personen l√§cheln - perfekte Gruppenstimmung!`);
                    } else {
                        feedback.push(`   ‚Ä¢ üòÉ ${smilingCount} l√§chelnde Person${smilingCount > 1 ? 'en' : ''} erkannt - tolle Stimmung!`);
                    }
                    
                    // Smile bonus calculation
                    const smileBonus = smilingCount * 6;
                    feedback.push(`   ‚Ä¢ ‚ú® L√§chel-Bonus: +${smileBonus} Punkte!`);
                }
                
                // People count bonus calculation
                let peopleBonus = 15; // Base bonus
                if (peopleCount >= 2) peopleBonus += 10;
                if (peopleCount >= 3) peopleBonus += 8;
                if (peopleCount >= 4) peopleBonus += 6;
                if (peopleCount >= 5) peopleBonus += 5;
                
                feedback.push(`   ‚Ä¢ üë• Personen-Bonus: +${peopleBonus} Punkte!`);
                
                // Diversity bonus
                if (analysis.faces.skinToneAnalysis && analysis.faces.skinToneAnalysis.diversity.isInclusive) {
                    feedback.push("   ‚Ä¢ üåç Vielfalt erkannt - Inklusions-Bonus: +8 Punkte!");
                }
                
                // Special achievements
                if (peopleCount >= 6 && smilingCount >= 4) {
                    feedback.push("   ‚Ä¢ üèÜ **Spezial-Achievement: 'Gl√ºckliche Gro√ügruppe' erreicht!**");
                } else if (peopleCount >= 3 && smilingCount === peopleCount) {
                    feedback.push("   ‚Ä¢ üåü **Spezial-Achievement: 'Perfekte Teamharmonie' erreicht!**");
                } else if (peopleCount >= 5) {
                    feedback.push("   ‚Ä¢ üéä **Spezial-Achievement: 'Gro√ügruppen-Foto' erreicht!**");
                }
                
                // Detailed recognition info
                if (analysis.faces.skinToneAnalysis) {
                    const skinAnalysis = analysis.faces.skinToneAnalysis;
                    feedback.push(`   ‚Ä¢ üîç Hautton-Analyse: ${skinAnalysis.clusters} Gesichtsbereich${skinAnalysis.clusters > 1 ? 'e' : ''} erkannt`);
                }
            } else {
                feedback.push("   ‚Ä¢ üì∑ Keine Personen erkannt - Landschafts- oder Architekturfoto");
            }
            
            // Object recognition feedback
            if (analysis.objects.totalObjects > 0) {
                const objectTypes = [];
                const objects = analysis.objects.detected;
                
                if (objects.buildings > 0) objectTypes.push(`${objects.buildings} Geb√§ude`);
                if (objects.vehicles > 0) objectTypes.push(`${objects.vehicles} Fahrzeug${objects.vehicles > 1 ? 'e' : ''}`);
                if (objects.nature > 0) objectTypes.push(`${objects.nature} Natur-Element${objects.nature > 1 ? 'e' : ''}`);
                if (objects.technology > 0) objectTypes.push(`${objects.technology} technische${objects.technology > 1 ? '' : 's'} Ger√§t${objects.technology > 1 ? 'e' : ''}`);
                
                if (objectTypes.length > 0) {
                    feedback.push(`   ‚Ä¢ üèóÔ∏è Objekte erkannt: ${objectTypes.join(', ')}`);
                }
                
                const objectBonus = Math.min(10, analysis.objects.totalObjects * 2);
                feedback.push(`   ‚Ä¢ üéØ Objekt-Erkennungs-Bonus: +${objectBonus} Punkte!`);
            }
            
            // Scenery feedback
            const sceneryNames = {
                urban: 'St√§dtische Umgebung',
                historic: 'Historische Architektur',
                park: 'Park/Gr√ºnanlage',
                waterfront: 'Gew√§sser/Uferbereich',
                street: 'Stra√üenszene',
                indoor: 'Innenraum'
            };
            
            const sceneryName = sceneryNames[analysis.scenery.dominantScenery] || 'Gemischte Umgebung';
            feedback.push(`   ‚Ä¢ üèûÔ∏è Umgebung: ${sceneryName}`);
            
            if (analysis.scenery.isOutdoor) {
                feedback.push("   ‚Ä¢ üåç Outdoor-Exploration-Bonus: +8 Punkte!");
                
                if (analysis.scenery.dominantScenery === 'historic') {
                    feedback.push("   ‚Ä¢ üèõÔ∏è Historische Bedeutung erkannt: +8 Punkte!");
                }
            }
            
            // Color analysis feedback
            if (analysis.colors.isColorful) {
                feedback.push("   ‚Ä¢ üåà Sehr farbenfrohe Aufnahme!");
                if (analysis.colors.isDiverse) {
                    feedback.push("   ‚Ä¢ üé® Exzellente Farbvielfalt erkannt!");
                }
            }
            
            if (analysis.colors.hasGoodBalance) {
                feedback.push("   ‚Ä¢ ‚öñÔ∏è Ausgewogene Farbkomposition!");
            }
            
            // Technical details for interested users
            feedback.push(``); // Empty line
            feedback.push("üî¨ **Technische Details:**");
            feedback.push(`   ‚Ä¢ Bildaufl√∂sung: ${analysis.dimensions.width}√ó${analysis.dimensions.height} Pixel`);
            feedback.push(`   ‚Ä¢ Sch√§rfe-Score: ${Math.round(analysis.sharpness.score)} (${analysis.sharpness.qualityLevel})`);
            feedback.push(`   ‚Ä¢ Kontrast-Bereich: ${analysis.contrast.globalRange} (${analysis.contrast.isGoodContrast ? 'optimal' : 'verbesserbar'})`);
            feedback.push(`   ‚Ä¢ Helligkeits-Durchschnitt: ${Math.round(analysis.brightness.average)}/255`);
            
            if (analysis.faces.likelyHasPeople) {
                feedback.push(`   ‚Ä¢ Hautton-Anteil: ${(analysis.faces.skinToneRatio * 100).toFixed(1)}%`);
                feedback.push(`   ‚Ä¢ Gesichts-Regionen: ${analysis.faces.skinToneClusters} erkannt`);
            }
            
            feedback.push(`   ‚Ä¢ Farbvielfalt: ${analysis.colors.diversity} verschiedene Farbt√∂ne`);
            feedback.push(`   ‚Ä¢ Interessante Bereiche: ${analysis.composition.interestPoints} erkannt`);
            
            // Overall encouragement
            const totalScore = technicalScore + compositionScore + creativityScore;
            if (totalScore > 270) {
                feedback.push("üèÜ **Fantastisches Foto - ihr seid echte Profis!**");
            } else if (totalScore > 230) {
                feedback.push("üëè **Sehr gelungenes Bild - weiter so!**");
            } else if (totalScore > 180) {
                feedback.push("üì∏ **Gutes Foto mit sch√∂nen Details!**");
            } else {
                feedback.push("üì± **Guter Versuch - beim n√§chsten Foto wird's noch besser!**");
            }
            
            return feedback;
        }

        // VERBESSERTE FUNKTION: Erkennt irrelevante Motive und typische Objekte
        function isIrrelevantSubject(faces, colors, brightness, composition, objects = null) {
            // Erweiterte Erkennung f√ºr verschiedene irrelevante Motive
            
            // 1. Tastatur-Erkennung: Wenig Personen + geringe Farbvielfalt + helle Bereiche
            if (faces.estimatedPeopleCount === 0 && 
                colors.diversity < 60 && 
                brightness.average > 180 &&
                faces.skinToneRatio < 0.005) {
                return { isIrrelevant: true, reason: "Sieht aus wie eine Tastatur oder anderes technisches Ger√§t" };
            }
            
            // 2. Tisch/M√∂bel-Erkennung: Einheitliche Farben + wenig Details
            if (faces.skinToneRatio < 0.003 && 
                faces.estimatedPeopleCount === 0 && 
                colors.diversity < 40 && 
                brightness.isOptimal === false) {
                return { isIrrelevant: true, reason: "Sieht aus wie ein M√∂belst√ºck oder eine leere Fl√§che" };
            }
            
            // 3. Wand/Decke-Erkennung: Sehr einheitlich + wenig Interesse
            if (colors.diversity < 30 && 
                faces.estimatedPeopleCount === 0 &&
                !colors.isColorful) {
                return { isIrrelevant: true, reason: "Sieht aus wie eine Wand oder Decke" };
            }
            
            // 4. Handr√ºcken/Finger-Erkennung: Viel Hautton aber keine Gesichter
            if (faces.skinToneRatio > 0.4 && 
                faces.estimatedPeopleCount === 0 && 
                colors.diversity < 70) {
                return { isIrrelevant: true, reason: "Sieht aus wie ein Handr√ºcken oder Finger" };
            }
            
            // 5. Zu nah/unscharfe Aufnahmen
            if (colors.diversity < 50 && 
                faces.estimatedPeopleCount === 0 &&
                brightness.average < 50) {
                return { isIrrelevant: true, reason: "Foto ist zu dunkel oder zu nah aufgenommen" };
            }
            
            return { isIrrelevant: false, reason: null }; // Motiv scheint relevant zu sein
        }

        function generateDetailedFeedback(technicalScore, compositionScore, creativityScore, brightness, contrast, sharpness, colors, faces) {
            const feedback = [];
            
            // NEUE VALIDIERUNG: Pr√ºfe auf irrelevante Motive
            if (isIrrelevantSubject(faces, colors)) {
                feedback.push("‚ùå Dieses Foto scheint nicht zur Tour-Challenge zu passen!");
                feedback.push("üí° Tipp: Fotografiere dich/euer Team an der Sehensw√ºrdigkeit!");
                feedback.push("üìç Das Foto sollte einen Bezug zur aktuellen Station haben");
                return feedback;
            }
            
            // Technical feedback
            if (technicalScore > 80) {
                feedback.push("üì∏ Hervorragende technische Qualit√§t!");
            } else if (technicalScore > 60) {
                feedback.push("‚úÖ Gute technische Umsetzung");
            } else {
                feedback.push("‚ö†Ô∏è Technische Qualit√§t k√∂nnte verbessert werden");
            }
            
            // Specific technical issues
            if (brightness.isDark) {
                feedback.push("üí° Bild ist etwas zu dunkel - mehr Licht w√§re hilfreich");
            } else if (brightness.isBright) {
                feedback.push("‚òÄÔ∏è Bild ist sehr hell - weniger Belichtung k√∂nnte helfen");
            } else if (brightness.isOptimal) {
                feedback.push("üåü Perfekte Belichtung!");
            }
            
            if (sharpness.isBlurry) {
                feedback.push("üîç Bild wirkt unscharf - ruhigere Hand oder besserer Fokus");
            } else if (sharpness.isOptimal) {
                feedback.push("üéØ Sehr scharfes Bild!");
            }
            
            // Composition feedback
            if (compositionScore > 75) {
                feedback.push("üé® Ausgezeichnete Bildkomposition!");
            } else if (compositionScore > 55) {
                feedback.push("üìê Solide Bildaufteilung");
            }
            
            // Creativity feedback
            if (colors.isColorful) {
                feedback.push("üåà Sch√∂ne Farbvielfalt im Bild!");
            }

            // Enhanced people and smile feedback
            if (faces.likelyHasPeople) {
                const peopleCount = faces.estimatedPeopleCount;
                const smilingCount = faces.estimatedSmilingPeople;
                
                // People count feedback
                if (peopleCount === 1) {
                    feedback.push("üë§ Eine Person im Bild erkannt!");
                } else if (peopleCount <= 3) {
                    feedback.push(`üë• ${peopleCount} Personen erkannt - tolle Teamarbeit!`);
                } else if (peopleCount <= 5) {
                    feedback.push(`üë®‚Äçüë©‚Äçüëß‚Äçüë¶ ${peopleCount} Personen im Bild - super Gruppenfoto!`);
                } else {
                    feedback.push(`üéâ Wow! ${peopleCount} Personen erkannt - fantastisches Gruppenbild!`);
                }
                
                // Smile feedback
                if (smilingCount > 0) {
                    if (smilingCount === 1) {
                        feedback.push("üòä 1 l√§chelnde Person erkannt - strahlendes L√§cheln!");
                    } else if (smilingCount === peopleCount && peopleCount > 1) {
                        feedback.push(`üòÑ Alle ${smilingCount} Personen l√§cheln - perfekte Gruppenstimmung!`);
                    } else {
                        feedback.push(`üòÉ ${smilingCount} l√§chelnde Personen erkannt - tolle Stimmung!`);
                    }
                    
                    // Smile bonus points
                    const smileBonus = smilingCount * 5;
                    feedback.push(`‚ú® L√§chel-Bonus: +${smileBonus} Punkte!`);
                }
                
                // People count bonus points
                let peopleBonus = 12; // Base bonus
                if (peopleCount >= 2) peopleBonus += 8;
                if (peopleCount >= 3) peopleBonus += 6;
                if (peopleCount >= 4) peopleBonus += 4;
                if (peopleCount >= 5) peopleBonus += 3;
                
                feedback.push(`üë• Personen-Bonus: +${peopleBonus} Punkte!`);
                
                // Special achievements
                if (peopleCount >= 5 && smilingCount >= 4) {
                    feedback.push("üèÜ Spezial-Achievement: 'Gl√ºckliche Gro√ügruppe' erreicht!");
                } else if (peopleCount >= 3 && smilingCount === peopleCount) {
                    feedback.push("üåü Spezial-Achievement: 'Perfekte Teamharmonie' erreicht!");
                }
            } else {
                feedback.push("üì∑ Einzelaufnahme - manchmal sind Solo-Shots auch kunstvolle Kompositionen!");
            }
            
            // Overall encouragement
            if (technicalScore + compositionScore + creativityScore > 240) {
                feedback.push("üèÜ Fantastisches Foto - ihr seid echte Profis!");
            } else if (technicalScore + compositionScore + creativityScore > 200) {
                feedback.push("üëè Sehr gelungenes Bild - weiter so!");
            } else {
                feedback.push("üì± Guter Versuch - beim n√§chsten Foto wird's noch besser!");
            }
            
            return feedback;
        }

        function createFallbackAnalysis(stationId) {
            // More intelligent fallback based on station and time
            const station = tourApp.stations.find(s => s.id === stationId);
            const timeOfDay = new Date().getHours();
            
            // Base scores with some variation
            let technicalScore = 65 + Math.random() * 25;
            let compositionScore = 60 + Math.random() * 30;
            let creativityScore = 55 + Math.random() * 25;
            
            // Station-specific bonuses
            if (station) {
                if (station.title.includes('Dom')) creativityScore += 5;
                if (station.title.includes('Heumarkt')) technicalScore += 5;
                if (station.title.includes('Altstadt')) compositionScore += 5;
            }
            
            // Time of day adjustments
            if (timeOfDay >= 10 && timeOfDay <= 16) { // Good lighting
                technicalScore += 5;
            } else if (timeOfDay >= 19 || timeOfDay <= 7) { // Challenging lighting
                technicalScore -= 5;
                creativityScore += 3; // Bonus for night photography
            }
            
            // Konservativere team simulation f√ºr fallback
            if (tourApp.state.selectedTeam) {
                // Viel konservativere Simulation - meist 1 Person, selten mehr
                const simulatedPeople = Math.random() > 0.7 ? 2 : 1; // 70% Chance f√ºr 1 Person, 30% f√ºr 2
                const simulatedSmiles = Math.floor(simulatedPeople * (0.5 + Math.random() * 0.5)); // 50-100% smiling
                
                creativityScore += 8; // Base team bonus
                
                // People bonus simulation
                if (simulatedPeople >= 2) creativityScore += 8;
                if (simulatedPeople >= 3) creativityScore += 6;
                if (simulatedPeople >= 4) creativityScore += 4;
                
                // Smile bonus simulation
                creativityScore += simulatedSmiles * 3; // Reduced for fallback
                
                // Store simulated data for feedback
                window.lastFallbackData = {
                    people: simulatedPeople,
                    smiles: simulatedSmiles
                };
            }
            
            const finalScore = Math.round(
                (technicalScore * 0.4) + 
                (compositionScore * 0.3) + 
                (creativityScore * 0.3)
            );
            
            const feedback = [
                technicalScore > 75 ? "üì∏ Sehr gute Bildqualit√§t!" : "üì± Solide Aufnahme",
                compositionScore > 75 ? "üé® Kreative Bildgestaltung!" : "üìê Gute Komposition",
                creativityScore > 75 ? "‚ú® Sehr originell!" : "üé≠ Sch√∂ne kreative Elemente"
            ];

            if (tourApp.state.selectedTeam && window.lastFallbackData) {
                const { people, smiles } = window.lastFallbackData;
                feedback.push(`üë• ${people} Person${people > 1 ? 'en' : ''} erkannt!`);
                if (smiles > 0) {
                    feedback.push(`üòä ${smiles} l√§chelnde Person${smiles > 1 ? 'en' : ''}!`);
                    feedback.push(`‚ú® Extra-Punkte f√ºr gute Stimmung!`);
                }
            } else if (tourApp.state.selectedTeam) {
                feedback.push("üë• Team-Foto erkannt!");
            } else {
                feedback.push("üì∑ Einzelaufnahme");
            }
            
            return {
                technicalScore: Math.max(30, Math.min(100, technicalScore)),
                compositionScore: Math.max(30, Math.min(100, compositionScore)),
                creativityScore: Math.max(30, Math.min(100, creativityScore)),
                finalScore: Math.max(30, Math.min(100, finalScore)),
                feedback
            };
        }

        // NEW: Challenge Photo Sharing Function
        async function shareChallengePhoto(stationId) {
            try {
                const photoData = tourApp.state.uploadedPhotos.find(p => p.stationId === stationId);
                if (!photoData) {
                    showNotification('Kein Foto zum Teilen gefunden!', 'error');
                    return;
                }

                const station = tourApp.stations.find(s => s.id === stationId);
                if (!station) return;

                // Create high-quality version for sharing (less compression)
                const shareableImage = await compressImage(
                    dataURLtoFile(photoData.imageUrl), 
                    0.8, // Higher quality
                    1200, // Larger dimensions
                    900
                );

                const shareMessageData = {
                    userName: tourApp.state.userName,
                    image: shareableImage,
                    timestamp: firebase.firestore ? firebase.firestore.FieldValue.serverTimestamp() : Date.now(),
                    tourId: tourApp.state.tourId,
                    type: 'challenge-photo',
                    stationId: stationId,
                    stationTitle: station.title,
                    score: photoData.score || 0,
                    teamName: tourApp.state.teamName || 'Unbekanntes Team',
                    isDownloadable: true
                };

                // Add to main chat
                addChallengePhotoMessage(shareMessageData, true);

                // Save to Firebase
                if (tourApp.state.isFirebaseConnected && tourApp.state.tourId) {
                    await saveToFirebase('chat', `challenge_${Date.now()}`, shareMessageData);
                } else {
                    const chatKey = `chat_${tourApp.state.tourId}`;
                    const chatMessages = JSON.parse(localStorage.getItem(chatKey) || '[]');
                    chatMessages.push(shareMessageData);
                    if (chatMessages.length > 50) {
                        chatMessages.splice(0, chatMessages.length - 50);
                    }
                    localStorage.setItem(chatKey, JSON.stringify(chatMessages));
                }

                showNotification('Challenge-Foto im Chat geteilt! üì§');
                
                // Disable share button to prevent spam
                const shareButton = document.querySelector(`[onclick="shareChallengePhoto(${stationId})"]`);
                if (shareButton) {
                    shareButton.disabled = true;
                    shareButton.textContent = '‚úÖ Foto geteilt';
                    shareButton.style.background = '#6b7280';
                }

            } catch (error) {
                console.error('Error sharing challenge photo:', error);
                showNotification('Fehler beim Teilen des Fotos', 'error');
            }
        }

        // Helper function to convert data URL to File
        function dataURLtoFile(dataURL) {
            const arr = dataURL.split(',');
            const mime = arr[0].match(/:(.*?);/)[1];
            const bstr = atob(arr[1]);
            let n = bstr.length;
            const u8arr = new Uint8Array(n);
            while(n--){
                u8arr[n] = bstr.charCodeAt(n);
            }
            return new File([u8arr], 'challenge-photo.jpg', {type: mime});
        }

        // Enhanced challenge photo message with recognition results
        function addChallengePhotoMessage(messageData, isOwn = false) {
            try {
                const chatContainer = document.getElementById('chatContainer');
                if (!chatContainer) return;
                
                const messageDiv = document.createElement('div');
                messageDiv.className = `chat-message ${isOwn ? 'own' : ''} challenge-photo-message`;
                messageDiv.style.background = isOwn ? '#e0f2fe' : '#f0f9ff';
                messageDiv.style.borderLeft = '4px solid #0ea5e9';
                messageDiv.style.position = 'relative';
                
                const timeStr = new Date().toLocaleTimeString('de-DE', {
                    hour: '2-digit',
                    minute: '2-digit'
                });
                
                // Ensure all message data is properly defined
                const userName = messageData.userName || 'Unbekannt';
                const teamName = messageData.teamName || '';
                const stationTitle = messageData.stationTitle || 'Unbekannte Station';
                const score = messageData.score || 0;
                const image = messageData.image || '';
                const recognitionResults = messageData.recognitionResults || [];
                
                // Create recognition summary for display
                let recognitionSummary = '';
                if (recognitionResults.length > 0) {
                    const topResults = recognitionResults.slice(0, 3); // Show top 3 results
                    recognitionSummary = `
                        <div style="background: rgba(5, 150, 105, 0.1); padding: 0.5rem; border-radius: 6px; margin: 0.5rem 0; font-size: 0.8rem;">
                            <strong>üîç KI erkannte:</strong> ${topResults.join(' ‚Ä¢ ')}
                            ${recognitionResults.length > 3 ? ` ‚Ä¢ +${recognitionResults.length - 3} weitere` : ''}
                        </div>
                    `;
                }
                
                const messageContent = `
                    <div style="display: flex; align-items: center; margin-bottom: 0.5rem;">
                        <span style="background: #0ea5e9; color: white; padding: 0.2rem 0.5rem; border-radius: 12px; font-size: 0.7rem; margin-right: 0.5rem;">üì∏ CHALLENGE</span>
                        <strong>${userName}</strong> ${teamName ? `(${teamName})` : ''}
                    </div>
                    <p style="margin-bottom: 0.5rem; color: #0369a1; font-weight: bold;">
                        üèõÔ∏è ${stationTitle} - ${score} Punkte!
                    </p>
                    ${recognitionSummary}
                    <div class="chat-image-container" style="position: relative;">
                        <img src="${image}" class="chat-image" 
                            onclick="event.stopPropagation(); showEnhancedImageModal('${image}', 'Challenge: ${stationTitle}', '${userName} (${score} Punkte)', ${JSON.stringify(recognitionResults).replace(/"/g, '&quot;')})" 
                            alt="Challenge Foto" style="max-width: 300px; cursor: pointer; transition: transform 0.3s;"
                            onmouseover="this.style.transform='scale(1.05)'"
                            onmouseout="this.style.transform='scale(1)'">
                        <div style="position: absolute; top: 8px; right: 8px; display: flex; gap: 4px;">
                            <button onclick="event.stopPropagation(); downloadChallengePhoto('${image}', '${stationTitle}', '${userName}', ${score})" 
                                    style="background: rgba(0,0,0,0.7); color: white; border: none; padding: 0.4rem; border-radius: 50%; cursor: pointer; font-size: 0.9rem; transition: all 0.3s;"
                                    onmouseover="this.style.background='rgba(0,0,0,0.9)'; this.style.transform='scale(1.1)'"
                                    onmouseout="this.style.background='rgba(0,0,0,0.7)'; this.style.transform='scale(1)'"
                                    title="Foto herunterladen">
                                üíæ
                            </button>
                            <button onclick="event.stopPropagation(); showPhotoAnalysis('${image}', ${JSON.stringify(recognitionResults).replace(/"/g, '&quot;')})" 
                                    style="background: rgba(139, 92, 246, 0.9); color: white; border: none; padding: 0.4rem; border-radius: 50%; cursor: pointer; font-size: 0.9rem; transition: all 0.3s;"
                                    onmouseover="this.style.background='rgba(139, 92, 246, 1)'; this.style.transform='scale(1.1)'"
                                    onmouseout="this.style.background='rgba(139, 92, 246, 0.9)'; this.style.transform='scale(1)'"
                                    title="KI-Analyse anzeigen">
                                üîç
                            </button>
                        </div>
                    </div>
                    <span class="timestamp" style="font-size: 0.8rem; color: #6b7280;">${timeStr}</span>
                `;

                messageDiv.innerHTML = messageContent;
                
                chatContainer.appendChild(messageDiv);
                chatContainer.scrollTop = chatContainer.scrollHeight;
                
                if (!isOwn && tourApp.state.currentTab !== 'chat') {
                    tourApp.state.unreadMessages++;
                    updateChatNotification();
                    
                    const notificationText = recognitionResults.length > 0 
                        ? `üì∏ ${userName} hat ein Challenge-Foto geteilt! (${recognitionResults[0]})`
                        : `üì∏ ${userName} hat ein Challenge-Foto geteilt!`;
                    showClickableNotification(notificationText, 'chat');
                } else if (!isOwn && tourApp.state.currentTab === 'chat' && tourApp.state.currentChatTab !== 'main') {
                    tourApp.state.unreadMessages++;
                    updateChatNotification();
                }
            } catch (error) {
                console.error('Error adding challenge photo message:', error);
            }
        }

        // Enhanced image modal with recognition results
        function showEnhancedImageModal(url, title, description, recognitionResults) {
            try {
                const modal = document.createElement('div');
                modal.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0,0,0,0.95);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 10000;
                    flex-direction: column;
                    padding: 20px;
                    box-sizing: border-box;
                `;
                
                const recognitionResultsArray = typeof recognitionResults === 'string' ? 
                    JSON.parse(recognitionResults) : recognitionResults || [];
                
                const recognitionHtml = recognitionResultsArray.length > 0 ? `
                    <div style="background: rgba(139, 92, 246, 0.9); padding: 1rem; border-radius: 12px; margin-bottom: 1rem; max-width: 600px;">
                        <h4 style="color: white; margin-bottom: 0.5rem;">üîç KI-Erkennung:</h4>
                        <div style="color: white; font-size: 0.9rem; line-height: 1.4;">
                            ${recognitionResultsArray.map(result => `‚Ä¢ ${result}`).join('<br>')}
                        </div>
                    </div>
                ` : '';
                
                modal.innerHTML = `
                    ${recognitionHtml}
                    <img src="${url}" style="max-width: 90%; max-height: 70%; object-fit: contain; border-radius: 12px; box-shadow: 0 8px 32px rgba(0,0,0,0.5);" alt="${title}">
                    <div style="color: white; text-align: center; margin-top: 20px; max-width: 600px;">
                        <h3 style="margin-bottom: 0.5rem;">${title}</h3>
                        <p style="margin-bottom: 1rem;">${description}</p>
                        <div style="display: flex; gap: 1rem; justify-content: center; flex-wrap: wrap;">
                            <button onclick="event.stopPropagation(); downloadImageFromModal('${url}', '${title}')" 
                                    style="padding: 0.8rem 1.5rem; background: #059669; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: bold;">
                                üíæ Herunterladen
                            </button>
                            <button onclick="event.stopPropagation(); closeEnhancedImageModal(this.parentElement.parentElement.parentElement)" 
                                    style="padding: 0.8rem 1.5rem; background: #dc2626; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: bold;">
                                ‚úï Schlie√üen
                            </button>
                        </div>
                    </div>
                `;
                
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        e.stopPropagation();
                        closeEnhancedImageModal(modal);
                    }
                });

                const escapeHandler = (e) => {
                    if (e.key === 'Escape') {
                        e.stopPropagation();
                        closeEnhancedImageModal(modal);
                        document.removeEventListener('keydown', escapeHandler);
                    }
                };
                document.addEventListener('keydown', escapeHandler);
                
                modal.setAttribute('data-escape-handler', 'true');
                document.body.appendChild(modal);

            } catch (error) {
                console.error('Error showing enhanced image modal:', error);
                // Fallback to regular image modal
                showImageModal(url, title, description);
            }
        }

        function closeEnhancedImageModal(modal) {
            try {
                if (modal && modal.parentElement) {
                    modal.remove();
                }
            } catch (error) {
                console.error('Error closing enhanced image modal:', error);
            }
        }

        // NEUE FUNKTION: Best√§tigungsdialog f√ºr erkannte Objekte
        function showRecognitionConfirmDialog(recognitionResults, warning = null) {
            return new Promise((resolve) => {
                const modal = document.createElement('div');
                modal.className = 'image-modal';
                modal.style.zIndex = '10000';
                
                const topResults = recognitionResults.slice(0, 5);
                const warningHtml = warning ? `
                    <div style="background: #fef3c7; border: 2px solid #f59e0b; border-radius: 8px; padding: 1rem; margin-bottom: 1rem;">
                        <h4 style="color: #92400e; margin-bottom: 0.5rem;">‚ö†Ô∏è M√∂gliches Problem erkannt:</h4>
                        <p style="color: #92400e; margin: 0;">${warning}</p>
                    </div>
                ` : '';
                
                modal.innerHTML = `
                    <div style="background: white; border-radius: 16px; padding: 2rem; max-width: 500px; margin: 0 auto; position: relative; top: 10%; box-shadow: 0 20px 60px rgba(0,0,0,0.3);">
                        <h3 style="color: #1f2937; margin-bottom: 1rem; text-align: center;">üîç KI-Erkennung best√§tigen</h3>
                        
                        ${warningHtml}
                        
                        <div style="background: #f8fafc; border-radius: 8px; padding: 1rem; margin-bottom: 1.5rem;">
                            <h4 style="color: #374151; margin-bottom: 0.5rem;">Die KI hat erkannt:</h4>
                            <ul style="color: #6b7280; margin: 0; padding-left: 1.5rem;">
                                ${topResults.map(result => `<li>${result}</li>`).join('')}
                                ${recognitionResults.length > 5 ? `<li style="font-style: italic;">... und ${recognitionResults.length - 5} weitere Objekte</li>` : ''}
                            </ul>
                        </div>
                        
                        <p style="color: #6b7280; text-align: center; margin-bottom: 1.5rem;">
                            Stimmt die Erkennung? Zeigt dein Foto wirklich diese Dinge?
                        </p>
                        
                        <div style="display: flex; gap: 1rem; justify-content: center;">
                            <button onclick="resolveRecognitionDialog(false)" 
                                    style="background: #dc2626; color: white; border: none; padding: 0.8rem 1.5rem; border-radius: 8px; cursor: pointer; font-weight: bold;">
                                ‚ùå Nein, stimmt nicht
                            </button>
                            <button onclick="resolveRecognitionDialog(true)" 
                                    style="background: #059669; color: white; border: none; padding: 0.8rem 1.5rem; border-radius: 8px; cursor: pointer; font-weight: bold;">
                                ‚úÖ Ja, stimmt
                            </button>
                        </div>
                    </div>
                `;
                
                // Globale Resolver-Funktion f√ºr die Buttons
                window.resolveRecognitionDialog = (confirmed) => {
                    modal.remove();
                    delete window.resolveRecognitionDialog;
                    resolve(confirmed);
                };
                
                document.body.appendChild(modal);
            });
        }

        function downloadImageFromModal(imageUrl, title) {
            try {
                const cleanTitle = title.replace(/[^a-zA-Z0-9]/g, '_');
                const timestamp = new Date().toISOString().slice(0, 19).replace(/[:-]/g, '');
                const fileName = `${cleanTitle}_${timestamp}.jpg`;
                
                const link = document.createElement('a');
                link.href = imageUrl;
                link.download = fileName;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                showNotification(`üì• Foto heruntergeladen: "${fileName}"`, 'success');
            } catch (error) {
                console.error('Error downloading image from modal:', error);
            }
        }

        // Enhanced photo analysis display
        function showPhotoAnalysis(imageUrl, recognitionResults) {
            try {
                const modal = document.createElement('div');
                modal.className = 'admin-popup-overlay';
                
                const recognitionResultsArray = typeof recognitionResults === 'string' ? 
                    JSON.parse(recognitionResults) : recognitionResults || [];
                
                modal.innerHTML = `
                    <div class="admin-popup" style="max-width: 500px; width: 95%; background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%); color: white;">
                        <h3 style="color: white; margin-bottom: 1rem;">üîç KI-Foto-Analyse</h3>
                        
                        <div style="background: rgba(255,255,255,0.1); border-radius: 8px; padding: 1rem; margin-bottom: 1rem;">
                            <img src="${imageUrl}" style="width: 100%; max-height: 200px; object-fit: contain; border-radius: 6px; margin-bottom: 1rem;">
                        </div>
                        
                        <div style="background: rgba(255,255,255,0.1); border-radius: 8px; padding: 1rem; margin-bottom: 1rem;">
                            <h4 style="color: white; margin-bottom: 0.5rem;">üéØ Erkannte Elemente:</h4>
                            <div style="line-height: 1.6;">
                                ${recognitionResultsArray.length > 0 ? 
                                    recognitionResultsArray.map(result => `<div style="margin: 0.25rem 0;">‚Ä¢ ${result}</div>`).join('') :
                                    '<div style="color: rgba(255,255,255,0.7); font-style: italic;">Keine detaillierten Erkennungsdaten verf√ºgbar</div>'
                                }
                            </div>
                        </div>
                        
                        <div style="text-align: center;">
                            <button class="admin-popup-close" onclick="closePhotoAnalysis(this.parentElement.parentElement)" 
                                    style="background: white; color: #8b5cf6;">
                                Verstanden
                            </button>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(modal);
                
                // Add escape key handler
                const escapeHandler = (e) => {
                    if (e.key === 'Escape') {
                        modal.remove();
                        document.removeEventListener('keydown', escapeHandler);
                    }
                };
                document.addEventListener('keydown', escapeHandler);
                
            } catch (error) {
                console.error('Error showing photo analysis:', error);
            }
        }

        function closePhotoAnalysis(modal) {
            try {
                if (modal && modal.parentElement) {
                    modal.remove();
                }
            } catch (error) {
                console.error('Error closing photo analysis:', error);
            }
        }

        // Enhanced download function with score
        function downloadChallengePhoto(imageUrl, stationTitle, userName, score) {
            try {
                const cleanStationTitle = stationTitle.replace(/[^a-zA-Z0-9]/g, '_');
                const cleanUserName = userName.replace(/[^a-zA-Z0-9]/g, '_');
                const timestamp = new Date().toISOString().slice(0, 19).replace(/[:-]/g, '');
                const fileName = `Challenge_${cleanStationTitle}_${cleanUserName}_${score}pts_${timestamp}.jpg`;
                
                const link = document.createElement('a');
                link.href = imageUrl;
                link.download = fileName;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                showNotification(`üíæ Challenge-Foto heruntergeladen: "${fileName}"`, 'success');
            } catch (error) {
                console.error('Error downloading challenge photo:', error);
                showNotification('Download fehlgeschlagen', 'error');
            }
        }

        // Download function for challenge photos
        function downloadChallengePhoto(imageUrl, stationTitle, userName) {
            try {
                const link = document.createElement('a');
                link.href = imageUrl;
                link.download = `Challenge_${stationTitle.replace(/\s+/g, '_')}_${userName}_${Date.now()}.jpg`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                showNotification('Foto wird heruntergeladen! üíæ');
            } catch (error) {
                console.error('Error downloading challenge photo:', error);
                showNotification('Download fehlgeschlagen', 'error');
            }
        }

        function animateScore(stationId, targetScore) {
            try {
                const scoreElement = document.getElementById(`score-${stationId}`);
                if (!scoreElement) return;
                
                let currentScore = 0;
                const increment = Math.ceil(targetScore / 30);
                
                const interval = setInterval(() => {
                    currentScore += increment;
                    if (currentScore >= targetScore) {
                        currentScore = targetScore;
                        clearInterval(interval);
                    }
                    scoreElement.textContent = currentScore;
                }, 50);
            } catch (error) {
                console.error('Error animating score:', error);
            }
        }

        function generatePhotoFeedback(technical, composition, creativity) {
            // This function is now replaced by generateDetailedFeedback in the new analysis system
            // Keeping this as fallback for compatibility
            const feedback = [];
            
            if (technical > 80) {
                feedback.push("üì∏ Hervorragende technische Qualit√§t!");
            } else if (technical > 60) {
                feedback.push("‚úÖ Gute technische Umsetzung");
            } else {
                feedback.push("‚ö†Ô∏è Bild k√∂nnte sch√§rfer oder besser belichtet sein");
            }
            
            if (composition > 75) {
                feedback.push("üé® Ausgezeichnete Bildkomposition!");
            } else if (composition > 55) {
                feedback.push("üìê Solide Bildaufteilung");
            } else {
                feedback.push("üí° Tipp: Achte auf die Bildaufteilung und den Bildausschnitt");
            }
            
            if (creativity > 75) {
                feedback.push("‚ú® Sehr kreative und originelle Aufnahme!");
            } else if (creativity > 60) {
                feedback.push("üé≠ Sch√∂ne kreative Elemente!");
            } else {
                feedback.push("üì± Guter Ansatz - probiert ruhig verschiedene Perspektiven!");
            }
            
            if (tourApp.state.selectedTeam) {
                feedback.push("üë• Toll, dass ihr als Team fotografiert! Bonus: +10 Punkte");
            }
            
            return feedback;
        }

        function completeStation(stationId) {
            try {
                if (!tourApp.state.completedStations.includes(stationId)) {
                    tourApp.state.completedStations.push(stationId);
                    updateProgress();
                    showNotification('Station abgeschlossen! üèÅ');
                    
                    // Keep station details open after completion
                    const stationDetails = document.getElementById(`station-${stationId}`);
                    if (stationDetails) {
                        stationDetails.classList.add('active');
                    }
                    
                    const completeBtn = document.getElementById(`complete-btn-${stationId}`);
                    if (completeBtn) {
                        const stationCard = completeBtn.closest('.station-card');
                        if (stationCard) {
                            stationCard.classList.add('completed');
                            const stationNumber = stationCard.querySelector('.station-number');
                            if (stationNumber) {
                                stationNumber.classList.add('completed');
                            }
                        }
                        
                        completeBtn.disabled = true;
                        completeBtn.textContent = '‚úÖ Station abgeschlossen';
                        completeBtn.style.background = '#6b7280';
                    }

                    if (tourApp.state.completedStations.length === tourApp.stations.length) {
                        showNotification('üéâ Herzlichen Gl√ºckwunsch! Tour abgeschlossen!');
                        setTimeout(() => {
                            showTab('ranking', document.querySelector('.tab[onclick*="ranking"]'));
                        }, 2000);
                    }

                    saveState();
                    addSystemMessage(`${tourApp.state.userName} hat "${tourApp.stations.find(s => s.id === stationId)?.title}" abgeschlossen! üèÅ`);
                }
            } catch (error) {
                console.error('Error completing station:', error);
            }
        }

        function updateUI() {
            try {
                const scoreElement = document.getElementById('totalScore');
                if (scoreElement) {
                    scoreElement.textContent = tourApp.state.totalScore;
                }
                updateProgress();
            } catch (error) {
                console.error('Error updating UI:', error);
            }
        }

        function updateProgress() {
            try {
                const progress = (tourApp.state.completedStations.length / tourApp.stations.length) * 100;
                const progressBar = document.getElementById('progressBar');
                if (progressBar) {
                    progressBar.style.width = progress + '%';
                }
            } catch (error) {
                console.error('Error updating progress:', error);
            }
        }

        function resetTour() {
            try {
                if (confirm('Wirklich alle Daten zur√ºcksetzen?')) {
                    localStorage.removeItem(`chat_${tourApp.state.tourId}`);
                    
                    tourApp.state.completedStations = [];
                    tourApp.state.totalScore = 0;
                    tourApp.state.uploadedPhotos = [];
                    
                    saveState();
                    generateStationsList();
                    updateUI();
                    showNotification('Tour zur√ºckgesetzt! üîÑ');
                    addSystemMessage('Admin hat die Tour zur√ºckgesetzt! üîÑ');
                }
            } catch (error) {
                console.error('Error resetting tour:', error);
            }
        }

        // Map Functions
        function initMap() {
            try {
                if (tourApp.state.map || !document.getElementById('map')) return;
                
                if (typeof L === 'undefined') {
                    loadLeaflet(() => createMap());
                } else {
                    createMap();
                }
            } catch (error) {
                console.error('Error initializing map:', error);
            }
        }

        function forceMapRefresh() {
            try {
                if (tourApp.state.map) {
                    setTimeout(() => {
                        tourApp.state.map.invalidateSize();
                        
                        // Recenter on first station or user location
                        if (tourApp.state.userLocation) {
                            tourApp.state.map.setView([tourApp.state.userLocation.lat, tourApp.state.userLocation.lng], 15);
                        } else if (tourApp.stations && tourApp.stations.length > 0) {
                            tourApp.state.map.setView([tourApp.stations[0].lat, tourApp.stations[0].lng], 15);
                        }
                    }, 200);
                } else {
                    // Reinitialize map if it doesn't exist
                    initMap();
                }
            } catch (error) {
                console.error('Error refreshing map:', error);
                // Fallback: try to recreate map
                setTimeout(() => initMap(), 500);
            }
        }

        function loadLeaflet(callback) {
            const script = document.createElement('script');
            script.src = 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.js';
            script.onload = callback;
            script.onerror = () => showMapError();
            document.head.appendChild(script);
        }

        function createMap() {
            try {
                tourApp.state.map = L.map('map').setView([50.9375, 6.9597], 15);
                
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '¬© OpenStreetMap contributors'
                }).addTo(tourApp.state.map);
                
                tourApp.stations.forEach(station => {
                    const isCompleted = tourApp.state.completedStations.includes(station.id);
                    const marker = L.marker([station.lat, station.lng])
                        .bindPopup(`
                            <div style="text-align: center; max-width: 200px;">
                                <h4>${station.title}</h4>
                                <p>${station.subtitle}</p>
                                <p><strong>Station ${station.id}/${tourApp.stations.length}</strong></p>
                                ${isCompleted ? '<p style="color: green;">‚úÖ Abgeschlossen</p>' : '<p style="color: orange;">‚è≥ Ausstehend</p>'}
                            </div>
                        `)
                        .addTo(tourApp.state.map);
                    
                    tourApp.state.markers.push(marker);
                });
                
                const routeCoordinates = tourApp.stations.map(station => [station.lat, station.lng]);
                L.polyline(routeCoordinates, {
                    color: '#dc2626',
                    weight: 3,
                    opacity: 0.7
                }).addTo(tourApp.state.map);
                
                if (tourApp.state.userLocation) {
                    addUserLocationToMap();
                }
            } catch (error) {
                console.error('Error creating map:', error);
            }
        }

        function showMapError() {
            const mapEl = document.getElementById('map');
            if (mapEl) {
                mapEl.innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 100%; background: #f3f4f6; border-radius: 10px;"><p>üó∫Ô∏è Karte konnte nicht geladen werden</p></div>';
            }
        }

        function addUserLocationToMap() {
            try {
                if (!tourApp.state.map || !tourApp.state.userLocation) return;
                
                const userIcon = L.divIcon({
                    html: '<div style="background: #3b82f6; width: 20px; height: 20px; border-radius: 50%; border: 3px solid white; box-shadow: 0 2px 6px rgba(0,0,0,0.3);"></div>',
                    className: 'user-location-marker',
                    iconSize: [20, 20],
                    iconAnchor: [10, 10]
                });
                
                L.marker([tourApp.state.userLocation.lat, tourApp.state.userLocation.lng], {
                    icon: userIcon
                })
                .bindPopup('üìç Dein Standort')
                .addTo(tourApp.state.map);
            } catch (error) {
                console.error('Error adding user location to map:', error);
            }
        }

        function centerOnUser() {
            try {
                if (tourApp.state.userLocation && tourApp.state.map) {
                    tourApp.state.map.setView([tourApp.state.userLocation.lat, tourApp.state.userLocation.lng], 17);
                } else {
                    showNotification('Standort nicht verf√ºgbar. Bitte erlaube Standortzugriff.', 'error');
                }
            } catch (error) {
                console.error('Error centering on user:', error);
            }
        }

        function initGeolocation() {
            try {
                if (navigator.geolocation) {
                    navigator.geolocation.getCurrentPosition(
                        position => {
                            tourApp.state.userLocation = {
                                lat: position.coords.latitude,
                                lng: position.coords.longitude
                            };
                            updateLocationInfo();
                            if (tourApp.state.map) {
                                addUserLocationToMap();
                            }
                            
                            // Start position tracking
                            startUserPositionTracking();
                        },
                        error => {
                            const distanceInfo = document.getElementById('distanceInfo');
                            if (distanceInfo) {
                                distanceInfo.textContent = 'üìç Standort nicht verf√ºgbar';
                            }
                        }
                    );
                }
            } catch (error) {
                console.error('Error initializing geolocation:', error);
            }
        }

        function updateLocationInfo() {
            try {
                if (!tourApp.state.userLocation) return;
                
                let nearestStation = null;
                let minDistance = Infinity;
                
                tourApp.stations.forEach(station => {
                    const distance = calculateDistance(
                        tourApp.state.userLocation.lat, tourApp.state.userLocation.lng,
                        station.lat, station.lng
                    );
                    
                    if (distance < minDistance) {
                        minDistance = distance;
                        nearestStation = station;
                    }
                });
                
                if (nearestStation) {
                    const distanceText = minDistance < 1 
                        ? `${Math.round(minDistance * 1000)}m` 
                        : `${minDistance.toFixed(1)}km`;
                    
                    const distanceInfo = document.getElementById('distanceInfo');
                    if (distanceInfo) {
                        distanceInfo.textContent = `üìç N√§chste Station: ${nearestStation.title} (${distanceText})`;
                    }
                }
            } catch (error) {
                console.error('Error updating location info:', error);
            }
        }

        function calculateDistance(lat1, lng1, lat2, lng2) {
            const R = 6371;
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLng = (lng2 - lng1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                      Math.sin(dLng/2) * Math.sin(dLng/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }

        function playAudio(url, type, title) {
            try {
                if (!url || url.trim() === '') {
                    showNotification('Audio-Datei noch nicht verf√ºgbar', 'warning');
                    return;
                }
                
                const modal = document.createElement('div');
                modal.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0,0,0,0.95);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 10000;
                    flex-direction: column;
                    padding: 20px;
                    box-sizing: border-box;
                `;
                
                let audioContent = '';
                
                switch(type) {
                    case 'youtube':
                        const youtubeId = extractYouTubeId(url);
                        if (youtubeId) {
                            audioContent = `
                                <div style="background: white; border-radius: 16px; padding: 1.5rem; max-width: 90vw; width: 100%; max-width: 800px; text-align: center; box-shadow: 0 20px 60px rgba(0,0,0,0.3);">
                                    <h3 style="color: #1f2937; margin-bottom: 1rem; font-size: 1.3rem;">üì∫ ${title}</h3>
                                    <div style="position: relative; width: 100%; height: 0; padding-bottom: 56.25%; margin-bottom: 1rem;">
                                        <iframe 
                                            style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border-radius: 12px;" 
                                            src="https://www.youtube.com/embed/${youtubeId}?autoplay=1&rel=0" 
                                            frameborder="0" 
                                            allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" 
                                            allowfullscreen>
                                        </iframe>
                                    </div>
                                    <p style="color: #6b7280; font-size: 0.9rem;">üé¨ In-App YouTube Player</p>
                                </div>
                            `;
                        } else {
                            audioContent = `
                                <div style="background: white; border-radius: 16px; padding: 2rem; text-align: center;">
                                    <h3 style="color: #dc2626;">‚ùå Ung√ºltige YouTube-URL</h3>
                                    <p style="color: #6b7280; margin-top: 1rem;">Bitte √ºberpr√ºfen Sie die URL</p>
                                </div>
                            `;
                        }
                        break;
                        
                    case 'soundcloud':
                        const soundcloudEmbedUrl = generateSoundCloudEmbed(url);
                        audioContent = `
                            <div style="background: white; border-radius: 16px; padding: 1.5rem; max-width: 90vw; width: 100%; max-width: 600px; text-align: center; box-shadow: 0 20px 60px rgba(0,0,0,0.3);">
                                <h3 style="color: #1f2937; margin-bottom: 1rem; font-size: 1.3rem;">‚òÅÔ∏è ${title}</h3>
                                <iframe 
                                    width="100%" 
                                    height="166" 
                                    scrolling="no" 
                                    frameborder="no" 
                                    src="${soundcloudEmbedUrl}"
                                    style="border-radius: 12px; margin-bottom: 1rem;">
                                </iframe>
                                <p style="color: #6b7280; font-size: 0.9rem;">üéµ In-App SoundCloud Player</p>
                            </div>
                        `;
                        break;
                        
                    case 'spotify':
                        const spotifyEmbedUrl = generateSpotifyEmbed(url);
                        if (spotifyEmbedUrl) {
                            audioContent = `
                                <div style="background: white; border-radius: 16px; padding: 1.5rem; max-width: 90vw; width: 100%; max-width: 500px; text-align: center; box-shadow: 0 20px 60px rgba(0,0,0,0.3);">
                                    <h3 style="color: #1f2937; margin-bottom: 1rem; font-size: 1.3rem;">üü¢ ${title}</h3>
                                    <iframe 
                                        style="border-radius: 12px; margin-bottom: 1rem;" 
                                        src="${spotifyEmbedUrl}" 
                                        width="100%" 
                                        height="352" 
                                        frameborder="0" 
                                        allowtransparency="true" 
                                        allow="encrypted-media">
                                    </iframe>
                                    <p style="color: #6b7280; font-size: 0.9rem;">üé∂ In-App Spotify Player</p>
                                </div>
                            `;
                        } else {
                            audioContent = `
                                <div style="background: white; border-radius: 16px; padding: 2rem; text-align: center;">
                                    <h3 style="color: #dc2626;">‚ùå Ung√ºltige Spotify-URL</h3>
                                    <p style="color: #6b7280; margin-top: 1rem;">Bitte √ºberpr√ºfen Sie die URL</p>
                                </div>
                            `;
                        }
                        break;
                        
                    case 'audio':
                    case 'podcast':
                        audioContent = `
                            <div style="background: white; border-radius: 16px; padding: 2rem; max-width: 90vw; width: 100%; max-width: 500px; text-align: center; box-shadow: 0 20px 60px rgba(0,0,0,0.3);">
                                <h3 style="color: #1f2937; margin-bottom: 1.5rem; font-size: 1.3rem;">üéµ ${title}</h3>
                                <audio controls style="width: 100%; margin-bottom: 1.5rem; border-radius: 8px;" autoplay>
                                    <source src="${url}" type="audio/mpeg">
                                    <source src="${url}" type="audio/ogg">
                                    <source src="${url}" type="audio/wav">
                                    Ihr Browser unterst√ºtzt das Audio-Element nicht.
                                </audio>
                                <p style="color: #6b7280; font-size: 0.9rem;">üéß In-App Audio Player</p>
                            </div>
                        `;
                        break;
                        
                    default:
                        audioContent = `
                            <div style="background: white; border-radius: 16px; padding: 2rem; text-align: center;">
                                <h3 style="color: #dc2626;">‚ùå Unbekannter Audio-Typ</h3>
                                <p style="color: #6b7280; margin-top: 1rem;">Typ "${type}" wird nicht unterst√ºtzt</p>
                            </div>
                        `;
                }
                
                modal.innerHTML = `
                    ${audioContent}
                    <button 
                        style="margin-top: 30px; padding: 12px 24px; background: linear-gradient(135deg, #dc2626 0%, #991b1b 100%); color: white; border: none; border-radius: 25px; cursor: pointer; font-size: 1rem; font-weight: bold; box-shadow: 0 4px 15px rgba(220, 38, 38, 0.3); transition: all 0.3s;" 
                        onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 8px 25px rgba(220, 38, 38, 0.4)'" 
                        onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(220, 38, 38, 0.3)'"
                        onclick="event.stopPropagation(); closeAudioModal(this.parentElement)">
                        ‚úï Schlie√üen
                    </button>
                `;
                
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        e.stopPropagation();
                        closeAudioModal(modal);
                    }
                });
                
                const escapeHandler = (e) => {
                    if (e.key === 'Escape') {
                        e.stopPropagation();
                        closeAudioModal(modal);
                        document.removeEventListener('keydown', escapeHandler);
                    }
                };
                document.addEventListener('keydown', escapeHandler);
                
                modal.setAttribute('data-escape-handler', 'true');
                document.body.appendChild(modal);

                
            } catch (error) {
                console.error('Error playing audio:', error);
                showNotification('Fehler beim Abspielen der Audio-Datei', 'error');
            }
        }

        function closeAudioModal(modal) {
            try {
                if (modal && modal.parentElement) {
                    const escapeHandler = modal.getAttribute('data-escape-handler');
                    if (escapeHandler) {
                        document.removeEventListener('keydown', (e) => {
                            if (e.key === 'Escape') modal.remove();
                        });
                    }
                    modal.remove();
                }
            } catch (error) {
                console.error('Error closing audio modal:', error);
            }
        }

        function extractYouTubeId(url) {
            try {
                const regex = /(?:youtube\.com\/(?:[^\/]+\/.+\/|(?:v|e(?:mbed)?)\/|.*[?&]v=)|youtu\.be\/)([^"&?\/\s]{11})/;
                const match = url.match(regex);
                return match ? match[1] : null;
            } catch (error) {
                return null;
            }
        }

        function generateSoundCloudEmbed(url) {
            try {
                const encodedUrl = encodeURIComponent(url);
                return `https://w.soundcloud.com/player/?url=${encodedUrl}&color=%23ff5500&auto_play=true&hide_related=false&show_comments=true&show_user=true&show_reposts=false&show_teaser=true`;
            } catch (error) {
                return url;
            }
        }

        function generateSpotifyEmbed(url) {
            try {
                const spotifyRegex = /https:\/\/open\.spotify\.com\/(track|album|playlist|episode|show)\/([a-zA-Z0-9]+)/;
                const match = url.match(spotifyRegex);
                
                if (match) {
                    const [, type, id] = match;
                    return `https://open.spotify.com/embed/${type}/${id}?utm_source=generator&theme=0`;
                }
                return null;
            } catch (error) {
                return null;
            }
        }

        function showImageModal(url, title, description) {
            try {
                const modal = document.createElement('div');
                modal.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0,0,0,0.9);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 10000;
                    flex-direction: column;
                    padding: 20px;
                    box-sizing: border-box;
                `;
                
                const imageContent = !url || url === 'placeholder' ? `
                    <div style="width: 300px; height: 200px; background: #f3f4f6; border-radius: 8px; display: flex; align-items: center; justify-content: center; color: #6b7280; font-size: 3rem;">üì∑</div>
                ` : `
                    <img src="${url}" style="max-width: 90%; max-height: 70%; object-fit: contain; border-radius: 8px;" alt="${title}">
                `;
                
                modal.innerHTML = `
                    ${imageContent}
                    <div style="color: white; text-align: center; margin-top: 20px; max-width: 600px;">
                        <h3>${title}</h3>
                        <p>${description}</p>
                        <button 
                            style="margin-top: 20px; padding: 10px 20px; background: #dc2626; color: white; border: none; border-radius: 5px; cursor: pointer;" 
                            onclick="event.stopPropagation(); closeImageModal(this.parentElement.parentElement)">
                            Schlie√üen
                        </button>
                    </div>
                `;
                
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        e.stopPropagation();
                        closeImageModal(modal);
                    }
                });

                const escapeHandler = (e) => {
                    if (e.key === 'Escape') {
                        e.stopPropagation();
                        closeImageModal(modal);
                        document.removeEventListener('keydown', escapeHandler);
                    }
                };
                document.addEventListener('keydown', escapeHandler);
                
                modal.setAttribute('data-escape-handler', 'true');
                document.body.appendChild(modal);

            } catch (error) {
                console.error('Error showing image modal:', error);
            }
        }

        function closeImageModal(modal) {
            try {
                if (modal && modal.parentElement) {
                    const escapeHandler = modal.getAttribute('data-escape-handler');
                    if (escapeHandler) {
                        document.removeEventListener('keydown', (e) => {
                            if (e.key === 'Escape') modal.remove();
                        });
                    }
                    modal.remove();
                }
            } catch (error) {
                console.error('Error closing image modal:', error);
            }
        }

        function showNotification(message, type = 'success') {
            try {
                const notification = document.createElement('div');
                notification.className = `notification ${type}`;
                notification.textContent = message;
                document.body.appendChild(notification);

                setTimeout(() => {
                    notification.remove();
                }, 4000);
            } catch (error) {
                console.error('Error showing notification:', error);
            }
        }

        function saveState() {
            try {
                // Create a clean copy without circular references
                const stateToSave = {
                    currentStation: tourApp.state.currentStation,
                    completedStations: tourApp.state.completedStations,
                    totalScore: tourApp.state.totalScore,
                    selectedTeam: tourApp.state.selectedTeam,
                    teamName: tourApp.state.teamName,
                    userLocation: tourApp.state.userLocation,
                    uploadedPhotos: tourApp.state.uploadedPhotos,
                    userName: tourApp.state.userName,
                    tourId: tourApp.state.tourId,
                    isAdmin: tourApp.state.isAdmin,
                    isFirebaseConnected: tourApp.state.isFirebaseConnected,
                    connectionRetries: tourApp.state.connectionRetries,
                    maxRetries: tourApp.state.maxRetries,
                    chatModeration: tourApp.state.chatModeration,
                    chatBlocked: tourApp.state.chatBlocked,
                    tourChatLocked: tourApp.state.tourChatLocked,
                    unreadMessages: tourApp.state.unreadMessages,
                    unreadTeamMessages: tourApp.state.unreadTeamMessages,
                    currentTab: tourApp.state.currentTab,
                    currentChatTab: tourApp.state.currentChatTab
                    // Exclude: map, markers, syncListeners, stationMaps (these contain circular references)
                };
                localStorage.setItem('tourState', JSON.stringify(stateToSave));
            } catch (error) {
                console.error('Error saving state (non-critical):', error);
                // Don't throw - this is non-critical
            }
        }

        function loadState() {
            try {
                const saved = localStorage.getItem('tourState');
                if (saved) {
                    const savedState = JSON.parse(saved);
                    
                    // Safely merge saved state
                    Object.keys(savedState).forEach(key => {
                        if (key in tourApp.state && typeof savedState[key] !== 'undefined') {
                            tourApp.state[key] = savedState[key];
                        }
                    });
                    
                    if (tourApp.state.selectedTeam) {
                        setTimeout(() => {
                            updateCurrentTeamDisplay();
                            updateTeamChatTab();
                        }, 100);
                    }
                }
            } catch (error) {
                console.error('Error loading state (non-critical):', error);
                // Reset to defaults if state is corrupted
                tourApp.state.selectedTeam = null;
                tourApp.state.teamName = '';
            }
        }

        // Admin Direct Message Functions
        async function sendAdminMessage() {
            try {
                const input = document.getElementById('adminChatInputField');
                if (!input) {
                    console.error('Admin chat input not found');
                    return;
                }
                
                const message = input.value.trim();
                if (message) {
                    const messageData = {
                        userName: tourApp.state.userName,
                        message: message,
                        timestamp: firebase.firestore ? firebase.firestore.FieldValue.serverTimestamp() : Date.now(),
                        tourId: tourApp.state.tourId,
                        type: 'admin-direct',
                        isFromAdmin: tourApp.state.isAdmin,
                        targetUser: tourApp.state.isAdmin ? (currentAdminChatUser || 'admin') : 'admin'
                    };
                    
                    // Add to local UI immediately
                    addAdminChatMessage(messageData, true, tourApp.state.isAdmin ? currentAdminChatUser : 'admin');
                    
                    if (tourApp.state.isFirebaseConnected && tourApp.state.tourId) {
                        // Determine correct channel based on user role
                        let channelName;
                        let updatedMessageData = { ...messageData };
                        
                        if (tourApp.state.isAdmin && currentAdminChatUser) {
                            // Admin sending to specific user
                            channelName = `user_${currentAdminChatUser}`;
                            updatedMessageData.targetUser = currentAdminChatUser;
                        } else {
                            // User sending to admin OR admin sending from main admin chat
                            channelName = `user_${tourApp.state.userName}`;
                            updatedMessageData.targetUser = 'admin';
                        }
                        
                        // Save message to Firebase
                        await db.collection('tours').doc(tourApp.state.tourId)
                            .collection('adminDirectMessages').doc(channelName)
                            .collection('messages').add(updatedMessageData);
                        
                        // Ensure channel exists
                        await db.collection('tours').doc(tourApp.state.tourId)
                            .collection('adminDirectMessages').doc(channelName)
                            .set({
                                userName: channelName.replace('user_', ''),
                                lastActivity: firebase.firestore.FieldValue.serverTimestamp(),
                                isActive: true
                            }, { merge: true });
                        
                        console.log(`Admin message sent via channel: ${channelName}`);
                    }
                    
                    input.value = '';
                }
            } catch (error) {
                console.error('Error sending admin message:', error);
                showNotification('Fehler beim Senden der Admin-Nachricht', 'error');
            }
        }

        function selectAdminChatImage() {
            const input = document.getElementById('adminChatImageInput');
            if (input) {
                input.click();
            }
        }

        async function handleAdminChatImageUpload(event) {
            try {
                const file = event.target.files[0];
                if (!file) return;
                
                const compressedImage = await compressImage(file, 0.6, 600, 400);
                
                const messageData = {
                    userName: tourApp.state.userName,
                    image: compressedImage,
                    timestamp: firebase.firestore ? firebase.firestore.FieldValue.serverTimestamp() : Date.now(),
                    tourId: tourApp.state.tourId,
                    type: 'admin-direct-image',
                    isFromAdmin: tourApp.state.isAdmin
                };
                
                addAdminChatMessage(messageData, true);
                
                if (tourApp.state.isFirebaseConnected && tourApp.state.tourId) {
                    await db.collection('tours').doc(tourApp.state.tourId)
                        .collection('adminChat').doc(Date.now().toString())
                        .set(messageData);
                }
                
                event.target.value = '';
            } catch (error) {
                console.error('Error uploading admin chat image:', error);
                showNotification('Fehler beim Hochladen des Admin-Bildes', 'error');
            }
        }

        function addAdminChatMessage(messageData, isOwn = false, targetUser = null) {
            try {
                // Determine which container to use
                let adminChatContainer;
                
                if (tourApp.state.isAdmin && targetUser && targetUser !== 'admin') {
                    // Admin viewing specific user's chat
                    adminChatContainer = document.getElementById(`adminChatMessages_${targetUser}`);
                    if (!adminChatContainer) {
                        console.log(`Admin chat container for ${targetUser} not found, creating tab...`);
                        createAdminChatTab(targetUser);
                        adminChatContainer = document.getElementById(`adminChatMessages_${targetUser}`);
                    }
                } else {
                    // Regular admin chat container
                    adminChatContainer = document.getElementById('adminChatMessages');
                }
                
                if (!adminChatContainer) {
                    console.error('Admin chat container not found');
                    return;
                }
                
                const messageDiv = document.createElement('div');
                messageDiv.className = `chat-message ${isOwn ? 'own' : ''}`;
                
                // Admin messages have special styling
                if (messageData.isFromAdmin) {
                    messageDiv.style.background = '#fef3c7';
                    messageDiv.style.borderLeft = '4px solid #f59e0b';
                }
                
                const timeStr = new Date().toLocaleTimeString('de-DE', {
                    hour: '2-digit',
                    minute: '2-digit'
                });
                
                let messageContent = '';
                
                if (messageData.type === 'admin-direct-image') {
                    messageContent = `
                        <strong>${messageData.userName}${messageData.isFromAdmin ? ' (Admin)' : ''}:</strong> hat ein Bild geteilt<br>
                        <div class="chat-image-container">
                            <img src="${messageData.image}" class="chat-image" onclick="event.stopPropagation(); showImageModal('${messageData.image}', 'Admin Chat Bild', 'Von ${messageData.userName} geteilt')" alt="Admin Chat Bild">
                        </div>
                        <span class="timestamp">${timeStr}</span>
                    `;
                } else {
                    messageContent = `
                        <strong>${messageData.userName}${messageData.isFromAdmin ? ' (Admin)' : ''}:</strong> ${messageData.message}
                        <span class="timestamp">${timeStr}</span>
                    `;
                }

                messageDiv.innerHTML = messageContent;
                
                adminChatContainer.appendChild(messageDiv);
                adminChatContainer.scrollTop = adminChatContainer.scrollHeight;
                
                // Handle notifications
                if (!isOwn) {
                    if (tourApp.state.currentTab !== 'chat') {
                        tourApp.state.unreadAdminMessages = (tourApp.state.unreadAdminMessages || 0) + 1;
                        updateAdminChatNotification(targetUser);
                        
                        const notificationText = messageData.type === 'admin-direct-image' 
                            ? `üì∑ ${messageData.userName} hat ein Admin-Bild geteilt`
                            : `üë§ ${messageData.userName}: ${messageData.message.substring(0, 30)}${messageData.message.length > 30 ? '...' : ''}`;
                            
                        showClickableNotification(notificationText, 'admin');
                    } else if (tourApp.state.currentTab === 'chat' && !tourApp.state.currentChatTab.startsWith('admin')) {
                        tourApp.state.unreadAdminMessages = (tourApp.state.unreadAdminMessages || 0) + 1;
                        updateAdminChatNotification(targetUser);
                    }
                }
            } catch (error) {
                console.error('Error adding admin chat message:', error);
            }
        }

        function updateAdminChatNotification(targetUser = null) {
            const tabId = targetUser ? `adminChatTab_${targetUser}` : 'adminChatTab';
            const adminChatTab = document.getElementById(tabId);
            
            if (adminChatTab && tourApp.state.unreadAdminMessages > 0) {
                let notification = adminChatTab.querySelector('.tab-notification');
                if (!notification) {
                    notification = document.createElement('div');
                    notification.className = 'tab-notification';
                    notification.style.position = 'absolute';
                    notification.style.top = '5px';
                    notification.style.right = '8px';
                    adminChatTab.style.position = 'relative';
                    adminChatTab.appendChild(notification);
                }
                notification.textContent = tourApp.state.unreadAdminMessages > 9 ? '9+' : tourApp.state.unreadAdminMessages;
            }
        }

        function clearAdminChatNotification(targetUser = null) {
            tourApp.state.unreadAdminMessages = 0;
            const tabId = targetUser ? `adminChatTab_${targetUser}` : 'adminChatTab';
            const adminChatTab = document.getElementById(tabId);
            
            if (adminChatTab) {
                const notification = adminChatTab.querySelector('.tab-notification');
                if (notification) {
                    notification.remove();
                }
            }
        }

        function clearAdminChatNotification() {
            tourApp.state.unreadAdminMessages = 0;
            const adminChatTab = document.getElementById('adminChatTab');
            if (adminChatTab) {
                const notification = adminChatTab.querySelector('.tab-notification');
                if (notification) {
                    notification.remove();
                }
            }
        }

        // User Position Tracking
        let userPositionInterval = null;
        let userMarkers = {};
        let currentAdminChatUser = null; // Track which user the admin is chatting with

        function startUserPositionTracking() {
            if (userPositionInterval) return;
            
            userPositionInterval = setInterval(() => {
                if (navigator.geolocation && tourApp.state.isFirebaseConnected) {
                    navigator.geolocation.getCurrentPosition(
                        async (position) => {
                            const positionData = {
                                userName: tourApp.state.userName,
                                teamId: tourApp.state.selectedTeam,
                                teamName: tourApp.state.teamName,
                                lat: position.coords.latitude,
                                lng: position.coords.longitude,
                                timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                                accuracy: position.coords.accuracy
                            };
                            
                            // Update local position
                            tourApp.state.userLocation = {
                                lat: position.coords.latitude,
                                lng: position.coords.longitude
                            };
                            
                            // Save to Firebase
                            await db.collection('tours').doc(tourApp.state.tourId)
                                .collection('userPositions').doc(tourApp.state.userName)
                                .set(positionData);
                            
                            updateLocationInfo();
                        },
                        (error) => {
                            console.log('Position tracking error:', error);
                        }
                    );
                }
            }, 30000); // Alle 30 Sekunden
        }

        function stopUserPositionTracking() {
            if (userPositionInterval) {
                clearInterval(userPositionInterval);
                userPositionInterval = null;
            }
        }

        function updateUserMarkerOnMap(positionData) {
            if (!tourApp.state.map) return;
            
            try {
                // Remove existing marker
                if (userMarkers[positionData.userName]) {
                    tourApp.state.map.removeLayer(userMarkers[positionData.userName]);
                }
                
                // Team colors
                const teamColors = {
                    'red': '#dc2626',
                    'blue': '#2563eb', 
                    'green': '#059669',
                    'yellow': '#d97706'
                };
                
                const color = teamColors[positionData.teamId] || '#6b7280';
                
                // Create user marker
                const userIcon = L.divIcon({
                    html: `<div style="background: ${color}; width: 18px; height: 18px; border-radius: 50%; border: 3px solid white; box-shadow: 0 2px 6px rgba(0,0,0,0.3); position: relative;">
                              <div style="position: absolute; top: -25px; left: 50%; transform: translateX(-50%); background: ${color}; color: white; padding: 2px 6px; border-radius: 12px; font-size: 10px; white-space: nowrap; font-weight: bold;">
                                ${positionData.userName}
                              </div>
                           </div>`,
                    className: 'user-marker',
                    iconSize: [18, 18],
                    iconAnchor: [9, 9]
                });
                
                const marker = L.marker([positionData.lat, positionData.lng], {
                    icon: userIcon
                })
                .bindPopup(`
                    <div style="text-align: center;">
                        <strong>${positionData.userName}</strong><br>
                        ${positionData.teamName || 'Kein Team'}<br>
                        <small>Live-Position</small>
                    </div>
                `)
                .addTo(tourApp.state.map);
                
                userMarkers[positionData.userName] = marker;
                
            } catch (error) {
                console.error('Error updating user marker:', error);
            }
        }

        function removeUserMarkerFromMap(userName) {
            if (!tourApp.state.map || !userMarkers[userName]) return;
            
            try {
                tourApp.state.map.removeLayer(userMarkers[userName]);
                delete userMarkers[userName];
            } catch (error) {
                console.error('Error removing user marker:', error);
            }
        }

        // Admin Chat Tab Management
        function createAdminChatTab(userName) {
            try {
                const chatTabContainer = document.getElementById('chatTabContainer');
                if (!chatTabContainer || document.getElementById(`adminChatTab_${userName}`)) return;
                
                const adminChatTab = document.createElement('button');
                adminChatTab.id = `adminChatTab_${userName}`;
                adminChatTab.className = 'chat-sub-tab admin-chat-tab';
                adminChatTab.style.cssText = 'position: relative; min-width: 100px; font-size: 0.8rem; padding: 0.6rem 0.4rem !important;';
                adminChatTab.innerHTML = `
                    üë§ ${userName}
                    <button class="close-btn" onclick="event.stopPropagation(); closeAdminChatTab('${userName}')" 
                            style="position: absolute; top: 2px; right: 4px; background: rgba(220, 38, 38, 0.8); color: white; border: none; border-radius: 50%; width: 16px; height: 16px; font-size: 10px; cursor: pointer; display: flex; align-items: center; justify-content: center;">
                        √ó
                    </button>
                `;
                
                adminChatTab.onclick = () => showChatTab(`admin_${userName}`, adminChatTab);
                chatTabContainer.appendChild(adminChatTab);
                
                // Create chat container for this user
                const dynamicAdminChats = document.getElementById('dynamicAdminChats');
                if (dynamicAdminChats) {
                    const chatContainer = document.createElement('div');
                    chatContainer.id = `adminChatContainer_${userName}`;
                    chatContainer.className = 'chat-section';
                    chatContainer.style.display = 'none';
                    
                    chatContainer.innerHTML = `
                        <div class="admin-chat-section">
                            <div class="chat-container" id="adminChatMessages_${userName}">
                                <div class="chat-message system">
                                    <strong>Admin-Chat mit ${userName}:</strong> Direkter Kontakt üë§<br>
                                    <small>Privater Chat zwischen Admin und Benutzer</small>
                                    <span class="timestamp">jetzt</span>
                                </div>
                            </div>
                            
                            <div class="chat-input-container">
                                <input type="text" class="chat-input" placeholder="Nachricht an ${userName}..." maxlength="200">
                                <button class="chat-image-upload" onclick="selectAdminChatImage()">üì∑</button>
                                <button class="chat-send" onclick="sendAdminMessageToUser('${userName}', this)">Senden</button>
                            </div>
                        </div>
                    `;
                    
                    dynamicAdminChats.appendChild(chatContainer);
                }
                
                console.log(`Created admin chat tab for ${userName}`);
            } catch (error) {
                console.error('Error creating admin chat tab:', error);
            }
        }

        function closeAdminChatTab(userName) {
            try {
                const tab = document.getElementById(`adminChatTab_${userName}`);
                const container = document.getElementById(`adminChatContainer_${userName}`);
                
                if (tab) tab.remove();
                if (container) container.remove();
                
                // Switch to main admin chat if this was the active tab
                if (tourApp.state.currentChatTab === `admin_${userName}`) {
                    showChatTab('admin', document.getElementById('adminChatTab'));
                }
            } catch (error) {
                console.error('Error closing admin chat tab:', error);
            }
        }

        function sendAdminMessageToUser(userName, buttonElement) {
            try {
                const input = buttonElement.parentElement.querySelector('.chat-input');
                if (!input) return;
                
                const message = input.value.trim();
                if (message) {
                    currentAdminChatUser = userName;
                    
                    const messageData = {
                        userName: tourApp.state.userName,
                        message: message,
                        timestamp: firebase.firestore ? firebase.firestore.FieldValue.serverTimestamp() : Date.now(),
                        tourId: tourApp.state.tourId,
                        type: 'admin-direct',
                        isFromAdmin: true,
                        targetUser: userName
                    };
                    
                    // Add to local UI immediately
                    addAdminChatMessage(messageData, true, userName);
                    
                    if (tourApp.state.isFirebaseConnected && tourApp.state.tourId) {
                        // Send to specific user's channel
                        const channelName = `user_${userName}`;
                        
                        db.collection('tours').doc(tourApp.state.tourId)
                            .collection('adminDirectMessages').doc(channelName)
                            .collection('messages').add(messageData)
                            .then(() => {
                                console.log(`Admin message sent to ${userName} via channel ${channelName}`);
                            })
                            .catch(error => {
                                console.error('Error sending admin message:', error);
                                showNotification('Fehler beim Senden der Nachricht', 'error');
                            });
                        
                        // Ensure channel exists
                        db.collection('tours').doc(tourApp.state.tourId)
                            .collection('adminDirectMessages').doc(channelName)
                            .set({
                                userName: userName,
                                lastActivity: firebase.firestore.FieldValue.serverTimestamp(),
                                isActive: true
                            }, { merge: true });
                    }
                    
                    input.value = '';
                }
            } catch (error) {
                console.error('Error sending admin message to user:', error);
            }
        }

        // Initialize Admin Chat System
        function initializeAdminChat() {
            try {
                if (tourApp.state.isFirebaseConnected && tourApp.state.tourId) {
                    // Create initial admin direct message channel for current user
                    const channelName = `user_${tourApp.state.userName}`;
                    
                    db.collection('tours').doc(tourApp.state.tourId)
                        .collection('adminDirectMessages').doc(channelName)
                        .set({
                            userName: tourApp.state.userName,
                            lastActivity: firebase.firestore.FieldValue.serverTimestamp(),
                            isActive: true
                        }, { merge: true });
                }
            } catch (error) {
                console.error('Error initializing admin chat:', error);
            }
        }

        // Location Selection Functions
        let stationLocationMaps = {};
        let stationLocationMarkers = {};

        async function searchAddress(stationId) {
            try {
                const addressInput = document.getElementById(`edit-address-${stationId}`);
                const resultsContainer = document.getElementById(`address-results-${stationId}`);
                
                if (!addressInput || !resultsContainer) return;
                
                const query = addressInput.value.trim();
                if (!query) {
                    showNotification('Bitte gib eine Adresse ein', 'warning');
                    return;
                }
                
                // Show loading
                resultsContainer.style.display = 'block';
                resultsContainer.innerHTML = '<div style="padding: 1rem; text-align: center;">üîç Suche...</div>';
                
                // Use Nominatim API for geocoding (free OpenStreetMap service)
                const searchUrl = `https://nominatim.openstreetmap.org/search?format=json&limit=5&countrycodes=de&q=${encodeURIComponent(query + ', Deutschland')}`;
                
                const response = await fetch(searchUrl);
                const results = await response.json();
                
                if (results.length === 0) {
                    resultsContainer.innerHTML = '<div style="padding: 1rem; text-align: center; color: #6b7280;">‚ùå Keine Ergebnisse gefunden</div>';
                    return;
                }
                
                // Display results
                resultsContainer.innerHTML = results.map((result, index) => `
                    <div class="address-result" onclick="selectAddressResult(${stationId}, ${result.lat}, ${result.lon}, '${result.display_name.replace(/'/g, "\\'")}', this)" 
                         style="padding: 0.8rem; border-bottom: 1px solid #e5e7eb; cursor: pointer; transition: background 0.3s;"
                         onmouseover="this.style.background='#f3f4f6'"
                         onmouseout="this.style.background='white'">
                        <div style="font-weight: bold; color: #1f2937; margin-bottom: 0.25rem;">üìç ${result.display_name.split(',')[0]}</div>
                        <div style="font-size: 0.85rem; color: #6b7280;">${result.display_name}</div>
                        <div style="font-size: 0.8rem; color: #059669; margin-top: 0.25rem;">
                            ${parseFloat(result.lat).toFixed(6)}, ${parseFloat(result.lon).toFixed(6)}
                        </div>
                    </div>
                `).join('');
                
            } catch (error) {
                console.error('Error searching address:', error);
                const resultsContainer = document.getElementById(`address-results-${stationId}`);
                if (resultsContainer) {
                    resultsContainer.innerHTML = '<div style="padding: 1rem; text-align: center; color: #dc2626;">‚ùå Fehler bei der Adresssuche</div>';
                }
            }
        }

        function selectAddressResult(stationId, lat, lng, address, element) {
            try {
                // Update coordinates
                const latInput = document.getElementById(`edit-lat-${stationId}`);
                const lngInput = document.getElementById(`edit-lng-${stationId}`);
                
                if (latInput && lngInput) {
                    latInput.value = parseFloat(lat).toFixed(6);
                    lngInput.value = parseFloat(lng).toFixed(6);
                }
                
                // Update map
                updateStationLocationMap(stationId, lat, lng);
                
                // Hide results
                const resultsContainer = document.getElementById(`address-results-${stationId}`);
                if (resultsContainer) {
                    resultsContainer.style.display = 'none';
                }
                
                // Clear search input
                const addressInput = document.getElementById(`edit-address-${stationId}`);
                if (addressInput) {
                    addressInput.value = '';
                }
                
                showNotification(`üìç Standort gesetzt: ${address.split(',')[0]}`, 'success');
                
            } catch (error) {
                console.error('Error selecting address result:', error);
            }
        }

        function initStationLocationMap(stationId) {
            try {
                const mapContainer = document.getElementById(`location-map-${stationId}`);
                if (!mapContainer || stationLocationMaps[stationId]) return;
                
                // Wait for Leaflet if not loaded yet
                if (typeof L === 'undefined') {
                    setTimeout(() => initStationLocationMap(stationId), 500);
                    return;
                }
                
                const station = tourApp.stations.find(s => s.id === stationId);
                if (!station) return;
                
                // Create map
                const locationMap = L.map(`location-map-${stationId}`, {
                    center: [station.lat, station.lng],
                    zoom: 16,
                    scrollWheelZoom: true,
                    zoomControl: true
                });
                
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '¬© OpenStreetMap',
                    maxZoom: 19
                }).addTo(locationMap);
                
                // Add marker
                const marker = L.marker([station.lat, station.lng], {
                    draggable: true
                })
                .bindPopup(`
                    <div style="text-align: center;">
                        <h4>${station.title}</h4>
                        <p>üìç Ziehe den Marker um die Position zu √§ndern</p>
                        <small>${station.lat.toFixed(6)}, ${station.lng.toFixed(6)}</small>
                    </div>
                `)
                .addTo(locationMap);
                
                // Handle marker drag
                marker.on('dragend', function(e) {
                    const position = e.target.getLatLng();
                    updateStationCoordinates(stationId, position.lat, position.lng);
                });
                
                // Handle map click
                locationMap.on('click', function(e) {
                    const lat = e.latlng.lat;
                    const lng = e.latlng.lng;
                    
                    // Move marker to clicked position
                    marker.setLatLng([lat, lng]);
                    updateStationCoordinates(stationId, lat, lng);
                    
                    // Update popup
                    marker.setPopupContent(`
                        <div style="text-align: center;">
                            <h4>${station.title}</h4>
                            <p>‚úÖ Position aktualisiert!</p>
                            <small>${lat.toFixed(6)}, ${lng.toFixed(6)}</small>
                        </div>
                    `);
                    marker.openPopup();
                });
                
                // Store references
                stationLocationMaps[stationId] = locationMap;
                stationLocationMarkers[stationId] = marker;
                
                // Open popup initially
                setTimeout(() => {
                    marker.openPopup();
                }, 300);
                
            } catch (error) {
                console.error('Error initializing station location map:', error);
                const mapContainer = document.getElementById(`location-map-${stationId}`);
                if (mapContainer) {
                    mapContainer.innerHTML = '<div style="background: #f3f4f6; height: 100%; display: flex; align-items: center; justify-content: center; border-radius: 8px; color: #6b7280;">üó∫Ô∏è Karte nicht verf√ºgbar</div>';
                }
            }
        }

        function updateStationLocationMap(stationId, lat, lng) {
            try {
                const locationMap = stationLocationMaps[stationId];
                const marker = stationLocationMarkers[stationId];
                
                if (locationMap && marker) {
                    const newLatLng = [parseFloat(lat), parseFloat(lng)];
                    
                    // Update marker position
                    marker.setLatLng(newLatLng);
                    
                    // Center map on new position
                    locationMap.setView(newLatLng, 16);
                    
                    // Update popup
                    const station = tourApp.stations.find(s => s.id === stationId);
                    if (station) {
                        marker.setPopupContent(`
                            <div style="text-align: center;">
                                <h4>${station.title}</h4>
                                <p>‚úÖ Position aktualisiert!</p>
                                <small>${parseFloat(lat).toFixed(6)}, ${parseFloat(lng).toFixed(6)}</small>
                            </div>
                        `);
                    }
                } else {
                    // Initialize map if it doesn't exist
                    setTimeout(() => {
                        initStationLocationMap(stationId);
                        setTimeout(() => updateStationLocationMap(stationId, lat, lng), 500);
                    }, 100);
                }
            } catch (error) {
                console.error('Error updating station location map:', error);
            }
        }

        function updateStationCoordinates(stationId, lat, lng) {
            try {
                const latInput = document.getElementById(`edit-lat-${stationId}`);
                const lngInput = document.getElementById(`edit-lng-${stationId}`);
                
                if (latInput && lngInput) {
                    latInput.value = parseFloat(lat).toFixed(6);
                    lngInput.value = parseFloat(lng).toFixed(6);
                }
                
                showNotification('üìç Koordinaten aktualisiert!', 'success');
                
            } catch (error) {
                console.error('Error updating station coordinates:', error);
            }
        }

        function manualCoordinates(stationId) {
            try {
                const latInput = document.getElementById(`edit-lat-${stationId}`);
                const lngInput = document.getElementById(`edit-lng-${stationId}`);
                
                if (latInput && lngInput) {
                    const currentReadonly = latInput.readOnly;
                    
                    if (currentReadonly) {
                        // Enable manual editing
                        latInput.readOnly = false;
                        lngInput.readOnly = false;
                        latInput.style.background = 'white';
                        lngInput.style.background = 'white';
                        
                        const button = document.querySelector(`[onclick="manualCoordinates(${stationId})"]`);
                        if (button) {
                            button.textContent = 'üíæ Koordinaten speichern';
                            button.onclick = () => saveManualCoordinates(stationId);
                        }
                        
                        showNotification('‚úèÔ∏è Koordinaten k√∂nnen jetzt manuell bearbeitet werden', 'success');
                    }
                }
            } catch (error) {
                console.error('Error enabling manual coordinates:', error);
            }
        }

        function saveManualCoordinates(stationId) {
            try {
                const latInput = document.getElementById(`edit-lat-${stationId}`);
                const lngInput = document.getElementById(`edit-lng-${stationId}`);
                
                if (latInput && lngInput) {
                    const lat = parseFloat(latInput.value);
                    const lng = parseFloat(lngInput.value);
                    
                    // Validate coordinates
                    if (isNaN(lat) || isNaN(lng) || lat < -90 || lat > 90 || lng < -180 || lng > 180) {
                        showNotification('‚ùå Ung√ºltige Koordinaten! Breitengrad: -90 bis 90, L√§ngengrad: -180 bis 180', 'error');
                        return;
                    }
                    
                    // Disable editing
                    latInput.readOnly = true;
                    lngInput.readOnly = true;
                    latInput.style.background = '#f3f4f6';
                    lngInput.style.background = '#f3f4f6';
                    
                    // Update map
                    updateStationLocationMap(stationId, lat, lng);
                    
                    const button = document.querySelector(`[onclick="saveManualCoordinates(${stationId})"]`);
                    if (button) {
                        button.textContent = '‚úèÔ∏è Koordinaten manuell bearbeiten';
                        button.onclick = () => manualCoordinates(stationId);
                    }
                    
                    showNotification('üíæ Koordinaten gespeichert!', 'success');
                }
            } catch (error) {
                console.error('Error saving manual coordinates:', error);
            }
        }
        
        // Tour Export/Import Functions
        async function exportTourData() {
            try {
                const exportData = {
                    version: "1.0",
                    exportDate: new Date().toISOString(),
                    tourId: tourApp.state.tourId,
                    stations: tourApp.stations.map(station => ({
                        ...station,
                        // Ensure all data is included with proper number conversion
                        id: station.id,
                        title: station.title,
                        subtitle: station.subtitle,
                        lat: parseFloat(station.lat),
                        lng: parseFloat(station.lng),
                        description: station.description,
                        photoChallenge: station.photoChallenge,
                        mainText: station.mainText,
                        images: station.images || [],
                        audio: station.audio || []
                    })),
                    metadata: {
                        totalStations: tourApp.stations.length,
                        exportedBy: tourApp.state.userName,
                        isAdmin: tourApp.state.isAdmin
                    }
                };

                // Create download
                const dataStr = JSON.stringify(exportData, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                
                const link = document.createElement('a');
                link.href = URL.createObjectURL(dataBlob);
                link.download = `koeln-tour-${tourApp.state.tourId}-${new Date().toISOString().split('T')[0]}.json`;
                
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                showNotification('Tour erfolgreich exportiert! üì§');
                addSystemMessage(`Admin hat Tour-Daten exportiert! üì¶`);
                
            } catch (error) {
                console.error('Error exporting tour data:', error);
                showNotification('Fehler beim Exportieren der Tour-Daten', 'error');
            }
        }

        async function importTourData(event) {
            try {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = async (e) => {
                    try {
                        const importData = JSON.parse(e.target.result);
                        
                        // Validate import data
                        if (!importData.version || !importData.stations) {
                            throw new Error('Ung√ºltiges Tour-Datei-Format');
                        }

                        if (!confirm(`Tour importieren?\n\nDatenmenge: ${importData.stations.length} Stationen\nExportiert am: ${new Date(importData.exportDate).toLocaleString('de-DE')}\nExportiert von: ${importData.metadata?.exportedBy || 'Unbekannt'}\n\n‚ö†Ô∏è Alle aktuellen Stationen werden ersetzt!`)) {
                            return;
                        }

                        // Import stations with proper coordinate conversion
                        tourApp.stations = importData.stations.map(station => ({
                            ...station,
                            // Ensure required fields exist with proper data types
                            lat: parseFloat(station.lat) || 50.9375,
                            lng: parseFloat(station.lng) || 6.9597,
                            images: station.images || [],
                            audio: station.audio || []
                        }));

                        // Save to Firebase if connected
                        if (tourApp.state.isFirebaseConnected && tourApp.state.tourId) {
                            // Clear existing stations in Firebase
                            const stationsRef = db.collection('tours').doc(tourApp.state.tourId).collection('stations');
                            const snapshot = await stationsRef.get();
                            const batch = db.batch();
                            snapshot.docs.forEach((doc) => {
                                batch.delete(doc.ref);
                            });
                            await batch.commit();

                            // Import new stations to Firebase
                            for (const station of tourApp.stations) {
                                await saveToFirebase('stations', station.id.toString(), station);
                            }
                        }

                        // Reset user progress for imported tour
                        tourApp.state.completedStations = [];
                        tourApp.state.totalScore = 0;
                        tourApp.state.uploadedPhotos = [];

                        // Update UI
                        generateStationsList();
                        generateContentEditor();
                        updateProgress();
                        updateUI();
                        
                        if (tourApp.state.map) {
                            updateMapMarkers();
                        }

                        saveState();
                        showNotification(`Tour erfolgreich importiert! ${importData.stations.length} Stationen geladen üì•`);
                        addSystemMessage(`Admin hat neue Tour-Daten importiert! ${importData.stations.length} Stationen üì¶`);

                    } catch (parseError) {
                        console.error('Error parsing import file:', parseError);
                        showNotification('Fehler beim Lesen der Import-Datei: ' + parseError.message, 'error');
                    }
                };
                
                reader.readAsText(file);
                
                // Reset file input
                event.target.value = '';
                
            } catch (error) {
                console.error('Error importing tour data:', error);
                showNotification('Fehler beim Importieren der Tour-Daten', 'error');
            }
        }

        // Auto-delete chat messages after 24 hours
        async function cleanupOldChatMessages() {
            try {
                if (!tourApp.state.isFirebaseConnected || !tourApp.state.tourId) return;

                const now = Date.now();
                const twentyFourHoursAgo = now - (24 * 60 * 60 * 1000);

                // Clean main chat
                const chatRef = db.collection('tours').doc(tourApp.state.tourId).collection('chat');
                const oldChatMessages = await chatRef.where('timestamp', '<', twentyFourHoursAgo).get();

                if (!oldChatMessages.empty) {
                    const batch = db.batch();
                    oldChatMessages.docs.forEach((doc) => {
                        batch.delete(doc.ref);
                    });
                    await batch.commit();
                    console.log(`üóëÔ∏è Deleted ${oldChatMessages.docs.length} old chat messages`);
                }

                // Clean team chats
                const teamChatRef = db.collection('tours').doc(tourApp.state.tourId).collection('teamChat');
                const teamSnapshot = await teamChatRef.get();
                
                for (const teamDoc of teamSnapshot.docs) {
                    const messagesRef = teamDoc.ref.collection('messages');
                    const oldTeamMessages = await messagesRef.where('timestamp', '<', twentyFourHoursAgo).get();
                    
                    if (!oldTeamMessages.empty) {
                        const teamBatch = db.batch();
                        oldTeamMessages.docs.forEach((messageDoc) => {
                            teamBatch.delete(messageDoc.ref);
                        });
                        await teamBatch.commit();
                        console.log(`üóëÔ∏è Deleted ${oldTeamMessages.docs.length} old team messages for ${teamDoc.id}`);
                    }
                }

                // Clean admin direct messages
                const adminDirectRef = db.collection('tours').doc(tourApp.state.tourId).collection('adminDirectMessages');
                const adminDirectSnapshot = await adminDirectRef.get();
                
                for (const channelDoc of adminDirectSnapshot.docs) {
                    const messagesRef = channelDoc.ref.collection('messages');
                    const oldAdminMessages = await messagesRef.where('timestamp', '<', twentyFourHoursAgo).get();
                    
                    if (!oldAdminMessages.empty) {
                        const adminBatch = db.batch();
                        oldAdminMessages.docs.forEach((messageDoc) => {
                            adminBatch.delete(messageDoc.ref);
                        });
                        await adminBatch.commit();
                        console.log(`üóëÔ∏è Deleted ${oldAdminMessages.docs.length} old admin messages for ${channelDoc.id}`);
                    }
                }

                // Clean local storage chat data
                const chatKey = `chat_${tourApp.state.tourId}`;
                const localChatMessages = JSON.parse(localStorage.getItem(chatKey) || '[]');
                const filteredMessages = localChatMessages.filter(msg => {
                    const messageTime = msg.timestamp || 0;
                    return messageTime > twentyFourHoursAgo;
                });
                
                if (filteredMessages.length !== localChatMessages.length) {
                    localStorage.setItem(chatKey, JSON.stringify(filteredMessages));
                    console.log(`üóëÔ∏è Cleaned ${localChatMessages.length - filteredMessages.length} old local chat messages`);
                }

                // Clean team chat local storage
                Object.keys(localStorage).forEach(key => {
                    if (key.startsWith(`teamChat_${tourApp.state.tourId}_`)) {
                        const teamMessages = JSON.parse(localStorage.getItem(key) || '[]');
                        const filteredTeamMessages = teamMessages.filter(msg => {
                            const messageTime = msg.timestamp || 0;
                            return messageTime > twentyFourHoursAgo;
                        });
                        
                        if (filteredTeamMessages.length !== teamMessages.length) {
                            localStorage.setItem(key, JSON.stringify(filteredTeamMessages));
                            console.log(`üóëÔ∏è Cleaned ${teamMessages.length - filteredTeamMessages.length} old local team messages for ${key}`);
                        }
                    }
                });

            } catch (error) {
                console.error('Error cleaning up old chat messages:', error);
            }
        }

        // Start cleanup interval (runs every hour)
        let chatCleanupInterval = null;

        function startChatCleanup() {
            if (chatCleanupInterval) return;
            
            // Run cleanup immediately and then every hour
            cleanupOldChatMessages();
            
            chatCleanupInterval = setInterval(() => {
                cleanupOldChatMessages();
            }, 60 * 60 * 1000); // Every hour
        }

        function stopChatCleanup() {
            if (chatCleanupInterval) {
                clearInterval(chatCleanupInterval);
                chatCleanupInterval = null;
            }
        }

        // Admin Tab Management
        function showAdminTab(tabType, tabElement) {
            try {
                // Update tab appearance
                document.querySelectorAll('.admin-sub-tab').forEach(tab => {
                    tab.classList.remove('active');
                    tab.style.color = '#6b7280';
                    tab.style.borderBottom = '3px solid transparent';
                });
                
                if (tabElement) {
                    tabElement.classList.add('active');
                    tabElement.style.color = '#dc2626';
                    tabElement.style.borderBottom = '3px solid #dc2626';
                }

                // Show/hide sections
                document.querySelectorAll('.admin-section').forEach(section => {
                    section.classList.remove('active');
                    section.style.display = 'none';
                });
                
                const targetSection = document.getElementById(tabType + 'Section');
                if (targetSection) {
                    targetSection.classList.add('active');
                    targetSection.style.display = 'block';
                }

                // Load content for specific tabs
                if (tabType === 'planning') {
                    setTimeout(() => generateContentEditor(), 100);
                } else if (tabType === 'live') {
                    setTimeout(() => refreshAdminStats(), 100);
                }
            } catch (error) {
                console.error('Error showing admin tab:', error);
            }
        }

        // Tour Settings Functions
        async function saveTourSettings() {
            try {
                const tourSettings = {
                    title: document.getElementById('editTourTitle').value.trim(),
                    subtitle: document.getElementById('editTourSubtitle').value.trim(),
                    duration: document.getElementById('editTourDuration').value.trim(),
                    start: document.getElementById('editTourStart').value.trim(),
                    end: document.getElementById('editTourEnd').value.trim(),
                    participants: document.getElementById('editTourParticipants').value.trim(),
                    goal: document.getElementById('editTourGoal').value.trim()
                };

                // Update UI immediately
                document.getElementById('tourTitle').textContent = tourSettings.title;
                document.getElementById('tourSubtitle').textContent = tourSettings.subtitle;
                document.getElementById('tourDuration').textContent = tourSettings.duration;
                document.getElementById('tourStart').textContent = tourSettings.start;
                document.getElementById('tourEnd').textContent = tourSettings.end;
                document.getElementById('tourParticipants').textContent = tourSettings.participants;
                document.getElementById('tourGoal').textContent = tourSettings.goal;

                // Save to Firebase
                if (tourApp.state.isFirebaseConnected && tourApp.state.tourId) {
                    await saveToFirebase('settings', 'tour', tourSettings);
                }

                // Save to localStorage as backup
                localStorage.setItem(`tourSettings_${tourApp.state.tourId}`, JSON.stringify(tourSettings));

                showNotification('Tour-Einstellungen gespeichert! ‚úÖ');
                addSystemMessage('Admin hat die Tour-Einstellungen aktualisiert! ‚öôÔ∏è');

            } catch (error) {
                console.error('Error saving tour settings:', error);
                showNotification('Fehler beim Speichern der Einstellungen', 'error');
            }
        }

        // Load Tour Settings
        async function loadTourSettings() {
            try {
                let tourSettings = null;

                // Try to load from Firebase first
                if (tourApp.state.isFirebaseConnected && tourApp.state.tourId) {
                    const firebaseSettings = await getFromFirebase('settings');
                    const tourSetting = firebaseSettings.find(s => s.id === 'tour');
                    if (tourSetting) {
                        tourSettings = tourSetting;
                    }
                }

                // Fallback to localStorage
                if (!tourSettings) {
                    const localSettings = localStorage.getItem(`tourSettings_${tourApp.state.tourId}`);
                    if (localSettings) {
                        tourSettings = JSON.parse(localSettings);
                    }
                }

                // Apply settings if found
                if (tourSettings) {
                    // Update UI
                    if (tourSettings.title) document.getElementById('tourTitle').textContent = tourSettings.title;
                    if (tourSettings.subtitle) document.getElementById('tourSubtitle').textContent = tourSettings.subtitle;
                    if (tourSettings.duration) document.getElementById('tourDuration').textContent = tourSettings.duration;
                    if (tourSettings.start) document.getElementById('tourStart').textContent = tourSettings.start;
                    if (tourSettings.end) document.getElementById('tourEnd').textContent = tourSettings.end;
                    if (tourSettings.participants) document.getElementById('tourParticipants').textContent = tourSettings.participants;
                    if (tourSettings.goal) document.getElementById('tourGoal').textContent = tourSettings.goal;

                    // Update form fields if they exist
                    if (document.getElementById('editTourTitle')) document.getElementById('editTourTitle').value = tourSettings.title || '';
                    if (document.getElementById('editTourSubtitle')) document.getElementById('editTourSubtitle').value = tourSettings.subtitle || '';
                    if (document.getElementById('editTourDuration')) document.getElementById('editTourDuration').value = tourSettings.duration || '';
                    if (document.getElementById('editTourStart')) document.getElementById('editTourStart').value = tourSettings.start || '';
                    if (document.getElementById('editTourEnd')) document.getElementById('editTourEnd').value = tourSettings.end || '';
                    if (document.getElementById('editTourParticipants')) document.getElementById('editTourParticipants').value = tourSettings.participants || '';
                    if (document.getElementById('editTourGoal')) document.getElementById('editTourGoal').value = tourSettings.goal || '';
                }
            } catch (error) {
                console.error('Error loading tour settings:', error);
            }
        }

        // Quick Station Update Modal
        function showQuickStationUpdate() {
            try {
                const modal = document.createElement('div');
                modal.className = 'admin-popup-overlay';
                
                const stationOptions = tourApp.stations.map(station => 
                    `<option value="${station.id}">Station ${station.id}: ${station.title}</option>`
                ).join('');

                modal.innerHTML = `
                    <div class="admin-popup" style="max-width: 500px; width: 90%;">
                        <h3>‚ö° Station schnell bearbeiten</h3>
                        <div style="margin: 1rem 0;">
                            <label style="display: block; font-weight: bold; margin-bottom: 0.5rem;">Station ausw√§hlen:</label>
                            <select id="quickStationSelect" style="width: 100%; padding: 0.8rem; border: 2px solid #e5e7eb; border-radius: 8px; font-size: 1rem;">
                                <option value="">Station w√§hlen...</option>
                                ${stationOptions}
                            </select>
                        </div>
                        <div style="display: flex; gap: 1rem; margin-top: 1.5rem;">
                            <button class="admin-popup-close" onclick="closeQuickStationModal(this.parentElement.parentElement)" style="flex: 1;">
                                Abbrechen
                            </button>
                            <button onclick="openQuickStationEdit()" style="flex: 1; background: #dc2626; color: white; border: none; padding: 0.8rem 2rem; border-radius: 25px; font-weight: bold; cursor: pointer;">
                                Bearbeiten
                            </button>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(modal);

                // Add escape key handler
                const escapeHandler = (e) => {
                    if (e.key === 'Escape') {
                        modal.remove();
                        document.removeEventListener('keydown', escapeHandler);
                    }
                };
                document.addEventListener('keydown', escapeHandler);

            } catch (error) {
                console.error('Error showing quick station update:', error);
            }
        }

        function closeQuickStationModal(modal) {
            if (modal && modal.parentElement) {
                modal.remove();
            }
        }

        function openQuickStationEdit() {
            try {
                const stationId = document.getElementById('quickStationSelect').value;
                if (!stationId) {
                    showNotification('Bitte w√§hle eine Station aus!', 'error');
                    return;
                }

                // Close modal
                const modal = document.querySelector('.admin-popup-overlay');
                if (modal) modal.remove();

                // Switch to planning tab
                showAdminTab('planning', document.querySelector('[onclick*="planning"]'));

                // Open station editor after a short delay
                setTimeout(() => {
                    const stationEditor = document.getElementById(`admin-station-${stationId}`);
                    if (stationEditor) {
                        stationEditor.scrollIntoView({ behavior: 'smooth' });
                        setTimeout(() => toggleStationEditor(parseInt(stationId)), 500);
                    }
                }, 300);

            } catch (error) {
                console.error('Error opening quick station edit:', error);
            }
        }

        // AI Content Integration Functions
        function showPerplexityHelper(stationId, fieldType) {
            try {
                const station = tourApp.stations.find(s => s.id === stationId);
                if (!station) return;

                const modal = document.createElement('div');
                modal.className = 'admin-popup-overlay';
                
                let promptSuggestions = '';
                let targetField = '';
                
                switch(fieldType) {
                    case 'mainText':
                        targetField = `edit-maintext-${stationId}`;
                        promptSuggestions = `
                            <h4>üí° Vorschl√§ge f√ºr Perplexity:</h4>
                            <div style="background: #f0f9ff; padding: 1rem; border-radius: 8px; margin: 1rem 0;">
                                <p><strong>Beispiel-Prompts:</strong></p>
                                <ul style="margin-left: 1.5rem; margin-top: 0.5rem;">
                                    <li>"Geschichte von ${station.title} in K√∂ln, interessante historische Fakten"</li>
                                    <li>"Was passierte historisch am ${station.title} in K√∂ln?"</li>
                                    <li>"Architektur und Bedeutung von ${station.title} K√∂ln"</li>
                                </ul>
                            </div>
                        `;
                        break;
                    case 'photoChallenge':
                        targetField = `edit-challenge-${stationId}`;
                        promptSuggestions = `
                            <h4>üí° Vorschl√§ge f√ºr Perplexity:</h4>
                            <div style="background: #f0f9ff; padding: 1rem; border-radius: 8px; margin: 1rem 0;">
                                <p><strong>Beispiel-Prompts:</strong></p>
                                <ul style="margin-left: 1.5rem; margin-top: 0.5rem;">
                                    <li>"Kreative Foto-Ideen f√ºr ${station.title} in K√∂ln"</li>
                                    <li>"Interessante Fotoperspektiven und Winkel f√ºr ${station.title}"</li>
                                    <li>"Gruppenfoto-Ideen mit historischem Bezug zu ${station.title}"</li>
                                </ul>
                            </div>
                        `;
                        break;
                }

                modal.innerHTML = `
                    <div class="admin-popup" style="max-width: 600px; width: 95%;">
                        <h3>ü§ñ KI-Textgenerator</h3>
                        <p>Lasse dir von Perplexity.ai Texte f√ºr <strong>${station.title}</strong> generieren:</p>
                        
                        ${promptSuggestions}
                        
                        <div style="margin: 1rem 0;">
                            <label style="display: block; font-weight: bold; margin-bottom: 0.5rem;">Dein Prompt:</label>
                            <textarea id="aiPromptText" style="width: 100%; min-height: 80px; padding: 0.8rem; border: 2px solid #e5e7eb; border-radius: 8px; font-size: 0.9rem;" placeholder="Beschreibe, welchen Text du generieren m√∂chtest..."></textarea>
                        </div>
                        
                        <div style="margin: 1rem 0;">
                            <label style="display: block; font-weight: bold; margin-bottom: 0.5rem;">Generierter Text:</label>
                            <textarea id="aiGeneratedText" style="width: 100%; min-height: 120px; padding: 0.8rem; border: 2px solid #e5e7eb; border-radius: 8px; font-size: 0.9rem;" placeholder="Hier den generierten Text aus Perplexity einf√ºgen..."></textarea>
                        </div>
                        
                        <div style="display: flex; gap: 1rem; margin-top: 1.5rem; flex-wrap: wrap;">
                            <button onclick="openPerplexity()" style="flex: 1; min-width: 120px; background: #059669; color: white; border: none; padding: 0.8rem 1rem; border-radius: 25px; font-weight: bold; cursor: pointer;">
                                üåê Perplexity √∂ffnen
                            </button>
                            <button onclick="insertAIText('${targetField}')" style="flex: 1; min-width: 120px; background: #dc2626; color: white; border: none; padding: 0.8rem 1rem; border-radius: 25px; font-weight: bold; cursor: pointer;">
                                ‚úÖ Text einf√ºgen
                            </button>
                            <button class="admin-popup-close" onclick="closeAIModal(this.parentElement.parentElement)" style="flex: 1; min-width: 120px;">
                                Abbrechen
                            </button>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(modal);

                // Add escape key handler
                const escapeHandler = (e) => {
                    if (e.key === 'Escape') {
                        modal.remove();
                        document.removeEventListener('keydown', escapeHandler);
                    }
                };
                document.addEventListener('keydown', escapeHandler);

            } catch (error) {
                console.error('Error showing Perplexity helper:', error);
            }
        }

        function openPerplexity() {
            const promptText = document.getElementById('aiPromptText').value.trim();
            let url = 'https://www.perplexity.ai/';
            
            if (promptText) {
                url += '?q=' + encodeURIComponent(promptText);
            }
            
            window.open(url, '_blank');
            showNotification('Perplexity in neuem Tab ge√∂ffnet! üåê');
        }

        function insertAIText(targetFieldId) {
           try {
               const generatedText = document.getElementById('aiGeneratedText').value.trim();
               if (!generatedText) {
                   showNotification('Bitte f√ºge den generierten Text ein!', 'error');
                   return;
               }

               const targetField = document.getElementById(targetFieldId);
               if (targetField) {
                   targetField.value = generatedText;
                   showNotification('KI-Text eingef√ºgt! ü§ñ');
                   
                   // Close modal
                   const modal = document.querySelector('.admin-popup-overlay');
                   if (modal) modal.remove();
               } else {
                   showNotification('Zielfeld nicht gefunden!', 'error');
               }
           } catch (error) {
               console.error('Error inserting AI text:', error);
           }
       }

       function closeAIModal(modal) {
            try {
                if (modal && modal.parentElement) {
                    modal.remove();
                } else {
                    // Fallback: Remove all overlay modals
                    document.querySelectorAll('.admin-popup-overlay').forEach(overlay => {
                        overlay.remove();
                    });
                }
            } catch (error) {
                console.error('Error closing AI modal:', error);
            }
        }

       // Media Search Functions
       function showMediaSearchHelper(stationId, mediaType, mediaIndex = null) {
           try {
               const station = tourApp.stations.find(s => s.id === stationId);
               if (!station) return;

               const modal = document.createElement('div');
               modal.className = 'admin-popup-overlay';
               
               let searchPlaceholder = '';
               let searchExamples = '';
               let searchUrl = '';
               
               switch(mediaType) {
                   case 'image':
                       searchPlaceholder = 'z.B. "K√∂lner Dom historisch" oder "Heumarkt K√∂ln"';
                       searchExamples = `
                           <li>"${station.title} K√∂ln historisch"</li>
                           <li>"${station.title} Architektur"</li>
                           <li>"K√∂ln ${station.title} heute"</li>
                       `;
                       searchUrl = 'https://www.google.com/search?tbm=isch&q=';
                       break;
                   case 'youtube':
                       searchPlaceholder = 'z.B. "K√∂lner Dom Dokumentation" oder "Geschichte K√∂ln"';
                       searchExamples = `
                           <li>"${station.title} K√∂ln Geschichte"</li>
                           <li>"${station.title} Dokumentation"</li>
                           <li>"K√∂ln Stadtf√ºhrung ${station.title}"</li>
                       `;
                       searchUrl = 'https://www.youtube.com/results?search_query=';
                       break;
                   case 'soundcloud':
                       searchPlaceholder = 'z.B. "K√∂ln Stadtger√§usche" oder "Rhein Atmosph√§re"';
                       searchExamples = `
                           <li>"K√∂ln Stadtger√§usche"</li>
                           <li>"${station.title} Atmosph√§re"</li>
                           <li>"Rhein K√∂ln Audio"</li>
                       `;
                       searchUrl = 'https://soundcloud.com/search?q=';
                       break;
               }

               const mediaTypeIcon = {
                   'image': 'üñºÔ∏è',
                   'youtube': 'üì∫', 
                   'soundcloud': '‚òÅÔ∏è'
               };

               modal.innerHTML = `
                   <div class="admin-popup" style="max-width: 600px; width: 95%;">
                       <h3>${mediaTypeIcon[mediaType]} ${mediaType === 'image' ? 'Bilder' : mediaType === 'youtube' ? 'YouTube Videos' : 'SoundCloud Audio'} suchen</h3>
                       <p>Suche nach Medien f√ºr <strong>${station.title}</strong>:</p>
                       
                       <div style="background: #f0f9ff; padding: 1rem; border-radius: 8px; margin: 1rem 0;">
                           <h4>üí° Suchvorschl√§ge:</h4>
                           <ul style="margin-left: 1.5rem; margin-top: 0.5rem;">
                               ${searchExamples}
                           </ul>
                       </div>
                       
                       <div style="margin: 1rem 0;">
                           <label style="display: block; font-weight: bold; margin-bottom: 0.5rem;">Suchbegriff:</label>
                           <input type="text" id="mediaSearchTerm" style="width: 100%; padding: 0.8rem; border: 2px solid #e5e7eb; border-radius: 8px; font-size: 1rem;" placeholder="${searchPlaceholder}">
                       </div>
                       
                       <div style="margin: 1rem 0;">
                           <label style="display: block; font-weight: bold; margin-bottom: 0.5rem;">Gefundene URL:</label>
                           <input type="url" id="foundMediaUrl" style="width: 100%; padding: 0.8rem; border: 2px solid #e5e7eb; border-radius: 8px; font-size: 1rem;" placeholder="Hier die gefundene URL einf√ºgen...">
                       </div>
                       
                       <div style="margin: 1rem 0;">
                           <label style="display: block; font-weight: bold; margin-bottom: 0.5rem;">Titel/Beschreibung:</label>
                           <input type="text" id="mediaTitle" style="width: 100%; padding: 0.8rem; border: 2px solid #e5e7eb; border-radius: 8px; font-size: 1rem;" placeholder="Titel oder Beschreibung des Mediums...">
                       </div>
                       
                       <div style="display: flex; gap: 1rem; margin-top: 1.5rem; flex-wrap: wrap;">
                           <button onclick="openMediaSearch('${searchUrl}')" style="flex: 1; min-width: 120px; background: #059669; color: white; border: none; padding: 0.8rem 1rem; border-radius: 25px; font-weight: bold; cursor: pointer;">
                               üîç Suche √∂ffnen
                           </button>
                           <button onclick="insertFoundMedia(${stationId}, '${mediaType}', ${mediaIndex})" style="flex: 1; min-width: 120px; background: #dc2626; color: white; border: none; padding: 0.8rem 1rem; border-radius: 25px; font-weight: bold; cursor: pointer;">
                               ‚úÖ URL einf√ºgen
                           </button>
                           <button class="admin-popup-close" onclick="closeMediaModal(this.parentElement.parentElement)" style="flex: 1; min-width: 120px;">
                               Abbrechen
                           </button>
                       </div>
                   </div>
               `;
               
               document.body.appendChild(modal);
                // Add escape key handler
                const escapeHandler = (e) => {
                    if (e.key === 'Escape') {
                        modal.remove();
                        document.removeEventListener('keydown', escapeHandler);
                    }
                };
                document.addEventListener('keydown', escapeHandler);

           } catch (error) {
               console.error('Error showing media search helper:', error);
           }
       }

       function openMediaSearch(baseUrl) {
           const searchTerm = document.getElementById('mediaSearchTerm').value.trim();
           let url = baseUrl;
           
           if (searchTerm) {
               url += encodeURIComponent(searchTerm);
           }
           
           window.open(url, '_blank');
           showNotification('Suche in neuem Tab ge√∂ffnet! üîç');
       }

       function insertFoundMedia(stationId, mediaType, mediaIndex) {
           try {
               const foundUrl = document.getElementById('foundMediaUrl').value.trim();
               const mediaTitle = document.getElementById('mediaTitle').value.trim();
               
               if (!foundUrl) {
                   showNotification('Bitte f√ºge eine URL ein!', 'error');
                   return;
               }

               const station = tourApp.stations.find(s => s.id === stationId);
               if (!station) return;

               if (mediaType === 'image') {
                   if (!station.images) station.images = [];
                   
                   if (mediaIndex !== null && mediaIndex >= 0) {
                       // Update existing image
                       station.images[mediaIndex].url = foundUrl;
                       if (mediaTitle) station.images[mediaIndex].title = mediaTitle;
                   } else {
                       // Add new image
                       station.images.push({
                           title: mediaTitle || 'Neues Bild',
                           description: '√úber Mediensuche hinzugef√ºgt',
                           url: foundUrl
                       });
                   }
                   
                   // Refresh image editor
                   const editorContainer = document.getElementById(`image-editor-${stationId}`);
                   if (editorContainer) {
                       editorContainer.innerHTML = generateImageEditor(station);
                   }
                   
               } else {
                   // Audio/Video
                   if (!station.audio) station.audio = [];
                   
                   const audioType = mediaType === 'youtube' ? 'youtube' : 'soundcloud';
                   
                   if (mediaIndex !== null && mediaIndex >= 0) {
                       // Update existing audio
                       station.audio[mediaIndex].url = foundUrl;
                       station.audio[mediaIndex].type = audioType;
                       if (mediaTitle) station.audio[mediaIndex].title = mediaTitle;
                   } else {
                       // Add new audio
                       station.audio.push({
                           title: mediaTitle || 'Neues Audio',
                           description: '√úber Mediensuche hinzugef√ºgt',
                           url: foundUrl,
                           type: audioType
                       });
                   }
                   
                   // Refresh audio editor
                   const editorContainer = document.getElementById(`audio-editor-${stationId}`);
                   if (editorContainer) {
                       editorContainer.innerHTML = generateAudioEditor(station);
                   }
               }

               showNotification(`${mediaType === 'image' ? 'Bild' : 'Audio'} hinzugef√ºgt! ‚úÖ`);
               
               // Close modal
               const modal = document.querySelector('.admin-popup-overlay');
               if (modal) modal.remove();

           } catch (error) {
               console.error('Error inserting found media:', error);
               showNotification('Fehler beim Einf√ºgen des Mediums', 'error');
           }
       }

       function closeMediaModal(modal) {
            try {
                if (modal && modal.parentElement) {
                    modal.remove();
                } else {
                    // Fallback: Remove all overlay modals
                    document.querySelectorAll('.admin-popup-overlay').forEach(overlay => {
                        overlay.remove();
                    });
                }
            } catch (error) {
                console.error('Error closing media modal:', error);
            }
        }


        // Global window functions for HTML onclick handlers
        window.showAdminTab = showAdminTab;
        window.saveTourSettings = saveTourSettings;
        window.showQuickStationUpdate = showQuickStationUpdate;
        window.openQuickStationEdit = openQuickStationEdit;
        window.closeQuickStationModal = closeQuickStationModal;
        window.showPerplexityHelper = showPerplexityHelper;
        window.openPerplexity = openPerplexity;  
        window.insertAIText = insertAIText;
        window.closeAIModal = closeAIModal;
        window.showMediaSearchHelper = showMediaSearchHelper;
        window.openMediaSearch = openMediaSearch;
        window.insertFoundMedia = insertFoundMedia;
        window.closeMediaModal = closeMediaModal;
        window.setWelcomeName = setWelcomeName;
        window.closeWelcomeModal = closeWelcomeModal;

        async function selectTeam(teamId, teamName, element) {
            try {
                const oldTeam = tourApp.state.selectedTeam;
                const oldTeamName = tourApp.state.teamName;
                
                tourApp.state.selectedTeam = teamId;
                tourApp.state.teamName = teamName;
                
                // Update team membership
                updateTeamMembership(teamId).catch(error => console.error('Error updating team membership:', error));
                
                // Update UI
                document.querySelectorAll('.team-option').forEach(option => {
                    option.classList.remove('selected');
                });
                if (element) {
                    element.classList.add('selected');
                }
                
                updateCurrentTeamDisplay();
                updateTeamChatTab();
                
                // Show team chat tab when user joins a team
                const teamChatTab = document.getElementById('teamChatTab');
                if (teamChatTab) {
                    teamChatTab.style.display = 'block';
                }
                
                // Update localStorage with selected team
                try {
                    const stateToSave = {
                        selectedTeam: tourApp.state.selectedTeam,
                        teamName: tourApp.state.teamName,
                        userName: tourApp.state.userName,
                        tourId: tourApp.state.tourId,
                        isAdmin: tourApp.state.isAdmin
                    };
                    localStorage.setItem('tourState', JSON.stringify(stateToSave));
                } catch (saveError) {
                    console.log('State save skipped due to circular reference');
                }
                
                // Broadcast team change
                if (oldTeam !== teamId && oldTeam) {
                    addSystemMessage(`${tourApp.state.userName} ist von ${teamNames[oldTeam] || oldTeamName} zu ${teamName} gewechselt! üîÑ`);
                } else if (!oldTeam) {
                    addSystemMessage(`${tourApp.state.userName} ist ${teamName} beigetreten! üëã`);
                }
                
                showNotification(`Du bist jetzt in ${teamName}! üéâ`);
                
                // Auto-load team chat history
                setTimeout(() => loadChatHistory(), 300);
                
            } catch (error) {
                console.error('Error selecting team:', error);
                showNotification('Fehler beim Team-Beitritt', 'error');
            }
        }

        window.changeUserName = function() {
            try {
                const input = document.getElementById('userNameInput');
                const newName = input.value.trim();
                
                if (newName && newName.length >= 2) {
                    const oldName = tourApp.state.userName;
                    tourApp.state.userName = newName;
                    
                    const displayEl = document.getElementById('currentUserName');
                    if (displayEl) {
                        displayEl.textContent = newName;
                    }
                    
                    input.value = '';
                    saveState();
                    showNotification('Name ge√§ndert! üë§');
                    addSystemMessage(`${oldName} hei√üt jetzt ${newName}! üë§`);
                } else {
                    showNotification('Name muss mindestens 2 Zeichen haben!', 'error');
                }
            } catch (error) {
                console.error('Error changing user name:', error);
            }
        }

        window.startTour = function() {
            try {
                if (!tourApp.state.selectedTeam) {
                    showNotification('Bitte w√§hle zuerst ein Team aus!', 'error');
                    return;
                }
                
                window.showTab('stations', document.querySelector('.tab[onclick*="stations"]'));
                showNotification('Tour gestartet! Viel Erfolg! üöÄ');
            } catch (error) {
                console.error('Error starting tour:', error);
            }
        }

        window.loginAdmin = function() {
            try {
                const password = document.getElementById('adminPassword').value;
                if (password === 'koeln2024') {
                    tourApp.state.isAdmin = true;
                    document.getElementById('adminTab').classList.remove('hidden');
                    generateStationsList();
                    showNotification('Admin-Modus aktiviert! ‚öôÔ∏è');
                    window.showTab('admin', document.getElementById('adminTab'));
                } else {
                    showNotification('Falsches Passwort!', 'error');
                }
            } catch (error) {
                console.error('Error logging in admin:', error);
            }
        }

        window.copyShareUrl = function() {
            try {
                const shareUrl = document.getElementById('shareUrl').textContent;
                if (navigator.clipboard) {
                    navigator.clipboard.writeText(shareUrl).then(() => {
                        showNotification('URL kopiert! üìã');
                    });
                } else {
                    const textarea = document.createElement('textarea');
                    textarea.value = shareUrl;
                    document.body.appendChild(textarea);
                    textarea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textarea);
                    showNotification('URL kopiert! üìã');
                }
            } catch (error) {
                console.error('Error copying URL:', error);
            }
        }

        window.shareViaWhatsApp = function() {
            try {
                const shareUrl = document.getElementById('shareUrl').textContent;
                const message = `üèõÔ∏è K√∂lner Abendspaziergang - Tour beitreten:\n${shareUrl}`;
                const whatsappUrl = `https://wa.me/?text=${encodeURIComponent(message)}`;
                window.open(whatsappUrl, '_blank');
            } catch (error) {
                console.error('Error sharing via WhatsApp:', error);
            }
        }

        window.retryConnection = function() {
            tourApp.state.connectionRetries = 0;
            initFirebase();
        }

        // Global window functions for team management
        window.showTeamSelector = showTeamSelector;
        window.showTeamNameEditor = showTeamNameEditor;
        window.saveTeamName = saveTeamName;
        window.closeTeamNameEditor = closeTeamNameEditor;
        window.autoAssignTeams = autoAssignTeams;
        window.selectTeam = selectTeam;
        window.toggleTourChatLock = toggleTourChatLock;

        // Initialize app when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                setTimeout(initApp, 100);
            });
        } else {
            setTimeout(initApp, 100);
        }

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            stopChatCleanup();
            stopUserPositionTracking();
            
            // Cleanup location maps
            Object.values(stationLocationMaps).forEach(map => {
                if (map) {
                    map.remove();
                }
            });
            stationLocationMaps = {};
            stationLocationMarkers = {};
        });

        // Global window functions for enhanced photo analysis
        window.showFeedbackTab = showFeedbackTab;
        window.savePhotoToDevice = savePhotoToDevice;
        window.downloadAllTourPhotos = downloadAllTourPhotos;

        // Additional global functions for enhanced features
        window.showEnhancedImageModal = showEnhancedImageModal;
        window.closeEnhancedImageModal = closeEnhancedImageModal;
        window.downloadImageFromModal = downloadImageFromModal;
        window.showPhotoAnalysis = showPhotoAnalysis;
        window.closePhotoAnalysis = closePhotoAnalysis;
        window.downloadChallengePhoto = downloadChallengePhoto;
        
    </script>
</body>
</html>
