<!DOCTYPE html>

<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>K√∂lner Abendspaziergang</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

```
    body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: #333;
        line-height: 1.6;
        overflow-x: hidden;
    }

    .container {
        max-width: 100vw;
        margin: 0 auto;
        min-height: 100vh;
        background: white;
        box-shadow: 0 0 30px rgba(0,0,0,0.3);
    }

    header {
        background: linear-gradient(135deg, #dc2626 0%, #991b1b 100%);
        color: white;
        padding: 1rem;
        text-align: center;
        position: sticky;
        top: 0;
        z-index: 1000;
        box-shadow: 0 2px 10px rgba(0,0,0,0.2);
    }

    h1 {
        font-size: 1.8rem;
        margin-bottom: 0.5rem;
        text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
    }

    .subtitle {
        font-size: 0.9rem;
        opacity: 0.9;
    }

    .progress-container {
        background: rgba(255,255,255,0.2);
        height: 8px;
        border-radius: 4px;
        margin-top: 1rem;
        overflow: hidden;
    }

    .progress-bar {
        background: #fbbf24;
        height: 100%;
        width: 0%;
        border-radius: 4px;
        transition: width 0.5s ease;
    }

    .live-message {
        background: #059669;
        color: white;
        padding: 1rem;
        margin: 0.5rem;
        border-radius: 8px;
        animation: slideIn 0.5s ease;
        border-left: 4px solid #047857;
        position: relative;
    }

    .live-message.new {
        background: #dc2626;
        animation: pulse 1s infinite;
    }

    .live-message .timestamp {
        font-size: 0.8rem;
        opacity: 0.8;
        float: right;
    }

    @keyframes slideIn {
        from { transform: translateX(-100%); opacity: 0; }
        to { transform: translateX(0); opacity: 1; }
    }

    @keyframes pulse {
        0%, 100% { transform: scale(1); }
        50% { transform: scale(1.02); }
    }

    .main-content {
        padding: 0;
    }

    .tab-container {
        display: flex;
        background: #f8fafc;
        border-bottom: 2px solid #e2e8f0;
        position: sticky;
        top: 132px;
        z-index: 999;
        overflow-x: auto;
    }

    .tab {
        flex: 1;
        padding: 1rem 0.5rem;
        text-align: center;
        cursor: pointer;
        background: transparent;
        border: none;
        font-weight: 600;
        color: #64748b;
        transition: all 0.3s;
        font-size: 0.9rem;
        white-space: nowrap;
        min-width: 100px;
    }

    .tab.active {
        background: white;
        color: #dc2626;
        border-bottom: 3px solid #dc2626;
    }

    .tab-content {
        display: none;
        padding: 1.5rem;
        min-height: calc(100vh - 200px);
    }

    .tab-content.active {
        display: block;
    }

    .station-card {
        background: white;
        border-radius: 12px;
        padding: 1.5rem;
        margin-bottom: 1.5rem;
        box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        border-left: 5px solid #dc2626;
        cursor: pointer;
        transition: all 0.3s;
    }

    .station-card:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 25px rgba(0,0,0,0.15);
    }

    .station-card.completed {
        border-left-color: #10b981;
        background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%);
    }

    .station-header {
        display: flex;
        align-items: center;
        margin-bottom: 1rem;
    }

    .station-number {
        background: #dc2626;
        color: white;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        margin-right: 1rem;
        flex-shrink: 0;
    }

    .station-number.completed {
        background: #10b981;
    }

    .station-title {
        flex: 1;
        font-size: 1.3rem;
        font-weight: bold;
        color: #1f2937;
    }

    .station-subtitle {
        color: #6b7280;
        font-size: 0.9rem;
        margin-bottom: 1rem;
    }

    .station-details {
        display: none;
        margin-top: 1rem;
        padding-top: 1rem;
        border-top: 2px solid #e5e7eb;
    }

    .station-details.active {
        display: block;
    }

    .detail-section {
        margin-bottom: 1.5rem;
    }

    .detail-section h4 {
        color: #dc2626;
        margin-bottom: 0.8rem;
        font-size: 1.1rem;
        display: flex;
        align-items: center;
    }

    .detail-section h4::before {
        content: "‚ñ∂";
        margin-right: 0.5rem;
        color: #dc2626;
    }

    .photo-challenge {
        background: linear-gradient(135deg, #e0e7ff 0%, #c7d2fe 100%);
        border-radius: 12px;
        padding: 1.5rem;
        margin: 1rem 0;
        border-left: 4px solid #6366f1;
    }

    .photo-challenge h4 {
        color: #4f46e5;
        margin-bottom: 1rem;
        font-size: 1.2rem;
    }

    .photo-upload-area {
        border: 3px dashed #a5b4fc;
        border-radius: 10px;
        padding: 2rem;
        text-align: center;
        margin: 1rem 0;
        cursor: pointer;
        transition: all 0.3s;
        background: rgba(255,255,255,0.5);
    }

    .photo-upload-area:hover {
        border-color: #6366f1;
        background: rgba(255,255,255,0.8);
    }

    .photo-upload-area.has-photo {
        border-color: #10b981;
        background: #f0fdf4;
    }

    .photo-preview {
        max-width: 100%;
        max-height: 200px;
        border-radius: 8px;
        margin: 1rem 0;
    }

    .ai-rating {
        background: white;
        border-radius: 10px;
        padding: 1.5rem;
        margin: 1rem 0;
        text-align: center;
        border: 2px solid #10b981;
    }

    .rating-score {
        font-size: 3rem;
        font-weight: bold;
        color: #059669;
        margin-bottom: 0.5rem;
    }

    .rating-text {
        color: #047857;
        font-size: 1.1rem;
        margin-bottom: 1rem;
    }

    .rating-details {
        background: #f0fdf4;
        padding: 1rem;
        border-radius: 8px;
        font-size: 0.9rem;
        color: #065f46;
    }

    .image-gallery {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        gap: 1rem;
        margin: 1rem 0;
    }

    .gallery-image {
        width: 100%;
        height: 120px;
        object-fit: cover;
        border-radius: 8px;
        cursor: pointer;
        transition: transform 0.3s;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }

    .gallery-image:hover {
        transform: scale(1.05);
    }

    .gallery-item {
        text-align: center;
    }

    .gallery-item small {
        display: block;
        margin-top: 0.5rem;
        color: #6b7280;
        font-size: 0.8rem;
    }

    .btn {
        background: #dc2626;
        color: white;
        border: none;
        padding: 1rem 2rem;
        border-radius: 8px;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.3s;
        width: 100%;
        font-size: 1rem;
        margin-top: 1rem;
    }

    .btn:hover {
        background: #991b1b;
        transform: translateY(-2px);
    }

    .btn:disabled {
        background: #9ca3af;
        cursor: not-allowed;
        transform: none;
    }

    .btn-secondary {
        background: #6b7280;
    }

    .btn-secondary:hover {
        background: #4b5563;
    }

    .score-display {
        background: linear-gradient(135deg, #e0e7ff 0%, #c7d2fe 100%);
        padding: 1rem;
        border-radius: 10px;
        text-align: center;
        margin: 1rem 0;
        border: 2px solid #8b5cf6;
    }

    .score-number {
        font-size: 2rem;
        font-weight: bold;
        color: #5b21b6;
    }

    .score-label {
        color: #7c3aed;
        margin-top: 0.5rem;
    }

    .team-ranking {
        background: white;
        border-radius: 12px;
        padding: 1.5rem;
        margin: 1rem 0;
        box-shadow: 0 4px 15px rgba(0,0,0,0.1);
    }

    .team-rank-item {
        display: flex;
        align-items: center;
        padding: 1rem;
        margin: 0.5rem 0;
        border-radius: 8px;
        background: #f8fafc;
    }

    .team-rank-item.highlight {
        background: #fef3c7;
        border: 2px solid #f59e0b;
    }

    .rank-position {
        background: #6b7280;
        color: white;
        width: 30px;
        height: 30px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        margin-right: 1rem;
    }

    .rank-position.gold {
        background: #f59e0b;
    }

    .rank-position.silver {
        background: #6b7280;
    }

    .rank-position.bronze {
        background: #d97706;
    }

    #map {
        height: 400px;
        width: 100%;
        border-radius: 10px;
        margin: 1rem 0;
        box-shadow: 0 4px 15px rgba(0,0,0,0.1);
    }

    .location-info {
        background: #f0f9ff;
        border: 2px solid #0ea5e9;
        border-radius: 10px;
        padding: 1rem;
        margin: 1rem 0;
    }

    .distance-info {
        font-weight: bold;
        color: #0369a1;
        margin-bottom: 0.5rem;
    }

    .team-selector {
        background: white;
        border: 2px solid #e5e7eb;
        border-radius: 10px;
        padding: 1rem;
        margin: 1rem 0;
    }

    .team-option {
        display: flex;
        align-items: center;
        padding: 0.8rem;
        margin: 0.5rem 0;
        border-radius: 8px;
        cursor: pointer;
        transition: background 0.3s;
    }

    .team-option:hover {
        background: #f3f4f6;
    }

    .team-option.selected {
        background: #dbeafe;
        border: 2px solid #3b82f6;
    }

    .team-color {
        width: 20px;
        height: 20px;
        border-radius: 50%;
        margin-right: 1rem;
    }

    .chat-container {
        background: white;
        border-radius: 12px;
        padding: 1rem;
        margin: 1rem 0;
        box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        max-height: 400px;
        overflow-y: auto;
    }

    .chat-message {
        padding: 0.5rem;
        margin: 0.5rem 0;
        border-radius: 8px;
        background: #f8fafc;
        border-left: 3px solid #3b82f6;
    }

    .chat-message.own {
        background: #dbeafe;
        border-left-color: #1d4ed8;
        margin-left: 2rem;
    }

    .chat-input-container {
        display: flex;
        gap: 0.5rem;
        margin-top: 1rem;
    }

    .chat-input {
        flex: 1;
        padding: 0.8rem;
        border: 2px solid #e5e7eb;
        border-radius: 8px;
        font-size: 1rem;
    }

    .chat-send {
        padding: 0.8rem 1.5rem;
        background: #3b82f6;
        color: white;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        font-weight: bold;
    }

    .success-message {
        background: #10b981;
        color: white;
        padding: 1rem;
        border-radius: 8px;
        margin: 1rem 0;
        text-align: center;
        animation: slideIn 0.5s ease;
    }

    .loading-spinner {
        display: inline-block;
        width: 20px;
        height: 20px;
        border: 3px solid #f3f3f3;
        border-top: 3px solid #dc2626;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin-right: 0.5rem;
    }

    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }

    .hidden {
        display: none !important;
    }

    .file-input {
        display: none;
    }

    .notification {
        position: fixed;
        top: 20px;
        right: 20px;
        background: #059669;
        color: white;
        padding: 1rem;
        border-radius: 8px;
        box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        z-index: 10000;
        animation: slideIn 0.5s ease;
    }

    .notification.error {
        background: #dc2626;
    }

    @media (max-width: 768px) {
        .container {
            box-shadow: none;
        }
        
        h1 {
            font-size: 1.5rem;
        }
        
        .tab {
            font-size: 0.8rem;
            padding: 0.8rem 0.3rem;
        }
        
        .tab-content {
            padding: 1rem;
        }
        
        .station-card {
            padding: 1rem;
        }
        
        .image-gallery {
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
        }
    }
</style>
```

</head>
<body>
    <div class="container">
        <!-- Live Messages Area -->
        <div id="liveMessages"></div>

```
    <header>
        <h1>üèõÔ∏è K√∂lner Abendspaziergang</h1>
        <p class="subtitle">Entdecke 2000 Jahre Stadtgeschichte</p>
        <div class="progress-container">
            <div class="progress-bar" id="progressBar"></div>
        </div>
    </header>

    <div class="main-content">
        <div class="tab-container">
            <button class="tab active" onclick="showTab('overview')">üó∫Ô∏è √úbersicht</button>
            <button class="tab" onclick="showTab('stations')">üìç Stationen</button>
            <button class="tab" onclick="showTab('ranking')">üèÜ Ranking</button>
            <button class="tab" onclick="showTab('chat')">üí¨ Chat</button>
            <button class="tab" onclick="showTab('map')">üó∫Ô∏è Karte</button>
        </div>

        <!-- Overview Tab -->
        <div id="overview" class="tab-content active">
            <div class="score-display">
                <div class="score-number" id="totalScore">0</div>
                <div class="score-label">Foto-Punkte gesammelt</div>
            </div>

            <div class="team-selector" id="teamSelector">
                <h3 style="margin-bottom: 1rem; color: #374151;">üì∏ W√§hle dein Team:</h3>
                <div class="team-option" onclick="selectTeam('red', 'üî¥ Team R√∂mer')">
                    <div class="team-color" style="background: #dc2626;"></div>
                    <span>üî¥ Team R√∂mer</span>
                </div>
                <div class="team-option" onclick="selectTeam('blue', 'üîµ Team Gaffeln')">
                    <div class="team-color" style="background: #2563eb;"></div>
                    <span>üîµ Team Gaffeln</span>
                </div>
                <div class="team-option" onclick="selectTeam('green', 'üü¢ Team Hanseat')">
                    <div class="team-color" style="background: #059669;"></div>
                    <span>üü¢ Team Hanseat</span>
                </div>
                <div class="team-option" onclick="selectTeam('yellow', 'üü° Team Modern')">
                    <div class="team-color" style="background: #d97706;"></div>
                    <span>üü° Team Modern</span>
                </div>
            </div>

            <div style="background: #f8fafc; padding: 1.5rem; border-radius: 12px; margin: 1.5rem 0;">
                <h3 style="color: #1f2937; margin-bottom: 1rem;">üìã Tour-Informationen</h3>
                <p><strong>‚è∞ Dauer:</strong> ca. 3,5 Stunden</p>
                <p><strong>üìç Start:</strong> Heumarkt, 19:30 Uhr</p>
                <p><strong>üéØ Ziel:</strong> Alte Bastion</p>
                <p><strong>üë• Teilnehmer:</strong> 15-25 Personen</p>
                <p><strong>üì∏ Ziel:</strong> Sammle die besten Foto-Punkte!</p>
            </div>

            <button class="btn" onclick="startTour()">üöÄ Tour starten</button>
        </div>

        <!-- Stations Tab -->
        <div id="stations" class="tab-content">
            <div id="stationsList">
                <!-- Stations will be generated here -->
            </div>
        </div>

        <!-- Ranking Tab -->
        <div id="ranking" class="tab-content">
            <div class="team-ranking">
                <h3 style="color: #1f2937; margin-bottom: 1rem;">üèÜ Live-Ranking</h3>
                <div id="rankingList">
                    <!-- Ranking will be generated here -->
                </div>
            </div>

            <div style="background: white; border-radius: 12px; padding: 1.5rem; margin: 1.5rem 0; box-shadow: 0 4px 15px rgba(0,0,0,0.1);">
                <h3 style="color: #1f2937; margin-bottom: 1rem;">üì∏ KI-Punktesystem</h3>
                <ul style="margin-left: 1.5rem; color: #4b5563;">
                    <li><strong>Technische Qualit√§t:</strong> Sch√§rfe, Belichtung, Komposition (0-40 Punkte)</li>
                    <li><strong>Kreativit√§t:</strong> Perspective, Originalit√§t (0-30 Punkte)</li>
                    <li><strong>Stadtbezug:</strong> Erkannte Sehensw√ºrdigkeiten (0-20 Punkte)</li>
                    <li><strong>Personen/Gruppenfoto:</strong> Bonus f√ºr Teamarbeit (+10 Punkte)</li>
                </ul>
            </div>
        </div>

        <!-- Chat Tab -->
        <div id="chat" class="tab-content">
            <div class="chat-container" id="chatContainer">
                <div class="chat-message">
                    <strong>System:</strong> Willkommen im Tour-Chat! üëã
                    <span class="timestamp">jetzt</span>
                </div>
            </div>
            <div class="chat-input-container">
                <input type="text" class="chat-input" id="chatInput" placeholder="Nachricht eingeben..." maxlength="200">
                <button class="chat-send" onclick="sendMessage()">Senden</button>
            </div>
            <div style="margin-top: 1rem; text-align: center; color: #6b7280; font-size: 0.9rem;">
                üí° Chat funktioniert zwischen allen Ger√§ten mit derselben Tour-ID
            </div>
        </div>

        <!-- Map Tab -->
        <div id="map-tab" class="tab-content">
            <div class="location-info">
                <div class="distance-info" id="distanceInfo">üìç Standort wird ermittelt...</div>
                <p>üí° Tipp: Erlaube Standortzugriff f√ºr Navigation</p>
            </div>
            <div id="map"></div>
            <button class="btn" onclick="centerOnUser()">üìç Zu meinem Standort</button>
        </div>
    </div>
</div>

<!-- TensorFlow.js for AI photo rating -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/tensorflow/4.15.0/tf.min.js"></script>
<!-- Leaflet for maps -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css" />

<script>
    // App State
    let appState = {
        currentStation: 0,
        completedStations: [],
        totalScore: 0,
        selectedTeam: null,
        teamName: '',
        userLocation: null,
        map: null,
        markers: [],
        uploadedPhotos: [],
        userName: '',
        tourId: 'cologne-tour-' + new Date().toISOString().split('T')[0],
        mlModel: null,
        chatInitialized: false
    };

    // BroadcastChannel for real-time communication between tabs
    let broadcastChannel = null;

    // Station Data with real images
    const stations = [
        {
            id: 1,
            title: "Heumarkt",
            subtitle: "Wo alles anfing: 2000 Jahre Migration und Handel",
            lat: 50.9356, lng: 6.9611,
            description: "Start der Tour am historischen Heumarkt, einem der geschichtstr√§chtigsten Orte K√∂lns.",
            photoChallenge: "Mache ein Foto von dir oder deinem Team vor dem Reiterstandbild - zeigt dabei mit Handbewegungen, wie H√§ndler fr√ºher ihre Waren angepriesen haben k√∂nnten!",
            mainText: `Die Stadt ist ca. 2.000 Jahre alt. CCAA - Colonia Claudia Ara Agrippinensium - wurde 50 n. Chr. von den R√∂mern gegr√ºndet, mithilfe der germanischen Ubier. Das war √ºbrigens eine der ersten erfolgreichen Integration zweier Kulturen in Europa. 
```

Hier auf dem Heumarkt stehen wir an einem der ehemaligen Einfallstore zur Stadt. Die Markmannsgasse runter, links von der heutigen Deutzer Br√ºcke, befand sich von 1822 bis 1915 die einzige Schiffsbr√ºcke √ºber den Rhein - 42 schwimmende Boote, die √ºber 30 Mal t√§glich f√ºr Schiffe ge√∂ffnet wurden.

Das ‚ÄúStapelrecht‚Äù von 1259 bis 1804 war ein 545 Jahre g√ºltiges Handelsprivileg. Alle Waren auf Schiffen, die an K√∂ln vorbeifahren wollten, mussten drei Tage hier angeboten werden.`, images: [ { url: "https://images.unsplash.com/photo-1568667256549-094345857637?w=400", title: "Heumarkt heute", description: "Moderne Aufnahme des historischen Platzes" }, { url: "https://images.unsplash.com/photo-1590736969955-71cc94901144?w=400", title: "K√∂lner Architektur", description: "Typische Rheinische Bauweise" }, { url: "https://images.unsplash.com/photo-1551622656-fa4fa96b5faf?w=400", title: "Rheinufer", description: "Blick auf den historischen Handelsweg" } ] }, { id: 2, title: "K√∂lner Dom", subtitle: "Das ewige Bauprojekt und die Verkehrsrevolution", lat: 50.9413, lng: 6.9583, description: "K√∂lns Wahrzeichen und die l√§ngste Baustelle der Welt.", photoChallenge: "Bildet mit eurem Team eine 'menschliche Kathedrale' vor dem Dom - streckt die Arme hoch und formt gotische B√∂gen nach!", mainText: `Der Dom wird seit fast 800 Jahren gebaut - etwas l√§nger als der BER. Die Grundsteinlegung 1248 war K√∂lns Versuch, Paris und andere Gro√üst√§dte zu beeindrucken. K√∂ln war immer reich, aber auch provinziell.

1248-1330 wurden Grundmauern und der Chor fertiggestellt. Dann ging das Geld aus. Fast 300 Jahre stand nur ein riesiger Kran auf dem unvollendeten Turm - eines der ersten gro√üen ‚Äúpaused projects‚Äù der Geschichte.

Erst die Romantik des 19. Jahrhunderts und preu√üisches Geld vollendeten den Dom 1880. Der Hauptbahnhof entstand 1894 als einer der modernsten Europas.`, images: [ { url: "https://images.unsplash.com/photo-1571115764595-644a1f56a55c?w=400", title: "K√∂lner Dom", description: "Die ber√ºhmten Zwillingst√ºrme" }, { url: "https://images.unsplash.com/photo-1506905925346-21bda4d32df4?w=400", title: "Dom Innenraum", description: "Gotische Architektur" }, { url: "https://images.unsplash.com/photo-1513635269975-59663e0ac1ad?w=400", title: "Dom bei Nacht", description: "Beleuchtetes Wahrzeichen" } ] }, { id: 3, title: "Altstadt", subtitle: "Macht, Rebellion und eine gro√üe Liebesgeschichte", lat: 50.9369, lng: 6.9572, description: "Das historische Rathaus und die ber√ºhmte Jan-und-Griet-Geschichte.", photoChallenge: "Fotografiert euch am historischen Rathaus und stellt eine romantische Szene nach: Eine Person kniet, eine steht stolz daneben.", mainText: `Der Rathaus-Turm zeigt wichtige Pers√∂nlichkeiten der K√∂lner Geschichte. 1945 zerst√∂rt und wieder aufgebaut. Da auch die Figuren zerst√∂rt waren, w√§hlte eine Kommission neue aus - von √ºber 100 Kandidaten. Alle m√§nnlich.

Oben am Turm seht ihr den ‚ÄúPlatz-Jabbeck‚Äù - er streckt Autorit√§ten die Zunge raus. So viel Respekt hatten die K√∂lner f√ºr die Obrigkeit.

Die Altstadt erz√§hlt eine der gr√∂√üten deutschen Liebesgeschichten: Jan ist ein armer Knecht, Griet arbeitet auch dort. Er mag sie, sie ihn nicht. Der Krieg beginnt, Jan zieht aus, kommt als ber√ºhmter General zur√ºck.`, images: [ { url: "https://images.unsplash.com/photo-1544892504-5ad7a122b56f?w=400", title: "K√∂lner Altstadt", description: "Historische Gassen" }, { url: "https://images.unsplash.com/photo-1517840901100-8179e982acb7?w=400", title: "Rheinpromenade", description: "Spazierweg mit Domblick" }, { url: "https://images.unsplash.com/photo-1567696911980-2eed69651dd7?w=400", title: "Historisches Rathaus", description: "Gotisches Bauwerk" } ] }, { id: 4, title: "Gro√ü St. Martin", subtitle: "Romanische Kirche und Klostergeschichte", lat: 50.9347, lng: 6.9597, description: "Eine der zw√∂lf gro√üen romanischen Kirchen K√∂lns.", photoChallenge: "Macht ein Foto der imposanten Kircht√ºrme und zeigt dabei mittelalterliche Gebetshaltungen!", mainText: `Gro√ü St. Martin ist eine der beeindruckendsten romanischen Kirchen K√∂lns. Der markante Vierungsturm pr√§gt seit dem 12. Jahrhundert die Silhouette der Altstadt.

Die Kirche wurde auf r√∂mischen Fundamenten errichtet - arch√§ologische Ausgrabungen zeigen die Kontinuit√§t der Besiedlung √ºber 2000 Jahre. Im Mittelalter war hier eines der m√§chtigsten Benediktinerkl√∂ster der Region.

Der Turm diente auch als Orientierungspunkt f√ºr Rheinschiffe und H√§ndler - ein fr√ºher ‚ÄúLeuchtturm‚Äù des Handels.`, images: [ { url: "https://images.unsplash.com/photo-1518709268805-4e9042af2e96?w=400", title: "Gro√ü St. Martin", description: "Romanischer Kirchenbau" }, { url: "https://images.unsplash.com/photo-1573052905904-34ad8c27f0d4?w=400", title: "Altstadt Panorama", description: "Kircht√ºrme der Altstadt" }, { url: "https://images.unsplash.com/photo-1578662996442-48f60103fc96?w=400", title: "Rheinufer", description: "Blick auf die Kirchen" } ] }, { id: 5, title: "Fischmarkt", subtitle: "Handel, Handwerk und B√ºrgerstolz", lat: 50.9378, lng: 6.9589, description: "Mittelpunkt des mittelalterlichen Handels.", photoChallenge: "Zeigt mit euren H√§nden, wie mittelalterliche H√§ndler ihre Waren pr√§sentiert haben - seid kreativ mit Gesten!", mainText: `Der Fischmarkt war im Mittelalter das kommerzielle Herz K√∂lns. Hier wurde nicht nur Fisch verkauft, sondern alle wichtigen Handelsg√ºter der Region.

Die K√∂lner B√ºrger entwickelten hier ihre ber√ºhmte Unabh√§ngigkeit. 1074 erhielt K√∂ln bereits wichtige Stadtrechte - 500 Jahre bevor andere deutsche St√§dte folgten.

Die Zunftordnungen vom Fischmarkt dienten als Vorbild f√ºr ganz Europa. Handwerksmeister aus K√∂ln gr√ºndeten in vielen anderen St√§dten √§hnliche Organisationen.`,
images: [
{
url: ‚Äúhttps://images.unsplash.com/photo-1578916171728-46686eac8d58?w=400‚Äù,
title: ‚ÄúAlter Markt K√∂ln‚Äù,
description: ‚ÄúHistorischer Marktplatz‚Äù
},
{
url: ‚Äúhttps://images.unsplash.com/photo-1574790398664-0cb3c99c3711?w=400‚Äù,
title: ‚ÄúK√∂lner H√§user‚Äù,
description: ‚ÄúTypische Architektur‚Äù
},
{
url: ‚Äúhttps://images.unsplash.com/photo-1587474260584-136574528ed5?w=400‚Äù,
title: ‚ÄúRheinischer Markt‚Äù,
description: ‚ÄúHandelstradition‚Äù
}
]
}
];

```
    // Real-time Messaging System
    class TourMessaging {
        constructor(tourId) {
            this.tourId = tourId;
            this.channel = null;
            this.init();
        }

        init() {
            // BroadcastChannel for local communication
            if ('BroadcastChannel' in window) {
                this.channel = new BroadcastChannel(this.tourId);
                this.channel.addEventListener('message', (event) => {
                    this.handleMessage(event.data);
                });
            }

            // Fallback: LocalStorage + polling
            this.startPolling();
        }

        sendMessage(userName, message) {
            const messageData = {
                id: Date.now() + Math.random(),
                userName: userName,
                message: message,
                timestamp: Date.now(),
                tourId: this.tourId
            };

            // Send via BroadcastChannel
            if (this.channel) {
                this.channel.postMessage(messageData);
            }

            // Store in localStorage
            this.storeMessage(messageData);
        }

        storeMessage(messageData) {
            const messages = this.getStoredMessages();
            messages.push(messageData);
            
            // Keep only last 50 messages
            if (messages.length > 50) {
                messages.splice(0, messages.length - 50);
            }
            
            localStorage.setItem(`tour_messages_${this.tourId}`, JSON.stringify(messages));
        }

        getStoredMessages() {
            const stored = localStorage.getItem(`tour_messages_${this.tourId}`);
            return stored ? JSON.parse(stored) : [];
        }

        handleMessage(messageData) {
            if (messageData.tourId === this.tourId) {
                this.displayMessage(messageData);
            }
        }

        displayMessage(messageData) {
            const chatContainer = document.getElementById('chatContainer');
            const messageDiv = document.createElement('div');
            
            const isOwn = messageData.userName === appState.userName;
            messageDiv.className = `chat-message ${isOwn ? 'own' : ''}`;
            
            const timeStr = new Date(messageData.timestamp).toLocaleTimeString('de-DE', {
                hour: '2-digit',
                minute: '2-digit'
            });

            messageDiv.innerHTML = `
                <strong>${messageData.userName}:</strong> ${messageData.message}
                <span class="timestamp">${timeStr}</span>
            `;
            
            chatContainer.appendChild(messageDiv);
            chatContainer.scrollTop = chatContainer.scrollHeight;

            // Show notification if not on chat tab
            if (!document.getElementById('chat').classList.contains('active') && !isOwn) {
                this.showNotification(`${messageData.userName}: ${messageData.message}`);
            }
        }

        startPolling() {
            // Check for new messages every 2 seconds
            setInterval(() => {
                const messages = this.getStoredMessages();
                const lastCheck = parseInt(localStorage.getItem(`last_check_${this.tourId}`) || '0');
                
                const newMessages = messages.filter(msg => msg.timestamp > lastCheck);
                if (newMessages.length > 0) {
                    newMessages.forEach(msg => this.displayMessage(msg));
                    localStorage.setItem(`last_check_${this.tourId}`, Date.now().toString());
                }
            }, 2000);
        }

        loadHistory() {
            const messages = this.getStoredMessages();
            messages.forEach(msg => this.displayMessage(msg));
        }

        showNotification(message) {
            const notification = document.createElement('div');
            notification.className = 'notification';
            notification.innerHTML = `üí¨ ${message}`;
            document.body.appendChild(notification);

            setTimeout(() => {
                notification.remove();
            }, 3000);
        }
    }

    // AI Photo Rating System
    class AIPhotoRater {
        constructor() {
            this.model = null;
            this.initModel();
        }

        async initModel() {
            try {
                // Load a pre-trained MobileNet model for basic image classification
                this.model = await tf.loadLayersModel('https://tfhub.dev/google/imagenet/mobilenet_v2_100_224/classification/4');
                console.log('AI model loaded successfully');
            } catch (error) {
                console.log('Could not load AI model, using rule-based rating');
            }
        }

        async ratePhoto(imageElement) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = imageElement.naturalWidth || imageElement.width;
            canvas.height = imageElement.naturalHeight || imageElement.height;
            ctx.drawImage(imageElement, 0, 0, canvas.width, canvas.height);

            const scores = {
                technical: await this.analyzeTechnicalQuality(canvas, ctx),
                composition: await this.analyzeComposition(canvas, ctx),
                creativity: this.analyzeCreativity(canvas, ctx),
                people: await this.detectPeople(canvas, ctx)
            };

            const finalScore = this.calculateFinalScore(scores);
            const feedback = this.generateFeedback(scores);

            return {
                score: finalScore,
                breakdown: scores,
                feedback: feedback
            };
        }

        async analyzeTechnicalQuality(canvas, ctx) {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            
            // Analyze sharpness using Laplacian variance
            const sharpness = this.calculateSharpness(imageData);
            
            // Analyze exposure
            const exposure = this.analyzeExposure(imageData);
            
            // Analyze color distribution
            const colorBalance = this.analyzeColorBalance(imageData);

            return {
                sharpness: Math.min(100, sharpness * 10),
                exposure: exposure,
                colorBalance: colorBalance,
                overall: (sharpness * 10 + exposure + colorBalance) / 3
            };
        }

        calculateSharpness(imageData) {
            const data = imageData.data;
            const width = imageData.width;
            const height = imageData.height;
            
            let variance = 0;
            let count = 0;

            // Apply Laplacian kernel for edge detection
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const idx = (y * width + x) * 4;
                    
                    const laplacian = 
                        -data[((y-1)*width + x-1)*4] - data[((y-1)*width + x)*4] - data[((y-1)*width + x+1)*4] +
                        -data[(y*width + x-1)*4] + 8*data[idx] - data[(y*width + x+1)*4] +
                        -data[((y+1)*width + x-1)*4] - data[((y+1)*width + x)*4] - data[((y+1)*width + x+1)*4];
                    
                    variance += laplacian * laplacian;
                    count++;
                }
            }
            
            return Math.sqrt(variance / count);
        }

        analyzeExposure(imageData) {
            const data = imageData.data;
            let brightness = 0;
            let pixels = 0;

            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                brightness += (r + g + b) / 3;
                pixels++;
            }

            const avgBrightness = brightness / pixels;
            
            // Optimal brightness range is 100-180
            if (avgBrightness >= 100 && avgBrightness <= 180) {
                return 90 + Math.random() * 10;
            } else if (avgBrightness < 100) {
                return Math.max(20, 90 - (100 - avgBrightness) * 0.5);
            } else {
                return Math.max(20, 90 - (avgBrightness - 180) * 0.3);
            }
        }

        analyzeColorBalance(imageData) {
            const data = imageData.data;
            let r = 0, g = 0, b = 0;
            let pixels = 0;

            for (let i = 0; i < data.length; i += 4) {
                r += data[i];
                g += data[i + 1];
                b += data[i + 2];
                pixels++;
            }

            r /= pixels;
            g /= pixels;
            b /= pixels;

            // Calculate color balance score
            const avgColor = (r + g + b) / 3;
            const rDiff = Math.abs(r - avgColor);
            const gDiff = Math.abs(g - avgColor);
            const bDiff = Math.abs(b - avgColor);
            
            const colorVariance = (rDiff + gDiff + bDiff) / 3;
            return Math.max(50, 100 - colorVariance / 2);
        }

        analyzeComposition(canvas, ctx) {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            
            // Rule of thirds analysis
            const ruleOfThirds = this.analyzeRuleOfThirds(imageData);
            
            // Symmetry analysis
            const symmetry = this.analyzeSymmetry(imageData);
            
            return {
                ruleOfThirds: ruleOfThirds,
                symmetry: symmetry,
                overall: (ruleOfThirds + symmetry) / 2
            };
        }

        analyzeRuleOfThirds(imageData) {
            const width = imageData.width;
            const height = imageData.height;
            const data = imageData.data;
            
            const thirdX = width / 3;
            const thirdY = height / 3;
            
            const intersections = [
                [thirdX, thirdY], [2 * thirdX, thirdY],
                [thirdX, 2 * thirdY], [2 * thirdX, 2 * thirdY]
            ];
            
            let score = 0;
            intersections.forEach(([x, y]) => {
                const pixelIndex = (Math.floor(y) * width + Math.floor(x)) * 4;
                const contrast = this.calculateLocalContrast(data, pixelIndex, width, height);
                score += contrast;
            });
            
            return Math.min(100, score / intersections.length * 2);
        }

        calculateLocalContrast(data, centerIndex, width, height) {
            const radius = 5;
            let centerValue = (data[centerIndex] + data[centerIndex + 1] + data[centerIndex + 2]) / 3;
            let surroundingSum = 0;
            let count = 0;
            
            for (let dy = -radius; dy <= radius; dy++) {
                for (let dx = -radius; dx <= radius; dx++) {
                    const idx = centerIndex + (dy * width + dx) * 4;
                    if (idx >= 0 && idx < data.length - 3) {
                        surroundingSum += (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
                        count++;
                    }
                }
            }
            
            const avgSurrounding = surroundingSum / count;
            return Math.abs(centerValue - avgSurrounding);
        }

        analyzeSymmetry(imageData) {
            // Simplified symmetry check
            const width = imageData.width;
            const height = imageData.height;
            const data = imageData.data;
            
            let symmetryScore = 0;
            const samples = Math.min(100, width / 10);
            
            for (let i = 0; i < samples; i++) {
                const x = Math.floor((i / samples) * width);
                const leftIdx = (Math.floor(height / 2) * width + x) * 4;
                const rightIdx = (Math.floor(height / 2) * width + (width - 1 - x)) * 4;
                
                if (leftIdx < data.length - 3 && rightIdx < data.length - 3) {
                    const leftColor = (data[leftIdx] + data[leftIdx + 1] + data[leftIdx + 2]) / 3;
                    const rightColor = (data[rightIdx] + data[rightIdx + 1] + data[rightIdx + 2]) / 3;
                    symmetryScore += Math.max(0, 100 - Math.abs(leftColor - rightColor));
                }
            }
            
            return symmetryScore / samples;
        }

        analyzeCreativity(canvas, ctx) {
            // Simplified creativity analysis based on color variance and edge density
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            // Color variance
            let colorVariance = 0;
            const colorHistogram = new Array(256).fill(0);
            
            for (let i = 0; i < data.length; i += 4) {
                const gray = Math.floor((data[i] + data[i + 1] + data[i + 2]) / 3);
                colorHistogram[gray]++;
            }
            
            // Calculate entropy as creativity measure
            const totalPixels = data.length / 4;
            let entropy = 0;
            for (let i = 0; i < 256; i++) {
                if (colorHistogram[i] > 0) {
                    const p = colorHistogram[i] / totalPixels;
                    entropy -= p * Math.log2(p);
                }
            }
            
            return Math.min(100, entropy * 12);
        }

        async detectPeople(canvas, ctx) {
            // Simplified people detection based on skin tone detection
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            let skinPixels = 0;
            let totalPixels = data.length / 4;
            
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                
                // Simple skin tone detection
                if (this.isSkinTone(r, g, b)) {
                    skinPixels++;
                }
            }
            
            const skinRatio = skinPixels / totalPixels;
            return skinRatio > 0.05 ? 80 + Math.random() * 20 : 20 + Math.random() * 30;
        }

        isSkinTone(r, g, b) {
            // Simplified skin tone detection
            return (r > 95 && g > 40 && b > 20 && 
                    r > g && r > b && 
                    r - g > 15 && 
                    Math.abs(r - g) > 15);
        }

        calculateFinalScore(scores) {
            const weights = {
                technical: 0.4,
                composition: 0.3,
                creativity: 0.2,
                people: 0.1
            };

            let finalScore = 0;
            finalScore += (scores.technical.overall || 50) * weights.technical;
            finalScore += (scores.composition.overall || 50) * weights.composition;
            finalScore += (scores.creativity || 50) * weights.creativity;
            finalScore += (scores.people || 50) * weights.people;

            return Math.round(Math.max(10, Math.min(100, finalScore)));
        }

        generateFeedback(scores) {
            const feedback = [];
            
            if (scores.technical.sharpness > 70) {
                feedback.push("üì∏ Sehr scharfes Bild!");
            } else if (scores.technical.sharpness < 40) {
                feedback.push("‚ö†Ô∏è Bild k√∂nnte sch√§rfer sein");
            }
            
            if (scores.composition.ruleOfThirds > 70) {
                feedback.push("üé® Gute Komposition!");
            } else {
                feedback.push("üí° Tipp: Platziere wichtige Elemente an den Drittel-Linien");
            }
            
            if (scores.creativity > 70) {
                feedback.push("‚ú® Sehr kreativ!");
            }
            
            if (scores.people > 60) {
                feedback.push("üë• Tolle Gruppenaufnahme!");
            }
            
            return feedback.length > 0 ? feedback : ["Sch√∂ne Aufnahme!"];
        }
    }

    // Team Synchronization System
    class TeamSync {
        constructor() {
            this.channel = null;
            this.init();
        }

        init() {
            if ('BroadcastChannel' in window) {
                this.channel = new BroadcastChannel('team-sync');
                this.channel.addEventListener('message', (event) => {
                    this.handleSyncMessage(event.data);
                });
            }
            
            // Periodic sync
            setInterval(() => {
                this.syncTeamScores();
            }, 5000);
        }

        updateTeamScore(teamId, newScore, stationId) {
            const update = {
                type: 'score_update',
                teamId: teamId,
                score: newScore,
                stationId: stationId,
                timestamp: Date.now(),
                userId: appState.userName
            };

            // Broadcast to other tabs
            if (this.channel) {
                this.channel.postMessage(update);
            }

            // Store locally
            this.storeTeamScore(teamId, newScore, stationId);
        }

        storeTeamScore(teamId, score, stationId) {
            const key = `team_score_${teamId}`;
            const currentData = JSON.parse(localStorage.getItem(key) || '{"score": 0, "stations": []}');
            
            currentData.score = Math.max(currentData.score, score);
            if (!currentData.stations.includes(stationId)) {
                currentData.stations.push(stationId);
            }
            currentData.lastUpdate = Date.now();
            
            localStorage.setItem(key, JSON.stringify(currentData));
        }

        getTeamScore(teamId) {
            const key = `team_score_${teamId}`;
            const data = JSON.parse(localStorage.getItem(key) || '{"score": 0, "stations": []}');
            return data.score;
        }

        getAllTeamScores() {
            const teams = ['red', 'blue', 'green', 'yellow'];
            return teams.map(teamId => ({
                id: teamId,
                name: this.getTeamName(teamId),
                score: this.getTeamScore(teamId)
            }));
        }

        getTeamName(teamId) {
            const names = {
                'red': 'üî¥ Team R√∂mer',
                'blue': 'üîµ Team Gaffeln', 
                'green': 'üü¢ Team Hanseat',
                'yellow': 'üü° Team Modern'
            };
            return names[teamId] || teamId;
        }

        handleSyncMessage(data) {
            if (data.type === 'score_update') {
                this.storeTeamScore(data.teamId, data.score, data.stationId);
                updateRanking();
            }
        }

        syncTeamScores() {
            // Get all team scores and broadcast current state
            const allScores = this.getAllTeamScores();
            if (this.channel) {
                this.channel.postMessage({
                    type: 'full_sync',
                    scores: allScores,
                    timestamp: Date.now()
                });
            }
        }
    }

    // Initialize systems
    let messaging = null;
    let aiRater = null;
    let teamSync = null;

    // Initialize App
    function initApp() {
        // Generate user name if not exists
        if (!appState.userName) {
            appState.userName = 'Tourist_' + Math.random().toString(36).substr(2, 5);
        }

        // Initialize systems
        messaging = new TourMessaging(appState.tourId);
        aiRater = new AIPhotoRater();
        teamSync = new TeamSync();

        generateStationsList();
        initMap();
        updateUI();
        
        // Check if geolocation is available
        if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(
                position => {
                    appState.userLocation = {
                        lat: position.coords.latitude,
                        lng: position.coords.longitude
                    };
                    updateLocationInfo();
                    if (appState.map) {
                        addUserLocationToMap();
                    }
                },
                error => {
                    console.log('Geolocation not available:', error);
                    document.getElementById('distanceInfo').textContent = 'üìç Standort nicht verf√ºgbar';
                }
            );
        }

        // Load saved state
        loadState();

        // Setup chat input handler
        document.getElementById('chatInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                sendMessage();
            }
        });
    }

    function showTab(tabName) {
        // Update tab buttons
        document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
        event.target.classList.add('active');

        // Update tab content
        document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
        document.getElementById(tabName === 'map' ? 'map-tab' : tabName).classList.add('active');

        // Initialize map if switching to map tab
        if (tabName === 'map' && !appState.map) {
            setTimeout(initMap, 100);
        }

        // Update ranking if switching to ranking tab
        if (tabName === 'ranking') {
            updateRanking();
        }

        // Load chat history when switching to chat
        if (tabName === 'chat' && !appState.chatInitialized) {
            messaging.loadHistory();
            appState.chatInitialized = true;
        }
    }

    function generateStationsList() {
        const container = document.getElementById('stationsList');
        
        stations.forEach(station => {
            const isCompleted = appState.completedStations.includes(station.id);
            
            const stationCard = document.createElement('div');
            stationCard.className = `station-card ${isCompleted ? 'completed' : ''}`;
            stationCard.onclick = () => toggleStationDetails(station.id);
            
            const imagesHtml = station.images.map(img => `
                <div class="gallery-item">
                    <img src="${img.url}" alt="${img.title}" class="gallery-image" onclick="showImageModal('${img.url}', '${img.title}', '${img.description}')">
                    <small>${img.title}</small>
                </div>
            `).join('');
            
            stationCard.innerHTML = `
                <div class="station-header">
                    <div class="station-number ${isCompleted ? 'completed' : ''}">${station.id}</div>
                    <div style="flex: 1;">
                        <div class="station-title">${station.title}</div>
                        <div class="station-subtitle">${station.subtitle}</div>
                    </div>
                </div>
                <div class="station-details" id="station-${station.id}">
                    <div class="detail-section">
                        <h4>üìñ Geschichte</h4>
                        <p>${station.mainText}</p>
                    </div>
                    
                    <div class="detail-section">
                        <h4>üñºÔ∏è Bildergalerie</h4>
                        <div class="image-gallery">
                            ${imagesHtml}
                        </div>
                    </div>

                    <div class="photo-challenge">
                        <h4>üì∏ KI-Foto-Challenge</h4>
                        <p>${station.photoChallenge}</p>
                        
                        <div class="photo-upload-area" onclick="selectPhoto(${station.id})" id="upload-area-${station.id}">
                            <div id="upload-content-${station.id}">
                                üì∑ Hier klicken zum Foto machen/ausw√§hlen<br>
                                <small>KI bewertet automatisch Qualit√§t, Komposition & Kreativit√§t</small>
                            </div>
                        </div>
                        
                        <input type="file" class="file-input" id="photo-input-${station.id}" accept="image/*" capture="environment" onchange="handlePhotoUpload(${station.id}, event)">
                        
                        <div class="ai-rating hidden" id="rating-${station.id}">
                            <div class="rating-score" id="score-${station.id}">0</div>
                            <div class="rating-text" id="rating-text-${station.id}">KI analysiert dein Foto...</div>
                            <div class="rating-details" id="rating-details-${station.id}"></div>
                        </div>
                    </div>

                    <button class="btn" onclick="completeStation(${station.id})" id="complete-btn-${station.id}" 
                            ${isCompleted ? 'disabled' : ''}>
                        ${isCompleted ? '‚úÖ Station abgeschlossen' : 'üèÅ Station abschlie√üen'}
                    </button>
                </div>
            `;
            
            container.appendChild(stationCard);
        });
    }

    function showImageModal(url, title, description) {
        const modal = document.createElement('div');
        modal.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            flex-direction: column;
            padding: 20px;
            box-sizing: border-box;
        `;
        
        modal.innerHTML = `
            <img src="${url}" style="max-width: 90%; max-height: 70%; object-fit: contain; border-radius: 8px;">
            <div style="color: white; text-align: center; margin-top: 20px; max-width: 600px;">
                <h3>${title}</h3>
                <p>${description}</p>
                <button style="margin-top: 20px; padding: 10px 20px; background: #dc2626; color: white; border: none; border-radius: 5px; cursor: pointer;" onclick="this.parentElement.parentElement.remove()">Schlie√üen</button>
            </div>
        `;
        
        modal.onclick = (e) => {
            if (e.target === modal) modal.remove();
        };
        
        document.body.appendChild(modal);
    }

    function toggleStationDetails(stationId) {
        const details = document.getElementById(`station-${stationId}`);
        details.classList.toggle('active');
    }

    function selectTeam(teamId, teamName) {
        appState.selectedTeam = teamId;
        appState.teamName = teamName;
        
        // Update UI
        document.querySelectorAll('.team-option').forEach(option => {
            option.classList.remove('selected');
        });
        event.target.closest('.team-option').classList.add('selected');
        
        // Hide team selector after selection
        document.getElementById('teamSelector').style.display = 'none';
        
        showSuccessMessage('Team ausgew√§hlt! üéâ');
        saveState();
    }

    function startTour() {
        if (!appState.selectedTeam) {
            alert('Bitte w√§hle zuerst ein Team aus!');
            return;
        }
        
        showTab('stations');
        document.querySelector('[onclick="showTab(\'stations\')"]').click();
        showSuccessMessage('Tour gestartet! Viel Erfolg! üöÄ');
    }

    function selectPhoto(stationId) {
        document.getElementById(`photo-input-${stationId}`).click();
    }

    async function handlePhotoUpload(stationId, event) {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = async function(e) {
            const imageUrl = e.target.result;
            
            // Update upload area
            const uploadArea = document.getElementById(`upload-area-${stationId}`);
            uploadArea.classList.add('has-photo');
            uploadArea.innerHTML = `
                <img src="${imageUrl}" class="photo-preview" alt="Uploaded photo">
                <p>üì∑ Foto erfolgreich hochgeladen!</p>
                <small>KI analysiert...</small>
            `;

            // Store photo
            const existingPhotoIndex = appState.uploadedPhotos.findIndex(p => p.stationId === stationId);
            const photoData = {
                stationId: stationId,
                imageUrl: imageUrl,
                timestamp: Date.now(),
                teamId: appState.selectedTeam
            };

            if (existingPhotoIndex >= 0) {
                appState.uploadedPhotos[existingPhotoIndex] = photoData;
            } else {
                appState.uploadedPhotos.push(photoData);
            }

            // AI Analysis
            setTimeout(async () => {
                await ratePhoto(stationId, imageUrl);
            }, 500);

            saveState();
        };
        
        reader.readAsDataURL(file);
    }

    async function ratePhoto(stationId, imageUrl) {
        const ratingDiv = document.getElementById(`rating-${stationId}`);
        ratingDiv.classList.remove('hidden');
        
        try {
            // Create image element for AI analysis
            const img = new Image();
            img.onload = async () => {
                const analysis = await aiRater.ratePhoto(img);
                
                // Animate score counting up
                let currentScore = 0;
                const scoreElement = document.getElementById(`score-${stationId}`);
                const interval = setInterval(() => {
                    currentScore += 2;
                    scoreElement.textContent = currentScore;
                    if (currentScore >= analysis.score) {
                        clearInterval(interval);
                        scoreElement.textContent = analysis.score;
                    }
                }, 50);
                
                document.getElementById(`rating-text-${stationId}`).innerHTML = `
                    <strong>KI-Bewertung abgeschlossen!</strong><br>
                    Qualit√§t: ${Math.round(analysis.breakdown.technical.overall)}% | 
                    Komposition: ${Math.round(analysis.breakdown.composition.overall)}% | 
                    Kreativit√§t: ${Math.round(analysis.breakdown.creativity)}%
                `;
                
                document.getElementById(`rating-details-${stationId}`).innerHTML = 
                    analysis.feedback.join('<br>');
                
                // Add score to total and sync with team
                addScore(analysis.score);
                if (appState.selectedTeam) {
                    teamSync.updateTeamScore(appState.selectedTeam, appState.totalScore, stationId);
                }
                
                // Store rating
                const photoData = appState.uploadedPhotos.find(p => p.stationId === stationId);
                if (photoData) {
                    photoData.score = analysis.score;
                    photoData.analysis = analysis;
                }
                
                showSuccessMessage(`KI-Bewertung: ${analysis.score} Punkte! ü§ñ`);
            };
            img.src = imageUrl;
            
        } catch (error) {
            console.error('Error rating photo:', error);
            // Fallback to simpler rating
            const fallbackScore = 60 + Math.random() * 30;
            document.getElementById(`score-${stationId}`).textContent = Math.round(fallbackScore);
            document.getElementById(`rating-text-${stationId}`).textContent = 'Foto bewertet - Gute Aufnahme!';
            addScore(fallbackScore);
        }
    }

    function completeStation(stationId) {
        if (!appState.completedStations.includes(stationId)) {
            appState.completedStations.push(stationId);
            updateProgress();
            showSuccessMessage('Station abgeschlossen! üèÅ');
            
            // Update station card
            const stationCard = document.querySelector(`#complete-btn-${stationId}`).closest('.station-card');
            stationCard.classList.add('completed');
            stationCard.querySelector('.station-number').classList.add('completed');
            
            // Disable button
            event.target.disabled = true;
            event.target.textContent = '‚úÖ Station abgeschlossen';
            event.target.style.background = '#6b7280';

            // Check if tour is complete
            if (appState.completedStations.length === stations.length) {
                showSuccessMessage('üéâ Herzlichen Gl√ºckwunsch! Tour abgeschlossen!');
                setTimeout(() => {
                    showTab('ranking');
                    document.querySelector('[onclick="showTab(\'ranking\')"]').click();
                }, 2000);
            }

            saveState();
        }
    }

    function addScore(points) {
        appState.totalScore += Math.round(points);
        updateUI();
        saveState();
    }

    function updateUI() {
        document.getElementById('totalScore').textContent = appState.totalScore;
        updateProgress();
    }

    function updateProgress() {
        const progress = (appState.completedStations.length / stations.length) * 100;
        document.getElementById('progressBar').style.width = progress + '%';
    }

    function updateRanking() {
        const rankingList = document.getElementById('rankingList');
        
        // Get real team scores from TeamSync
        const teams = teamSync.getAllTeamScores()
            .filter(team => team.score > 0 || team.id === appState.selectedTeam)
            .sort((a, b) => b.score - a.score);

        // Add some demo teams if no real data
        if (teams.length === 0) {
            teams.push(
                { id: 'red', name: 'üî¥ Team R√∂mer', score: Math.floor(Math.random() * 300) + 200 },
                { id: 'blue', name: 'üîµ Team Gaffeln', score: Math.floor(Math.random() * 300) + 200 },
                { id: 'green', name: 'üü¢ Team Hanseat', score: Math.floor(Math.random() * 300) + 200 },
                { id: 'yellow', name: 'üü° Team Modern', score: Math.floor(Math.random() * 300) + 200 }
            );
            teams.sort((a, b) => b.score - a.score);
        }

        rankingList.innerHTML = '';
        
        teams.forEach((team, index) => {
            const rankItem = document.createElement('div');
            const isUserTeam = team.id === appState.selectedTeam;
            rankItem.className = `team-rank-item ${isUserTeam ? 'highlight' : ''}`;
            
            let rankClass = '';
            if (index === 0) rankClass = 'gold';
            else if (index === 1) rankClass = 'silver';
            else if (index === 2) rankClass = 'bronze';
            
            rankItem.innerHTML = `
                <div class="rank-position ${rankClass}">${index + 1}</div>
                <div style="flex: 1;">
                    <strong>${team.name}</strong>
                    <div style="color: #6b7280; font-size: 0.9rem;">
                        ${team.score} Punkte
                    </div>
                </div>
                ${isUserTeam ? '<div style="color: #f59e0b;">üë§</div>' : ''}
            `;
            
            rankingList.appendChild(rankItem);
        });
    }

    function sendMessage() {
        const input = document.getElementById('chatInput');
        const message = input.value.trim();
        
        if (message) {
            messaging.sendMessage(appState.userName, message);
            input.value = '';
        }
    }

    function showSuccessMessage(message) {
        const messageDiv = document.createElement('div');
        messageDiv.className = 'success-message';
        messageDiv.textContent = message;
        
        document.body.appendChild(messageDiv);
        
        setTimeout(() => {
            messageDiv.remove();
        }, 3000);
    }

    // Map Functions
    function initMap() {
        if (!document.getElementById('map') || appState.map) return;
        
        appState.map = L.map('map').setView([50.9375, 6.9597], 15);
        
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '¬© OpenStreetMap contributors'
        }).addTo(appState.map);
        
        stations.forEach((station, index) => {
            const isCompleted = appState.completedStations.includes(station.id);
            const marker = L.marker([station.lat, station.lng])
                .bindPopup(`
                    <div style="text-align: center; max-width: 200px;">
                        <h4>${station.title}</h4>
                        <p>${station.subtitle}</p>
                        <p><strong>Station ${station.id}/${stations.length}</strong></p>
                        ${isCompleted ? '<p style="color: green;">‚úÖ Abgeschlossen</p>' : '<p style="color: orange;">‚è≥ Ausstehend</p>'}
                    </div>
                `)
                .addTo(appState.map);
            
            appState.markers.push(marker);
        });
        
        if (appState.userLocation) {
            addUserLocationToMap();
        }
        
        const routeCoordinates = stations.map(station => [station.lat, station.lng]);
        L.polyline(routeCoordinates, {
            color: '#dc2626',
            weight: 3,
            opacity: 0.7
        }).addTo(appState.map);
    }

    function addUserLocationToMap() {
        if (!appState.map || !appState.userLocation) return;
        
        const userIcon = L.divIcon({
            html: '<div style="background: #3b82f6; width: 20px; height: 20px; border-radius: 50%; border: 3px solid white; box-shadow: 0 2px 6px rgba(0,0,0,0.3);"></div>',
            className: 'user-location-marker',
            iconSize: [20, 20],
            iconAnchor: [10, 10]
        });
        
        L.marker([appState.userLocation.lat, appState.userLocation.lng], {
            icon: userIcon
        })
        .bindPopup('üìç Dein Standort')
        .addTo(appState.map);
    }

    function centerOnUser() {
        if (appState.userLocation && appState.map) {
            appState.map.setView([appState.userLocation.lat, appState.userLocation.lng], 17);
        } else {
            alert('Standort nicht verf√ºgbar. Bitte erlaube Standortzugriff in den Browser-Einstellungen.');
        }
    }

    function updateLocationInfo() {
        if (!appState.userLocation) return;
        
        let nearestStation = null;
        let minDistance = Infinity;
        
        stations.forEach(station => {
            const distance = calculateDistance(
                appState.userLocation.lat, appState.userLocation.lng,
                station.lat, station.lng
            );
            
            if (distance < minDistance) {
                minDistance = distance;
                nearestStation = station;
            }
        });
        
        if (nearestStation) {
            const distanceText = minDistance < 1 
                ? `${Math.round(minDistance * 1000)}m` 
                : `${minDistance.toFixed(1)}km`;
            
            document.getElementById('distanceInfo').textContent = 
                `üìç N√§chste Station: ${nearestStation.title} (${distanceText})`;
        }
    }

    function calculateDistance(lat1, lng1, lat2, lng2) {
        const R = 6371;
        const dLat = (lat2 - lat1) * Math.PI / 180;
        const dLng = (lng2 - lng1) * Math.PI / 180;
        const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                  Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                  Math.sin(dLng/2) * Math.sin(dLng/2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        return R * c;
    }

    // State Management
    function saveState() {
        const stateToSave = {
            ...appState,
            map: null, // Don't save map object
            markers: [] // Don't save markers
        };
        localStorage.setItem('tourState', JSON.stringify(stateToSave));
    }

    function loadState() {
        const saved = localStorage.getItem('tourState');
        if (saved) {
            const savedState = JSON.parse(saved);
            appState = { ...appState, ...savedState };
            updateUI();
            
            // Restore team selection
            if (appState.selectedTeam) {
                const teamOptions = document.querySelectorAll('.team-option');
                teamOptions.forEach(option => {
                    if (option.textContent.includes(appState.teamName)) {
                        option.classList.add('selected');
                    }
                });
                document.getElementById('teamSelector').style.display = 'none';
            }
            
            // Restore uploaded photos
            appState.uploadedPhotos.forEach(photo => {
                const uploadArea = document.getElementById(`upload-area-${photo.stationId}`);
                if (uploadArea) {
                    uploadArea.classList.add('has-photo');
                    uploadArea.innerHTML = `
                        <img src="${photo.imageUrl}" class="photo-preview" alt="Uploaded photo">
                        <p>üì∑ Foto erfolgreich hochgeladen!</p>
                        <small>Klicke hier f√ºr ein neues Foto</small>
                    `;
                    
                    if (photo.score) {
                        const ratingDiv = document.getElementById(`rating-${photo.stationId}`);
                        if (ratingDiv) {
                            ratingDiv.classList.remove('hidden');
                            document.getElementById(`score-${photo.stationId}`).textContent = Math.round(photo.score);
                            
                            if (photo.analysis) {
                                document.getElementById(`rating-text-${photo.stationId}`).innerHTML = `
                                    <strong>KI-Bewertung:</strong><br>
                                    Qualit√§t: ${Math.round(photo.analysis.breakdown.technical.overall)}% | 
                                    Komposition: ${Math.round(photo.analysis.breakdown.composition.overall)}% | 
                                    Kreativit√§t: ${Math.round(photo.analysis.breakdown.creativity)}%
                                `;
                                document.getElementById(`rating-details-${photo.stationId}`).innerHTML = 
                                    photo.analysis.feedback.join('<br>');
                            }
                        }
                    }
                }
            });
        }
    }

    // Initialize app when page loads
    document.addEventListener('DOMContentLoaded', initApp);

    // Service Worker for offline functionality
    if ('serviceWorker' in navigator) {
        navigator.serviceWorker.register(
            'data:application/javascript,' + encodeURIComponent(`
                const CACHE_NAME = 'cologne-tour-v1';
                self.addEventListener('install', event => {
                    self.skipWaiting();
                });
                self.addEventListener('activate', event => {
                    event.waitUntil(clients.claim());
                });
                self.addEventListener('fetch', event => {
                    if (event.request.destination === 'image') {
                        event.respondWith(
                            caches.open(CACHE_NAME).then(cache => {
                                return cache.match(event.request).then(response => {
                                    if (response) return response;
                                    return fetch(event.request).then(fetchResponse => {
                                        cache.put(event.request, fetchResponse.clone());
                                        return fetchResponse;
                                    });
                                });
                            })
                        );
                    }
                });
            `)
        ).catch(console.log);
    }
</script>
```

</body>
</html>
